###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.60.1.40026 for 8051             08/Jun/2018  08:44:37 #
# Copyright (C) 2004-2010 IAR Systems AB.                                     #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Users\win7\Desktop\ZStack传感器透明传输源程序V2 #
#                          .45-13(带回码2018-5-20)\Projects\GenericApp\Source #
#                          \GenericApp.c                                      #
#    Command line       =  -f "C:\Users\win7\Desktop\ZStack传感器透明传输源程 #
#                          序V2.45-13(带回码2018-5-20)\Projects\GenericApp\CC #
#                          2530DB\..\..\..\COMPONENTS\Tools\CC2530DB\f8wRoute #
#                          r.cfg" (-DCPU32MHZ -DROOT=__near_func              #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                   #
#                          -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8         #
#                          -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f                   #
#                          "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V #
#                          2.45-13(带回码2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\Tools\CC2530DB\f8wConfig.c #
#                          fg" (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR  #
#                          -DNWK_START_DELAY=1000 -DEXTENDED_JOINING_RANDOM_M #
#                          ASK=0x007F -DBEACON_REQUEST_DELAY=1000             #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Users\win7\Desktop\ZSta #
#                          ck传感器透明传输源程序V2.45-13(带回码2018-5-20)\Pr #
#                          ojects\GenericApp\Source\GenericApp.c" -D          #
#                          ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC  #
#                          -D xNV_RESTORE -D SERIAL_SUPPORTED=DEBUG -D        #
#                          SENSOR_TYPE=0X31 -D CHANLIST_C_R_E=25 -D           #
#                          ZDAPP_CONFIG_PAN_ID=0x0004 -D                      #
#                          ZigBee_C_R_E_Engineering -D ZigBee_C_R_E_IEEE -D   #
#                          xSENSOR_TYPE_R_E=0X01 -lC                          #
#                          "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V #
#                          2.45-13(带回码2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\Router\List\" -lA "C:\Users\win7\Desktop\ZStac #
#                          k传感器透明传输源程序V2.45-13(带回码2018-5-20)\Pro #
#                          jects\GenericApp\CC2530DB\Router\List\"            #
#                          --diag_suppress Pe001,Pa010 -o                     #
#                          "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V #
#                          2.45-13(带回码2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\Router\Obj\" -e --require_prototypes --debug   #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "C:\Users\win7\Desktop\ZSt #
#                          ack传感器透明传输源程序V2.45-13(带回码2018-5-20)\P #
#                          rojects\GenericApp\CC2530DB\" -I                   #
#                          "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V #
#                          2.45-13(带回码2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\SOURCE\" -I "C:\Users\win7\Desktop\ZStack传 #
#                          感器透明传输源程序V2.45-13(带回码2018-5-20)\Projec #
#                          ts\GenericApp\CC2530DB\..\..\..\COMPONENTS\ZMAIN\T #
#                          I2530DB\" -I "C:\Users\win7\Desktop\ZStack传感器透 #
#                          明传输源程序V2.45-13(带回码2018-5-20)\Projects\Gen #
#                          ericApp\CC2530DB\..\..\..\COMPONENTS\MT\" -I       #
#                          "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V #
#                          2.45-13(带回码2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\HAL\INCLUDE\" -I           #
#                          "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V #
#                          2.45-13(带回码2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\HAL\TARGET\CC2530EB\" -I   #
#                          "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V #
#                          2.45-13(带回码2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\OSAL\MCU\CCSOC\" -I        #
#                          "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V #
#                          2.45-13(带回码2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\OSAL\INCLUDE\" -I          #
#                          "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V #
#                          2.45-13(带回码2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\STACK\AF\" -I              #
#                          "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V #
#                          2.45-13(带回码2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\STACK\NWK\" -I             #
#                          "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V #
#                          2.45-13(带回码2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\STACK\SEC\" -I             #
#                          "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V #
#                          2.45-13(带回码2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\STACK\SAPI\" -I            #
#                          "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V #
#                          2.45-13(带回码2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\STACK\SYS\" -I             #
#                          "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V #
#                          2.45-13(带回码2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\STACK\ZDO\" -I             #
#                          "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V #
#                          2.45-13(带回码2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\ZMAC\F8W\" -I              #
#                          "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V #
#                          2.45-13(带回码2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\ZMAC\" -I                  #
#                          "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V #
#                          2.45-13(带回码2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\SERVICES\SADDR\" -I        #
#                          "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V #
#                          2.45-13(带回码2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\SERVICES\SDATA\" -I        #
#                          "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V #
#                          2.45-13(带回码2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\MAC\INCLUDE\" -I           #
#                          "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V #
#                          2.45-13(带回码2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\MAC\HIGH_LEVEL\" -I        #
#                          "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V #
#                          2.45-13(带回码2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\" -I   #
#                          "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V #
#                          2.45-13(带回码2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE #
#                          _CHIP\" -I "C:\Program Files (x86)\IAR             #
#                          Systems\Embedded Workbench 5.4\8051\INC\" -I       #
#                          "C:\Program Files (x86)\IAR Systems\Embedded       #
#                          Workbench 5.4\8051\INC\CLIB\" -Ohz                 #
#    List file          =  C:\Users\win7\Desktop\ZStack传感器透明传输源程序V2 #
#                          .45-13(带回码2018-5-20)\Projects\GenericApp\CC2530 #
#                          DB\Router\List\GenericApp.lst                      #
#    Object file        =  C:\Users\win7\Desktop\ZStack传感器透明传输源程序V2 #
#                          .45-13(带回码2018-5-20)\Projects\GenericApp\CC2530 #
#                          DB\Router\Obj\GenericApp.r51                       #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\win7\Desktop\ZStack传感器透明传输源程序V2.45-13(带回码2018-5-20)\Projects\GenericApp\Source\GenericApp.c
      1          /**************************************************************************************************
      2            Filename:       GenericApp.c
      3            Revised:        $Date: 2009-03-18 15:56:27 -0700 (Wed, 18 Mar 2009) $
      4            Revision:       $Revision: 19453 $
      5            NLME_SetPollRate( 0 );
      6          ZDApp_StopJoiningCycle();
      7          
      8            Description:    Generic Application (no Profile).
      9            Copyright 2004-2009 Texas Instruments Incorporated. All rights reserved.
     10            IMPORTANT: Your use of this Software is limited to those specific rights
     11            granted under the terms of a software license agreement between the user
     12            who downloaded the software, his/her employer (which must be your employer)
     13            and Texas Instruments Incorporated (the "License").  You may not use this
     14            Software unless you agree to abide by the terms of the License. The License
     15            limits your use, and you acknowledge, that the Software may not be modified,
     16            copied or distributed unless embedded on a Texas Instruments microcontroller
     17            or used solely and exclusively in conjunction with a Texas Instruments radio
     18            frequency transceiver, which is integrated into your product.  Other than for 
     19            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     20            works of, modify, distribute, perform, display or sell this Software and/or
     21            its documentation for any purpose.
     22          
     23            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     24            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     25            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     26            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     27            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     28            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     29            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     30            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     31            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     32            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     33            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     34          
     35            Should you have any questions regarding your right to use this Software,
     36            contact Texas Instruments Incorporated at www.TI.com. 
     37          **************************************************************************************************/
     38           
     39          /*********************************************************************
     40            This application isn't intended to do anything useful, it is
     41            intended to be a simple example of an application's structure.
     42          
     43            This application sends "Hello World" to another "Generic"
     44            application every 15 seconds.  The application will also
     45            receive "Hello World" packets.
     46          
     47            The "Hello World" messages are sent/received as MSG type message.
     48          
     49            This applications doesn't have a profile, so it handles everything
     50            directly - itself.
     51          
     52            Key control:
     53              SW1:
     54              SW2:  initiates end device binding
     55              SW3:
     56              SW4:  initiates a match description request
     57          *********************************************************************/
     58          
     59          /*********************************************************************
     60           * INCLUDES
     61           */
     62          #include "OSAL.h"
     63          #include "AF.h"
     64          #include "ZDApp.h"
     65          #include "ZDObject.h"
     66          #include "ZDProfile.h"
     67          #include "OSAL_Nv.h"
     68          #include "LQ12864.h"

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa0
   \   union <unnamed> volatile __sfr _A_P2
   \                     _A_P2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xcd
   \   unsigned char volatile __sfr T3CC0
   \                     T3CC0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd8
   \   union <unnamed> volatile __sfr _A_TIMIF
   \                     _A_TIMIF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf4
   \   unsigned char volatile __sfr P1SEL
   \                     P1SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xff
   \   unsigned char volatile __sfr P2DIR
   \                     P2DIR:
   \   000000                DS 1

   \                                 In  segment CODE_C, align 1
   \   static char const __code F8X16[1520]
   \                     F8X16:
   \   000000   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 248, 0, 0
   \            00000000
   \            00000000
   \            00000000
   \            000000F8
   \            0000    
   \   000016   00000000     DB 0, 0, 0, 0, 0, 51, 48, 0, 0, 0, 0, 16, 12, 6, 16, 12, 6, 0, 0, 0, 0
   \            00333000
   \            00000010
   \            0C06100C
   \            06000000
   \            00      
   \   00002B   00000000     DB 0, 0, 0, 0, 0, 64, 192, 120, 64, 192, 120, 64, 0, 4, 63, 4, 4, 63, 4
   \            0040C078
   \            40C07840
   \            00043F04
   \            043F04  
   \   00003E   04000070     DB 4, 0, 0, 112, 136, 252, 8, 48, 0, 0, 0, 24, 32, 255, 33, 30, 0, 0
   \            88FC0830
   \            00000018
   \            20FF211E
   \            0000    
   \   000050   F008F000     DB 240, 8, 240, 0, 224, 24, 0, 0, 0, 33, 28, 3, 30, 33, 30, 0, 0, 240
   \            E0180000
   \            00211C03
   \            1E211E00
   \            00F0    
   \   000062   08887000     DB 8, 136, 112, 0, 0, 0, 30, 33, 35, 36, 25, 39, 33, 16, 16, 22, 14, 0
   \            00001E21
   \            23241927
   \            21101016
   \            0E00    
   \   000074   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 224, 24, 4, 2, 0, 0, 0
   \            00000000
   \            00000000
   \            000000E0
   \            18040200
   \            0000    
   \   00008A   00071820     DB 0, 7, 24, 32, 64, 0, 0, 2, 4, 24, 224, 0, 0, 0, 0, 64, 32, 24, 7, 0
   \            40000002
   \            0418E000
   \            00000040
   \            20180700
   \   00009E   00004040     DB 0, 0, 64, 64, 128, 240, 128, 64, 64, 0, 2, 2, 1, 15, 1, 2, 2, 0, 0
   \            80F08040
   \            40000202
   \            010F0102
   \            020000  
   \   0000B1   0000F000     DB 0, 0, 240, 0, 0, 0, 0, 1, 1, 1, 31, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000001
   \            01011F01
   \            01010000
   \            00000000
   \            0000    
   \   0000C7   0080B070     DB 0, 128, 176, 112, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1
   \            00000000
   \            00000000
   \            00000000
   \            00000101
   \            01      
   \   0000DC   01010101     DB 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00000000
   \            00303000
   \            00000000
   \            0000    
   \   0000F2   00008060     DB 0, 0, 128, 96, 24, 4, 0, 96, 24, 6, 1, 0, 0, 0, 0, 224, 16, 8, 8, 16
   \            18040060
   \            18060100
   \            000000E0
   \            10080810
   \   000106   E000000F     DB 224, 0, 0, 15, 16, 32, 32, 16, 15, 0, 0, 16, 16, 248, 0, 0, 0, 0, 0
   \            10202010
   \            0F000010
   \            10F80000
   \            000000  
   \   000119   20203F20     DB 32, 32, 63, 32, 32, 0, 0, 0, 112, 8, 8, 8, 136, 112, 0, 0, 48, 40
   \            20000000
   \            70080808
   \            88700000
   \            3028    
   \   00012B   24222130     DB 36, 34, 33, 48, 0, 0, 48, 8, 136, 136, 72, 48, 0, 0, 24, 32, 32, 32
   \            00003008
   \            88884830
   \            00001820
   \            2020    
   \   00013D   110E0000     DB 17, 14, 0, 0, 0, 192, 32, 16, 248, 0, 0, 0, 7, 4, 36, 36, 63, 36, 0
   \            00C02010
   \            F8000000
   \            07042424
   \            3F2400  
   \   000150   00F80888     DB 0, 248, 8, 136, 136, 8, 8, 0, 0, 25, 33, 32, 32, 17, 14, 0, 0, 224
   \            88080800
   \            00192120
   \            20110E00
   \            00E0    
   \   000162   10888818     DB 16, 136, 136, 24, 0, 0, 0, 15, 17, 32, 32, 17, 14, 0, 0, 56, 8, 8
   \            0000000F
   \            11202011
   \            0E000038
   \            0808    
   \   000174   C8380800     DB 200, 56, 8, 0, 0, 0, 0, 63, 0, 0, 0, 0, 0, 112, 136, 8, 8, 136, 112
   \            0000003F
   \            00000000
   \            00708808
   \            088870  
   \   000187   00001C22     DB 0, 0, 28, 34, 33, 33, 34, 28, 0, 0, 224, 16, 8, 8, 16, 224, 0, 0, 0
   \            2121221C
   \            0000E010
   \            080810E0
   \            000000  
   \   00019A   31222211     DB 49, 34, 34, 17, 15, 0, 0, 0, 0, 192, 192, 0, 0, 0, 0, 0, 0, 48, 48
   \            0F000000
   \            00C0C000
   \            00000000
   \            003030  
   \   0001AD   00000000     DB 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 128, 96, 0, 0, 0, 0, 0, 0
   \            00008000
   \            00000000
   \            00806000
   \            00000000
   \            00      
   \   0001C2   80402010     DB 128, 64, 32, 16, 8, 0, 0, 1, 2, 4, 8, 16, 32, 0, 64, 64, 64, 64, 64
   \            08000001
   \            02040810
   \            20004040
   \            404040  
   \   0001D5   40400004     DB 64, 64, 0, 4, 4, 4, 4, 4, 4, 4, 0, 0, 8, 16, 32, 64, 128, 0, 0, 0
   \            04040404
   \            04040000
   \            08102040
   \            80000000
   \   0001E9   20100804     DB 32, 16, 8, 4, 2, 1, 0, 0, 112, 72, 8, 8, 8, 240, 0, 0, 0, 0, 48, 54
   \            02010000
   \            70480808
   \            08F00000
   \            00003036
   \   0001FD   010000C0     DB 1, 0, 0, 192, 48, 200, 40, 232, 16, 224, 0, 7, 24, 39, 36, 35, 20
   \            30C828E8
   \            10E00007
   \            18272423
   \            14      
   \   00020E   0B000000     DB 11, 0, 0, 0, 192, 56, 224, 0, 0, 0, 32, 60, 35, 2, 2, 39, 56, 32, 8
   \            C038E000
   \            0000203C
   \            23020227
   \            382008  
   \   000221   F8888888     DB 248, 136, 136, 136, 112, 0, 0, 32, 63, 32, 32, 32, 17, 14, 0, 192
   \            70000020
   \            3F202020
   \            110E00C0
   \   000231   30080808     DB 48, 8, 8, 8, 8, 56, 0, 7, 24, 32, 32, 32, 16, 8, 0, 8, 248, 8, 8, 8
   \            08380007
   \            18202020
   \            10080008
   \            F8080808
   \   000245   10E00020     DB 16, 224, 0, 32, 63, 32, 32, 32, 16, 15, 0, 8, 248, 136, 136, 232, 8
   \            3F202020
   \            100F0008
   \            F88888E8
   \            08      
   \   000256   1000203F     DB 16, 0, 32, 63, 32, 32, 35, 32, 24, 0, 8, 248, 136, 136, 232, 8, 16
   \            20202320
   \            180008F8
   \            8888E808
   \            10      
   \   000267   00203F20     DB 0, 32, 63, 32, 0, 3, 0, 0, 0, 192, 48, 8, 8, 8, 56, 0, 0, 7, 24, 32
   \            00030000
   \            00C03008
   \            08083800
   \            00071820
   \   00027B   20221E02     DB 32, 34, 30, 2, 0, 8, 248, 8, 0, 0, 8, 248, 8, 32, 63, 33, 1, 1, 33
   \            0008F808
   \            000008F8
   \            08203F21
   \            010121  
   \   00028E   3F200008     DB 63, 32, 0, 8, 8, 248, 8, 8, 0, 0, 0, 32, 32, 63, 32, 32, 0, 0, 0, 0
   \            08F80808
   \            00000020
   \            203F2020
   \            00000000
   \   0002A2   0808F808     DB 8, 8, 248, 8, 8, 0, 192, 128, 128, 128, 127, 0, 0, 0, 8, 248, 136
   \            0800C080
   \            80807F00
   \            000008F8
   \            88      
   \   0002B3   C0281808     DB 192, 40, 24, 8, 0, 32, 63, 32, 1, 38, 56, 32, 0, 8, 248, 8, 0, 0, 0
   \            00203F20
   \            01263820
   \            0008F808
   \            000000  
   \   0002C6   0000203F     DB 0, 0, 32, 63, 32, 32, 32, 32, 48, 0, 8, 248, 248, 0, 248, 248, 8, 0
   \            20202020
   \            300008F8
   \            F800F8F8
   \            0800    
   \   0002D8   203F003F     DB 32, 63, 0, 63, 0, 63, 32, 0, 8, 248, 48, 192, 0, 8, 248, 8, 32, 63
   \            003F2000
   \            08F830C0
   \            0008F808
   \            203F    
   \   0002EA   20000718     DB 32, 0, 7, 24, 63, 0, 224, 16, 8, 8, 8, 16, 224, 0, 15, 16, 32, 32
   \            3F00E010
   \            08080810
   \            E0000F10
   \            2020    
   \   0002FC   20100F00     DB 32, 16, 15, 0, 8, 248, 8, 8, 8, 8, 240, 0, 32, 63, 33, 1, 1, 1, 0, 0
   \            08F80808
   \            0808F000
   \            203F2101
   \            01010000
   \   000310   E0100808     DB 224, 16, 8, 8, 8, 16, 224, 0, 15, 24, 36, 36, 56, 80, 79, 0, 8, 248
   \            0810E000
   \            0F182424
   \            38504F00
   \            08F8    
   \   000322   88888888     DB 136, 136, 136, 136, 112, 0, 32, 63, 32, 0, 3, 12, 48, 32, 0, 112
   \            7000203F
   \            2000030C
   \            30200070
   \   000332   88080808     DB 136, 8, 8, 8, 56, 0, 0, 56, 32, 33, 33, 34, 28, 0, 24, 8, 8, 248, 8
   \            38000038
   \            20212122
   \            1C001808
   \            08F808  
   \   000345   08180000     DB 8, 24, 0, 0, 0, 32, 63, 32, 0, 0, 0, 8, 248, 8, 0, 0, 8, 248, 8, 0
   \            00203F20
   \            00000008
   \            F8080000
   \            08F80800
   \   000359   1F202020     DB 31, 32, 32, 32, 32, 31, 0, 8, 120, 136, 0, 0, 200, 56, 8, 0, 0, 7
   \            201F0008
   \            78880000
   \            C8380800
   \            0007    
   \   00036B   380E0100     DB 56, 14, 1, 0, 0, 248, 8, 0, 248, 0, 8, 248, 0, 3, 60, 7, 0, 7, 60, 3
   \            00F80800
   \            F80008F8
   \            00033C07
   \            00073C03
   \   00037F   00081868     DB 0, 8, 24, 104, 128, 128, 104, 24, 8, 32, 48, 44, 3, 3, 44, 48, 32, 8
   \            80806818
   \            0820302C
   \            03032C30
   \            2008    
   \   000391   38C800C8     DB 56, 200, 0, 200, 56, 8, 0, 0, 0, 32, 63, 32, 0, 0, 0, 16, 8, 8, 8
   \            38080000
   \            00203F20
   \            00000010
   \            080808  
   \   0003A4   C8380800     DB 200, 56, 8, 0, 32, 56, 38, 33, 32, 32, 24, 0, 0, 0, 0, 254, 2, 2, 2
   \            20382621
   \            20201800
   \            000000FE
   \            020202  
   \   0003B7   00000000     DB 0, 0, 0, 0, 127, 64, 64, 64, 0, 0, 12, 48, 192, 0, 0, 0, 0, 0, 0, 0
   \            7F404040
   \            00000C30
   \            C0000000
   \            00000000
   \   0003CB   010638C0     DB 1, 6, 56, 192, 0, 0, 2, 2, 2, 254, 0, 0, 0, 0, 64, 64, 64, 127, 0, 0
   \            00000202
   \            02FE0000
   \            00004040
   \            407F0000
   \   0003DF   00000004     DB 0, 0, 0, 4, 2, 2, 2, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            02020204
   \            00000000
   \            00000000
   \            00000000
   \            000000  
   \   0003F6   00008080     DB 0, 0, 128, 128, 128, 128, 128, 128, 128, 128, 0, 2, 2, 4, 0, 0, 0, 0
   \            80808080
   \            80800002
   \            02040000
   \            0000    
   \   000408   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 128, 128, 128, 0, 0, 0, 25, 36
   \            00000000
   \            00008080
   \            80800000
   \            001924  
   \   00041B   2222223F     DB 34, 34, 34, 63, 32, 8, 248, 0, 128, 128, 0, 0, 0, 0, 63, 17, 32, 32
   \            2008F800
   \            80800000
   \            00003F11
   \            2020    
   \   00042D   110E0000     DB 17, 14, 0, 0, 0, 0, 128, 128, 128, 0, 0, 0, 14, 17, 32, 32, 32, 17
   \            00008080
   \            80000000
   \            0E112020
   \            2011    
   \   00043F   00000000     DB 0, 0, 0, 0, 128, 128, 136, 248, 0, 0, 14, 17, 32, 32, 16, 63, 32, 0
   \            808088F8
   \            00000E11
   \            2020103F
   \            2000    
   \   000451   00808080     DB 0, 128, 128, 128, 128, 0, 0, 0, 31, 34, 34, 34, 34, 19, 0, 0, 128
   \            80000000
   \            1F222222
   \            22130000
   \            80      
   \   000462   80F08888     DB 128, 240, 136, 136, 136, 24, 0, 32, 32, 63, 32, 32, 0, 0, 0, 0, 128
   \            88180020
   \            203F2020
   \            00000000
   \            80      
   \   000473   80808080     DB 128, 128, 128, 128, 0, 0, 107, 148, 148, 148, 147, 96, 0, 8, 248, 0
   \            00006B94
   \            94949360
   \            0008F800
   \   000483   80808000     DB 128, 128, 128, 0, 0, 32, 63, 33, 0, 0, 32, 63, 32, 0, 128, 152, 152
   \            00203F21
   \            0000203F
   \            20008098
   \            98      
   \   000494   00000000     DB 0, 0, 0, 0, 0, 32, 32, 63, 32, 32, 0, 0, 0, 0, 0, 128, 152, 152, 0
   \            0020203F
   \            20200000
   \            00000080
   \            989800  
   \   0004A7   0000C080     DB 0, 0, 192, 128, 128, 128, 127, 0, 0, 8, 248, 0, 0, 128, 128, 128, 0
   \            80807F00
   \            0008F800
   \            00808080
   \            00      
   \   0004B8   203F2402     DB 32, 63, 36, 2, 45, 48, 32, 0, 0, 8, 8, 248, 0, 0, 0, 0, 0, 32, 32
   \            2D302000
   \            000808F8
   \            00000000
   \            002020  
   \   0004CB   3F202000     DB 63, 32, 32, 0, 0, 128, 128, 128, 128, 128, 128, 128, 0, 32, 63, 32
   \            00808080
   \            80808080
   \            00203F20
   \   0004DB   003F2000     DB 0, 63, 32, 0, 63, 128, 128, 0, 128, 128, 128, 0, 0, 32, 63, 33, 0, 0
   \            3F808000
   \            80808000
   \            00203F21
   \            0000    
   \   0004ED   203F2000     DB 32, 63, 32, 0, 0, 128, 128, 128, 128, 0, 0, 0, 31, 32, 32, 32, 32
   \            00808080
   \            80000000
   \            1F202020
   \            20      
   \   0004FE   1F008080     DB 31, 0, 128, 128, 0, 128, 128, 0, 0, 0, 128, 255, 161, 32, 32, 17, 14
   \            00808000
   \            000080FF
   \            A1202011
   \            0E      
   \   00050F   00000000     DB 0, 0, 0, 0, 128, 128, 128, 128, 0, 0, 14, 17, 32, 32, 160, 255, 128
   \            80808080
   \            00000E11
   \            2020A0FF
   \            80      
   \   000520   80808000     DB 128, 128, 128, 0, 128, 128, 128, 0, 32, 32, 63, 33, 32, 0, 1, 0, 0
   \            80808000
   \            20203F21
   \            20000100
   \            00      
   \   000531   00808080     DB 0, 128, 128, 128, 128, 128, 0, 0, 51, 36, 36, 36, 36, 25, 0, 0, 128
   \            80800000
   \            33242424
   \            24190000
   \            80      
   \   000542   80E08080     DB 128, 224, 128, 128, 0, 0, 0, 0, 0, 31, 32, 32, 0, 0, 128, 128, 0, 0
   \            00000000
   \            001F2020
   \            00008080
   \            0000    
   \   000554   00808000     DB 0, 128, 128, 0, 0, 31, 32, 32, 32, 16, 63, 32, 128, 128, 128, 0, 0
   \            001F2020
   \            20103F20
   \            80808000
   \            00      
   \   000565   80808000     DB 128, 128, 128, 0, 1, 14, 48, 8, 6, 1, 0, 128, 128, 0, 128, 0, 128
   \            010E3008
   \            06010080
   \            80008000
   \            80      
   \   000576   80800F30     DB 128, 128, 15, 48, 12, 3, 12, 48, 15, 0, 0, 128, 128, 0, 128, 128
   \            0C030C30
   \            0F000080
   \            80008080
   \   000586   80000020     DB 128, 0, 0, 32, 49, 46, 14, 49, 32, 0, 128, 128, 128, 0, 0, 128, 128
   \            312E0E31
   \            20008080
   \            80000080
   \            80      
   \   000597   8080818E     DB 128, 128, 129, 142, 112, 24, 6, 1, 0, 0, 128, 128, 128, 128, 128
   \            70180601
   \            00008080
   \            808080  
   \   0005A6   80000021     DB 128, 0, 0, 33, 48, 44, 34, 33, 48, 0, 0, 0, 0, 0, 128, 124, 2, 2, 0
   \            302C2221
   \            30000000
   \            0000807C
   \            020200  
   \   0005B9   00000000     DB 0, 0, 0, 0, 63, 64, 64, 0, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 255, 0
   \            3F404000
   \            000000FF
   \            00000000
   \            000000FF
   \            00      
   \   0005CE   00000002     DB 0, 0, 0, 2, 2, 124, 128, 0, 0, 0, 0, 64, 64, 63, 0, 0, 0, 0, 0, 6, 1
   \            027C8000
   \            00000040
   \            403F0000
   \            00000006
   \            01      
   \   0005E3   01020204     DB 1, 2, 2, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0
   \            04000000
   \            00000000
   \            00      

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant void OLED_delay(unsigned int)
   \                     OLED_delay:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   EA           MOV     A,R2
   \   000001   F8           MOV     R0,A
   \   000002   EB           MOV     A,R3
   \   000003   8007         SJMP    ??OLED_delay_0
   \                     ??OLED_delay_1:
   \   000005   E8           MOV     A,R0
   \   000006   24FF         ADD     A,#-0x1
   \   000008   18           DEC     R0
   \   000009   E9           MOV     A,R1
   \   00000A   34FF         ADDC    A,#-0x1
   \                     ??OLED_delay_0:
   \   00000C   F9           MOV     R1,A
   \   00000D   E8           MOV     A,R0
   \   00000E   7001         JNZ     ??OLED_delay_2
   \   000010   E9           MOV     A,R1
   \                     ??OLED_delay_2:
   \   000011   00           NOP
   \   000012   70F1         JNZ     ??OLED_delay_1
   \   000014   80..         SJMP    ??Subroutine31_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine31_0:
   \   000000   00           NOP
   \   000001   00           NOP
   \   000002   00           NOP
   \   000003   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant void OLED_IIC_Start(void)
   \                     OLED_IIC_Start:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   D2A2         SETB    0xa0.2
   \   000002   D2A1         SETB    0xa0.1
   \   000004   00           NOP
   \   000005   00           NOP
   \   000006   00           NOP
   \   000007   00           NOP
   \   000008   00           NOP
   \   000009   C2A1         CLR     0xa0.1
   \   00000B   80..         SJMP    ?Subroutine0
   \   00000D                REQUIRE _A_P2

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   C2A2         CLR     0xa0.2
   \   000002                REQUIRE ??Subroutine30_0
   \   000002                ; // Fall through to label ??Subroutine30_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine30_0:
   \   000000   00           NOP
   \   000001   00           NOP
   \   000002                REQUIRE ??Subroutine31_0
   \   000002                ; // Fall through to label ??Subroutine31_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant void OLED_IIC_Stop(void)
   \                     OLED_IIC_Stop:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   C2A2         CLR     0xa0.2
   \   000002   C2A1         CLR     0xa0.1
   \   000004   00           NOP
   \   000005   00           NOP
   \   000006   00           NOP
   \   000007   00           NOP
   \   000008   00           NOP
   \   000009   D2A2         SETB    0xa0.2
   \   00000B   D2A1         SETB    0xa0.1
   \   00000D   80..         SJMP    ??Subroutine30_0
   \   00000F                REQUIRE _A_P2

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant void Write_IIC_Byte(unsigned char)
   \                     Write_IIC_Byte:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   7A08         MOV     R2,#0x8
   \                     ??Write_IIC_Byte_0:
   \   000002   E9           MOV     A,R1
   \   000003   A2E7         MOV     C,0xE0 /* A   */.7
   \   000005   5004         JNC     ??Write_IIC_Byte_1
   \   000007   D2A1         SETB    0xa0.1
   \   000009   8002         SJMP    ??Write_IIC_Byte_2
   \                     ??Write_IIC_Byte_1:
   \   00000B   C2A1         CLR     0xa0.1
   \                     ??Write_IIC_Byte_2:
   \   00000D   D2A2         SETB    0xa0.2
   \   00000F   00           NOP
   \   000010   00           NOP
   \   000011   00           NOP
   \   000012   00           NOP
   \   000013   00           NOP
   \   000014   C2A2         CLR     0xa0.2
   \   000016   C3           CLR     C
   \   000017   33           RLC     A
   \   000018   F9           MOV     R1,A
   \   000019   00           NOP
   \   00001A   00           NOP
   \   00001B   00           NOP
   \   00001C   00           NOP
   \   00001D   00           NOP
   \   00001E   1A           DEC     R2
   \   00001F   EA           MOV     A,R2
   \   000020   70E0         JNZ     ??Write_IIC_Byte_0
   \   000022   D2A1         SETB    0xa0.1
   \   000024   D2A2         SETB    0xa0.2
   \   000026   00           NOP
   \   000027   00           NOP
   \   000028   00           NOP
   \   000029   00           NOP
   \   00002A   00           NOP
   \   00002B   80..         SJMP    ?Subroutine0
   \   00002D                REQUIRE _A_P2

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant void OLED_WrDat(unsigned char)
   \                     OLED_WrDat:
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000008                ; Setup parameters for call to function Write_IIC_Byte
   \   000008   7940         MOV     R1,#0x40
   \   00000A   80..         SJMP    ?Subroutine1

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   E9           MOV     A,R1
   \   000001   FE           MOV     R6,A
   \   000002                ; Setup parameters for call to function OLED_IIC_Start
   \   000002                ; Setup parameters for call to function OLED_IIC_Start
   \   000002   12....       LCALL   ??OLED_IIC_Start?relay
   \   000005                ; Setup parameters for call to function Write_IIC_Byte
   \   000005                ; Setup parameters for call to function Write_IIC_Byte
   \   000005   7978         MOV     R1,#0x78
   \   000007   12....       LCALL   ??Write_IIC_Byte?relay
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL   ??Write_IIC_Byte?relay
   \   000003                ; Setup parameters for call to function Write_IIC_Byte
   \   000003                ; Setup parameters for call to function Write_IIC_Byte
   \   000003   EE           MOV     A,R6
   \   000004   F9           MOV     R1,A
   \   000005   12....       LCALL   ??Write_IIC_Byte?relay
   \   000008                ; Setup parameters for call to function OLED_IIC_Stop
   \   000008                ; Setup parameters for call to function OLED_IIC_Stop
   \   000008   12....       LCALL   ??OLED_IIC_Stop?relay
   \   00000B                REQUIRE ??Subroutine32_0
   \   00000B                ; // Fall through to label ??Subroutine32_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine32_0:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant void OLED_WrCmd(unsigned char)
   \                     OLED_WrCmd:
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000008                ; Setup parameters for call to function Write_IIC_Byte
   \   000008   7900         MOV     R1,#0x0
   \   00000A   80..         SJMP    ?Subroutine1

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant void OLED_Set_Pos(unsigned char, unsigned char)
   \                     OLED_Set_Pos:
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   EA           MOV     A,R2
   \   000008   FF           MOV     R7,A
   \   000009                ; Setup parameters for call to function OLED_WrCmd
   \   000009   74B0         MOV     A,#-0x50
   \   00000B   2F           ADD     A,R7
   \   00000C   F9           MOV     R1,A
   \   00000D   12....       LCALL   ??OLED_WrCmd?relay
   \   000010                ; Setup parameters for call to function OLED_WrCmd
   \   000010   EE           MOV     A,R6
   \   000011   C4           SWAP    A
   \   000012   540F         ANL     A,#0xf
   \   000014   4410         ORL     A,#0x10
   \   000016   F9           MOV     R1,A
   \   000017   12....       LCALL   ??OLED_WrCmd?relay
   \   00001A                ; Setup parameters for call to function OLED_WrCmd
   \   00001A   740F         MOV     A,#0xf
   \   00001C   5E           ANL     A,R6
   \   00001D   4401         ORL     A,#0x1
   \   00001F   F9           MOV     R1,A
   \   000020   12....       LCALL   ??OLED_WrCmd?relay
   \   000023   80..         SJMP    ??Subroutine32_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant void OLED_Fill(unsigned char)
   \                     OLED_Fill:
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   75..00       MOV     ?V0 + 0,#0x0
   \                     ??OLED_Fill_0:
   \   00000A                ; Setup parameters for call to function OLED_WrCmd
   \   00000A   74B0         MOV     A,#-0x50
   \   00000C   25..         ADD     A,?V0 + 0
   \   00000E   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000011   7F80         MOV     R7,#-0x80
   \                     ??OLED_Fill_1:
   \   000013                ; Setup parameters for call to function OLED_WrDat
   \   000013   EE           MOV     A,R6
   \   000014   F9           MOV     R1,A
   \   000015   12....       LCALL   ??OLED_WrDat?relay
   \   000018   1F           DEC     R7
   \   000019   EF           MOV     A,R7
   \   00001A   70F7         JNZ     ??OLED_Fill_1
   \   00001C   05..         INC     ?V0 + 0
   \   00001E   E5..         MOV     A,?V0 + 0
   \   000020   C3           CLR     C
   \   000021   9408         SUBB    A,#0x8
   \   000023   40E5         JC      ??OLED_Fill_0
   \   000025   80..         SJMP    ??Subroutine32_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   F9           MOV     R1,A
   \   000001   12....       LCALL   ??OLED_WrCmd?relay
   \   000004                ; Setup parameters for call to function OLED_WrCmd
   \   000004                ; Setup parameters for call to function OLED_WrCmd
   \   000004   7901         MOV     R1,#0x1
   \   000006   12....       LCALL   ??OLED_WrCmd?relay
   \   000009                ; Setup parameters for call to function OLED_WrCmd
   \   000009                ; Setup parameters for call to function OLED_WrCmd
   \   000009   7910         MOV     R1,#0x10
   \   00000B   12....       LCALL   ??OLED_WrCmd?relay
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant void OLED_CLS(void)
   \                     OLED_CLS:
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   7F00         MOV     R7,#0x0
   \                     ??OLED_CLS_0:
   \   000007                ; Setup parameters for call to function OLED_WrCmd
   \   000007   74B0         MOV     A,#-0x50
   \   000009   2F           ADD     A,R7
   \   00000A   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   00000D   7E80         MOV     R6,#-0x80
   \                     ??OLED_CLS_1:
   \   00000F                ; Setup parameters for call to function OLED_WrDat
   \   00000F   7900         MOV     R1,#0x0
   \   000011   12....       LCALL   ??OLED_WrDat?relay
   \   000014   1E           DEC     R6
   \   000015   EE           MOV     A,R6
   \   000016   70F7         JNZ     ??OLED_CLS_1
   \   000018   0F           INC     R7
   \   000019   EF           MOV     A,R7
   \   00001A   C3           CLR     C
   \   00001B   9408         SUBB    A,#0x8
   \   00001D   40E8         JC      ??OLED_CLS_0
   \   00001F   80..         SJMP    ??Subroutine32_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant void OLED_Init(void)
   \                     OLED_Init:
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   43FF06       ORL     0xff,#0x6
   \   000007   E5FF         MOV     A,0xff
   \   000009                ; Setup parameters for call to function OLED_delay
   \   000009   7AF4         MOV     R2,#-0xc
   \   00000B   7B01         MOV     R3,#0x1
   \   00000D   12....       LCALL   ??OLED_delay?relay
   \   000010                ; Setup parameters for call to function OLED_WrCmd
   \   000010   79AE         MOV     R1,#-0x52
   \   000012   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000015                ; Setup parameters for call to function OLED_WrCmd
   \   000015   7910         MOV     R1,#0x10
   \   000017   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   00001A                ; Setup parameters for call to function OLED_WrCmd
   \   00001A   7981         MOV     R1,#-0x7f
   \   00001C   12....       LCALL   ??OLED_WrCmd?relay
   \   00001F                ; Setup parameters for call to function OLED_WrCmd
   \   00001F   79CF         MOV     R1,#-0x31
   \   000021   12....       LCALL   ??OLED_WrCmd?relay
   \   000024                ; Setup parameters for call to function OLED_WrCmd
   \   000024   79A1         MOV     R1,#-0x5f
   \   000026   12....       LCALL   ??OLED_WrCmd?relay
   \   000029                ; Setup parameters for call to function OLED_WrCmd
   \   000029   79C8         MOV     R1,#-0x38
   \   00002B   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   00002E                ; Setup parameters for call to function OLED_WrCmd
   \   00002E   79A8         MOV     R1,#-0x58
   \   000030   12....       LCALL   ??OLED_WrCmd?relay
   \   000033                ; Setup parameters for call to function OLED_WrCmd
   \   000033   793F         MOV     R1,#0x3f
   \   000035   12....       LCALL   ??OLED_WrCmd?relay
   \   000038                ; Setup parameters for call to function OLED_WrCmd
   \   000038   79D3         MOV     R1,#-0x2d
   \   00003A   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   00003D                ; Setup parameters for call to function OLED_WrCmd
   \   00003D   79D5         MOV     R1,#-0x2b
   \   00003F   12....       LCALL   ??OLED_WrCmd?relay
   \   000042                ; Setup parameters for call to function OLED_WrCmd
   \   000042   7980         MOV     R1,#-0x80
   \   000044   12....       LCALL   ??OLED_WrCmd?relay
   \   000047                ; Setup parameters for call to function OLED_WrCmd
   \   000047   79D9         MOV     R1,#-0x27
   \   000049   12....       LCALL   ??OLED_WrCmd?relay
   \   00004C                ; Setup parameters for call to function OLED_WrCmd
   \   00004C   79F1         MOV     R1,#-0xf
   \   00004E   12....       LCALL   ??OLED_WrCmd?relay
   \   000051                ; Setup parameters for call to function OLED_WrCmd
   \   000051   79DA         MOV     R1,#-0x26
   \   000053   12....       LCALL   ??OLED_WrCmd?relay
   \   000056                ; Setup parameters for call to function OLED_WrCmd
   \   000056   7912         MOV     R1,#0x12
   \   000058   12....       LCALL   ??OLED_WrCmd?relay
   \   00005B                ; Setup parameters for call to function OLED_WrCmd
   \   00005B   79DB         MOV     R1,#-0x25
   \   00005D   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000060                ; Setup parameters for call to function OLED_WrCmd
   \   000060   7920         MOV     R1,#0x20
   \   000062   12....       LCALL   ??OLED_WrCmd?relay
   \   000065                ; Setup parameters for call to function OLED_WrCmd
   \   000065   7902         MOV     R1,#0x2
   \   000067   12....       LCALL   ??OLED_WrCmd?relay
   \   00006A                ; Setup parameters for call to function OLED_WrCmd
   \   00006A   798D         MOV     R1,#-0x73
   \   00006C   12....       LCALL   ??OLED_WrCmd?relay
   \   00006F                ; Setup parameters for call to function OLED_WrCmd
   \   00006F   7914         MOV     R1,#0x14
   \   000071   12....       LCALL   ??OLED_WrCmd?relay
   \   000074                ; Setup parameters for call to function OLED_WrCmd
   \   000074   79A4         MOV     R1,#-0x5c
   \   000076   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000079                ; Setup parameters for call to function OLED_WrCmd
   \   000079   79AF         MOV     R1,#-0x51
   \   00007B   12....       LCALL   ??OLED_WrCmd?relay
   \   00007E                ; Setup parameters for call to function OLED_Fill
   \   00007E   7900         MOV     R1,#0x0
   \   000080   12....       LCALL   ??OLED_Fill?relay
   \   000083                ; Setup parameters for call to function OLED_Set_Pos
   \   000083   7A00         MOV     R2,#0x0
   \   000085   7900         MOV     R1,#0x0
   \   000087   12....       LCALL   ??OLED_Set_Pos?relay
   \   00008A   D083         POP     DPH
   \   00008C   D082         POP     DPL
   \   00008E   02....       LJMP    ?BRET
   \   000091                REQUIRE P2DIR

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   12....       LCALL   ??OLED_WrCmd?relay
   \   000003                ; Setup parameters for call to function OLED_WrCmd
   \   000003                ; Setup parameters for call to function OLED_WrCmd
   \   000003   79A6         MOV     R1,#-0x5a
   \   000005   12....       LCALL   ??OLED_WrCmd?relay
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   12....       LCALL   ??OLED_WrCmd?relay
   \   000003                ; Setup parameters for call to function OLED_WrCmd
   \   000003                ; Setup parameters for call to function OLED_WrCmd
   \   000003   7940         MOV     R1,#0x40
   \   000005   12....       LCALL   ??OLED_WrCmd?relay
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   12....       LCALL   ??OLED_WrCmd?relay
   \   000003                ; Setup parameters for call to function OLED_WrCmd
   \   000003                ; Setup parameters for call to function OLED_WrCmd
   \   000003   7900         MOV     R1,#0x0
   \   000005   12....       LCALL   ??OLED_WrCmd?relay
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant void OLED_P8x16Str(unsigned char, unsigned char, char *)
   \                     OLED_P8x16Str:
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   8A..         MOV     ?V0 + 1,R2
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   \   00000D   43FF06       ORL     0xff,#0x6
   \   000010   E5FF         MOV     A,0xff
   \   000012   75..00       MOV     ?V0 + 7,#0x0
   \   000015   805D         SJMP    ??OLED_P8x16Str_0
   \                     ??OLED_P8x16Str_1:
   \   000017   24E0         ADD     A,#-0x20
   \   000019   F5..         MOV     ?V0 + 4,A
   \   00001B   E5..         MOV     A,?V0 + 0
   \   00001D   C3           CLR     C
   \   00001E   9479         SUBB    A,#0x79
   \   000020   4005         JC      ??OLED_P8x16Str_2
   \   000022   75..00       MOV     ?V0 + 0,#0x0
   \   000025   05..         INC     ?V0 + 1
   \                     ??OLED_P8x16Str_2:
   \   000027                ; Setup parameters for call to function OLED_Set_Pos
   \   000027   AA..         MOV     R2,?V0 + 1
   \   000029   A9..         MOV     R1,?V0 + 0
   \   00002B   12....       LCALL   ??OLED_Set_Pos?relay
   \   00002E   75..00       MOV     ?V0 + 6,#0x0
   \   000031   75..00       MOV     ?V0 + 5,#0x0
   \   000034   7404         MOV     A,#0x4
   \   000036   78..         MOV     R0,#?V0 + 4
   \   000038   12....       LCALL   ?S_SHL
   \   00003B   85....       MOV     ?V0 + 2,?V0 + 4
   \   00003E   85....       MOV     ?V0 + 3,?V0 + 5
   \                     ??OLED_P8x16Str_3:
   \   000041                ; Setup parameters for call to function OLED_WrDat
   \   000041   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000044   24..         ADD     A,#(F8X16 & 0xff)
   \   000046   F582         MOV     DPL,A
   \   000048   E9           MOV     A,R1
   \   000049   34..         ADDC    A,#((F8X16 >> 8) & 0xff)
   \   00004B   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   00004E   40F1         JC      ??OLED_P8x16Str_3
   \   000050                ; Setup parameters for call to function OLED_Set_Pos
   \   000050   7401         MOV     A,#0x1
   \   000052   25..         ADD     A,?V0 + 1
   \   000054   FA           MOV     R2,A
   \   000055   A9..         MOV     R1,?V0 + 0
   \   000057   12....       LCALL   ??OLED_Set_Pos?relay
   \   00005A   75..00       MOV     ?V0 + 6,#0x0
   \                     ??OLED_P8x16Str_4:
   \   00005D                ; Setup parameters for call to function OLED_WrDat
   \   00005D   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   000060   24..         ADD     A,#((F8X16 + 8) & 0xff)
   \   000062   F582         MOV     DPL,A
   \   000064   E9           MOV     A,R1
   \   000065   34..         ADDC    A,#(((F8X16 + 8) >> 8) & 0xff)
   \   000067   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00006A   40F1         JC      ??OLED_P8x16Str_4
   \   00006C   7408         MOV     A,#0x8
   \   00006E   25..         ADD     A,?V0 + 0
   \   000070   F5..         MOV     ?V0 + 0,A
   \   000072   05..         INC     ?V0 + 7
   \                     ??OLED_P8x16Str_0:
   \   000074   85....       MOV     ?V0 + 2,?V0 + 7
   \   000077   EE           MOV     A,R6
   \   000078   25..         ADD     A,?V0 + 2
   \   00007A   F582         MOV     DPL,A
   \   00007C   EF           MOV     A,R7
   \   00007D   3400         ADDC    A,#0x0
   \   00007F   F583         MOV     DPH,A
   \   000081   E0           MOVX    A,@DPTR
   \   000082   7093         JNZ     ??OLED_P8x16Str_1
   \   000084   53FFF9       ANL     0xff,#0xf9
   \   000087   E5FF         MOV     A,0xff
   \   000089   7F08         MOV     R7,#0x8
   \   00008B   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00008E                REQUIRE P2DIR

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   85....       MOV     ?V0 + 4,?V0 + 6
   \   000003   E5..         MOV     A,?V0 + 4
   \   000005   25..         ADD     A,?V0 + 2
   \   000007   F8           MOV     R0,A
   \   000008   E4           CLR     A
   \   000009   35..         ADDC    A,?V0 + 3
   \   00000B   F9           MOV     R1,A
   \   00000C   E8           MOV     A,R0
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   F583         MOV     DPH,A
   \   000002   E4           CLR     A
   \   000003   93           MOVC    A,@A+DPTR
   \   000004   F9           MOV     R1,A
   \   000005   12....       LCALL   ??OLED_WrDat?relay
   \   000008   05..         INC     ?V0 + 6
   \   00000A   E5..         MOV     A,?V0 + 6
   \   00000C   C3           CLR     C
   \   00000D   9408         SUBB    A,#0x8
   \   00000F   22           RET
     69          #include "delay.h"
     70          
     71          #include "GenericApp.h"
     72          #include "DebugTrace.h"
     73          
     74          #if !defined( WIN32 )
     75            #include "OnBoard.h"
     76          #endif
     77          
     78          /* HAL */
     79          
     80          #include "hal_adc.h"
     81          #include "hal_lcd.h"
     82          #include "hal_led.h"
     83          #include "hal_key.h"  
     84          #include "hal_uart.h"
     85          #include "MT_UART.h"
     86          #include "appr51.h"
     87          #if((SENSOR_TYPE =='U')||(SENSOR_TYPE ==0X06))
     88          #include "18B20.h"
     89          #endif 
     90          #if(SENSOR_TYPE =='E')
     91          #include "SHT1x.h"  
     92          #endif 
     93          #if(SENSOR_TYPE ==0X85)
     94          #include "MLX90615.h" 
     95            char data[9]={0x5A,0x5a,0x45,0x04,0x00,0x00,0xaa,0xaa,0x00};
     96          #endif 
     97          #if(SENSOR_TYPE ==0X08) 
     98          #define TRF7970A   //如果 是TRF7970A打开此定义 。如果是TRF7960屏蔽此定义
     99          #endif
    100          #if(SENSOR_TYPE ==0X82)
    101          #include "HMC5883.H"  
    102          #define PI  3.14159265
    103          #define M_PI  3.14159265
    104          unsigned char T_MUMPT_y=0;    // 记录数值进行比较
    105          unsigned char T_MUMPT_z=0;    // 记录数值进行比较
    106          float HMC5883_x,HMC5883_y,HMC5883_z;
    107          #endif 
    108          #if(SENSOR_TYPE ==0X07)
    109          unsigned char AB;
    110          #endif
    111          #if(SENSOR_TYPE ==0X14) 
    112          #if defined(PH_E201C)
    113          #include "18B20.h"
    114          #endif 
    115          #endif 
    116          
    117          #if(ZDO_COORDINATOR==2)  //ZIGBEE  AT命令模式 透传模式
    118          uint8 FT_AT=0;//0 命令模式//1 透传模式
    119          #endif
    120          
    121          #if defined (NB_IOT_S10)
    122            unsigned char NBliucheng=0;//流程标号
    123            unsigned int NBjishu=0;//计数周期
    124            unsigned char NB_IMEI[16]={0};//IMEI号
    125            unsigned char NB_S=0;//内容长度
    126          #endif
    127          
    128          #if(SENSOR_TYPE ==0X76)
    129           unsigned int lens=0;
    130           unsigned char p=0;
    131          #endif
    132          #if(SENSOR_TYPE ==0X65)
    133          #include "lcd12232.h"
    134          #endif 
    135          #if(SENSOR_TYPE ==0X6B)
    136          //#define LEDA8  //定义 A8广告机 屏蔽 led显示屏
    137          //#define LED16X64  //定义led显示屏
    138          #endif
    139          #if(SENSOR_TYPE ==0X6C)
    140          #define CS P1_7//片选信号
    141           #define SDA P1_6//数据信号
    142           #define SCLK P1_5//时钟信号 
    143          #define code __code
    144          #define com  0
    145          #define dat  1
    146          const unsigned char code tab0[]={
    147          "  无锡泛太科技    公交管理系统  "}; 
    148          const unsigned char code tab1[]={
    149          "    路公交未驶出公交首末站, 请乘客耐心等待"};   
    150          const unsigned char code tab2[]={
    151          "    路公交已到达本站, 请乘客按次序上下车"};  
    152          const unsigned char code tab3[]={
    153          "    路公交离本站还有    站, 预计    分钟后到达"};
    154          
    155          unsigned char str0[];
    156          //unsigned char str1[]={"0123456789"};
    157          const unsigned char code str1[]={
    158          "0 1 2 3 4 5 6 7 8 9 " 
    159          };
    160          const unsigned char code str2[]="无锡公交首末站  ";
    161          const unsigned char code str3[]="  无锡火车站    ";
    162          const unsigned char code str4[]="    江南大学    ";
    163          const unsigned char code str5[]="    蠡湖公园    ";
    164          
    165          #endif 
    166          #if(SENSOR_TYPE ==0X6F)
    167          #define CS P1_7//片选信号
    168           #define SDA P1_6//数据信号
    169           #define SCLK P1_5//时钟信号 
    170          #define code __code
    171          #define com  0
    172          #define dat  1
    173          #endif 
    174          #if(SENSOR_TYPE ==0X28)
    175          #include "LCD_SPI.h"
    176          #endif 
    177          #if(SENSOR_TYPE ==0X33)
    178          #include "B_LUX_V30.h"
    179          #endif 
    180          #if(SENSOR_TYPE ==0X83)
    181          unsigned char PDI=0;
    182          #endif  
    183          
    184          #if(SENSOR_TYPE ==0X6A) 
    185          #if defined(HX711P) 
    186          #include <HX711.h>   
    187          #endif 
    188          #endif 
    189          #if(SENSOR_TYPE ==0X79)
    190          #include "SHT1x.h"  
    191          unsigned char PDI=0;
    192          unsigned char ERR_TEMP=0;
    193          unsigned char T_TEMP=0;
    194          unsigned char T_ADC=0;
    195          #endif  
    196          #if(SENSOR_TYPE ==0X66)
    197          #include "LCD.h"
    198          unsigned char Disp_Tab[10] ={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90};
    199          unsigned int LedNumVal=88;
    200          unsigned char LEDtime=0;//LED显示时间记录
    201          unsigned char LED_HL=0;//LED显示数码短
    202          #endif 
    203          
    204          #if(SENSOR_TYPE ==0X78)
    205          unsigned char data_buf[9]={0};
    206          unsigned char data_RPY=0;
    207          //int ROLL=0,PITCH=0,YAW=0;
    208          //int rpy[3]={0},Acc[3]={0},Gyr[3]={0},Mag[3]={0},Q[4]={0};
    209          
    210          #endif  
    211          #if(SENSOR_TYPE ==0X81)
    212           unsigned int max_byte ,bytee,t; 
    213          #define SO P1_5 
    214          #define CS P1_6 
    215          #define SCK P1_7
    216          #endif
    217          #if(SENSOR_TYPE ==0X6E)
    218          #include "LCD.h"
    219          #endif 
    220          #if(SENSOR_TYPE =='Q')
    221          #include <HX711.h>
    222          #include <HT1621B.h>
    223          uchar  Ht1621Tab[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
    224          uchar  table1[]={0x0B,0x00,0x07,0x05,0x0C,0x0D,0x0F,0x00,0x0F,0x0D};//0123456789
    225          uchar  table2[]={0x0E,0x06,0x0C,0x0E,0x06,0x0A,0x0A,0x0E,0x0E,0x0E};//0123456789
    226          unsigned char  RS=0, RSn=0;
    227          unsigned char  HXS=0,HX_Q=0;
    228          unsigned int  HXtime=0;
    229          unsigned char AD_SHINING=83;  //调节承重误差参数  50-150之间
    230          #endif 
    231          //定时3
    232          /* 清除TIMER3中断标志位 */
    233          /********************************************************************/
    234          #define CLR_TIMER34_IF( bitMask ) TIMIF=(TIMIF&0x40)|(0x3F&(~bitMask))
    235          /* 初始化定时器3宏定义 */
    236          #define TIMER34_INIT(timer)   \
    237             do {                       \
    238                T##timer##CTL   = 0xEF; \
    239             } while (0)
    240          // 定时器3使能
    241          #define TIMER3_RUN(value)      (T3CTL = (value) ? T3CTL | 0x10 : T3CTL & ~0x10)
    242          /********************************************************************/
    243          #define NOP()  asm("NOP")
    244          #if(SENSOR_TYPE =='B')
    245          #include  "mma7660.h"
    246          #endif 
    247          #if(SENSOR_TYPE =='C')
    248          #include "IIC.h"
    249          #endif 
    250          #if(SENSOR_TYPE =='F')
    251          #if defined(BMP085) 
    252          #include "IIC.h"
    253          #endif 
    254          #if defined(BMP180) 
    255          #include "bmp180.h"
    256                
    257          #endif 
    258          #endif 
    259          
    260          
    261          
    262          /*********************************************************************
    263           * MACROS
    264           */
    265          #if(SENSOR_TYPE =='B')
    266          #define uchar unsigned char
    267          #define uint unsigned int
    268          int Xavg8,Yavg8,Zavg8;//存放平均值
    269          int Xraw[RawDataLength],Yraw[RawDataLength],Zraw[RawDataLength]; //8个空间的数组，采集8个数取一次平均
    270          int Xnew8,Ynew8,Znew8;//新采集到的数据
    271          int RawDataPointer = 0;
    272          #endif  
    273          #if(SENSOR_TYPE =='C')
    274          #define _BH1710FVC_DEF_
    275          #define uchar unsigned char
    276          #define uint unsigned int
    277          //1710指令定义
    278          #define power_down 0x00
    279          #define power_on 0x01
    280          #define reset 0x07
    281          #define h_resolution_mod 0x10
    282          #define m_resolution_mod 0x13
    283          #define l_resolution_mod 0x16
    284          #define onetime_h 0x20
    285          #define onetime_m 0x23
    286          #define onetime_l 0x26
    287          #define write_1710 0x46
    288          #define read_1710 0x47
    289          #endif
    290          #if((SENSOR_TYPE ==0X24)||(SENSOR_TYPE ==0X80))
    291          uint8 CSB_Len_H;
    292          uint8 CSB_Len_L;
    293          #endif
    294          #if(SENSOR_TYPE ==0X40)
    295          uint8 LED_START=0;
    296          #endif
    297          #if(SENSOR_TYPE =='G')
    298          #define A1 P1_0	//定义A线圈正端口
    299          #define A2 P1_1	//定义A线圈负端口
    300          #define B1 P1_2	//定义B线圈正端口
    301          #define B2 P1_3	//定义B线圈负端口
    302          #define Coil_A1   {A1=0;A2=1;B1=1;B2=1;}  //A线圈通正向电压
    303          #define Coil_B1   {A1=1;A2=1;B1=0;B2=1;}	//B线圈通正向电压
    304          #define Coil_A2   {A1=1;A2=0;B1=1;B2=1;}  //A线圈通反向电压
    305          #define Coil_B2   {A1=1;A2=1;B1=1;B2=0;}	//B线圈通反向电压
    306          #define Coil_OFF  {A1=1;A2=1;B1=1;B2=1;}  //全部断电 
    307          uint8 Coil_AB=0;
    308          #endif
    309          #if(SENSOR_TYPE ==0X67)
    310          #define  NSYNC P1_7 //dac7512 使能端
    311          #define  SCLK P1_6 //dac7512 时钟端
    312          #define  DIN P1_5  //dac7512 数据端
    313          #endif
    314          #if(SENSOR_TYPE ==0X30)
    315          #define  NSYNC P1_7 //dac7512 使能端
    316          #define  SCLK P1_6 //dac7512 时钟端
    317          #define  DIN P1_5  //dac7512 数据端
    318          
    319          #define B01 0x0D//(1 =14.8度)电机角度设定 0X07 42BYGH408AA(1=7.2)设定0X0D  默认 0x0D
    320          #define A1 P1_0	//定义A线圈正端口
    321          #define A2 P1_1	//定义A线圈负端口
    322          #define B1 P1_2	//定义B线圈正端口
    323          #define B2 P1_3	//定义B线圈负端口
    324          #define Coil_A1   {A1=0;A2=1;B1=1;B2=1;}  //A线圈通正向电压
    325          #define Coil_B1   {A1=1;A2=1;B1=0;B2=1;}	//B线圈通正向电压
    326          #define Coil_A2   {A1=1;A2=0;B1=1;B2=1;}  //A线圈通反向电压
    327          #define Coil_B2   {A1=1;A2=1;B1=1;B2=0;}	//B线圈通反向电压
    328          #define Coil_OFF  {A1=1;A2=1;B1=1;B2=1;}  //全部断电 
    329          uint8 a68=0,b68=0,c68=0; //a68方向 b68角度 c68 时间
    330          #endif
    331          #if(SENSOR_TYPE ==0X73)
    332          #define DIR P1_7
    333          #define CP P1_6
    334          uint8 a68=0;
    335          int b68=0;
    336          uint8 C68=0,A8n=0;
    337          #endif
    338          #if(SENSOR_TYPE =='D')
    339          #define S0 P1_6
    340          #define S1 P1_7
    341          #define OE	P1_5	
    342          #define L2      P1_1
    343          #define L3	P1_2
    344          #define OUT P1_0
    345          #define uchar unsigned char
    346          #define uint unsigned int
    347          volatile uint times = 0;	//脉冲计数
    348          float OUTR,OUTG,OUTB;
    349          #endif
    350          #if(SENSOR_TYPE =='F')
    351          #if defined(BMP085) 
    352          #define XCLR P1_5 
    353          #define XCLROUT P1DIR|=0x20       //数据输出 
    354          #define uchar unsigned char
    355          #define uint unsigned int
    356          //变量声明
    357          //BMP085中E2PROM存储的标定参数
    358          int AC1=0;   				//(0xAA,0xAB)
    359          int AC2=0;  				//(0xAC,0xAD)
    360          int AC3=0;  				//(0xAE,0xAF)
    361          unsigned int AC4=0;				//(0xB0,0xB1)
    362          unsigned int AC5=0;				//(0xB2,0xB3)
    363          unsigned int AC6=0;				//(0xB4,0xB5)
    364          int B1=0;				//(0xB6,0xB7)
    365          int B2=0;				//(0xB8,0xB9)
    366          int MB=0;				//(0xBA,0xBB)
    367          int MC=0;				//(0xBC,0xBD)
    368          int MD=0;				//(0xBE,0xBF)
    369          unsigned long T=0;				//温度
    370          unsigned long p=0;				//压力
    371          #endif
    372          
    373          #endif
    374             //标志 长度 目地地址  原地地址  类型 数值 数值 

   \                                 In  segment XDATA_I, align 1, keep-with-next
    375          uint8 Send_data[0X80] = {0XFA,0X0A,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00};
   \                     Send_data:
   \   000000                DS 128
   \   000080                REQUIRE `?<Initializer for Send_data>`
   \   000080                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    376          uint8 Send_datalend=0; //内容+校验和长度
   \                     Send_datalend:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    377          uint8 AF_OK=0;//无线数据发送成功与否标志  1成功 0失败
   \                     AF_OK:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    378          uint8 AF_RF=0;//无线数据发送失败，重发标志
   \                     AF_RF:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    379          uint8 AF_RFn=0;//重发次数
   \                     AF_RFn:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    380          uint8 AF_RFnd=0;//重发组数
   \                     AF_RFnd:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    381          uint8 AF_RFnds=0;//重发顺序号 按顺序发送
   \                     AF_RFnds:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    382          #if defined( SENSOR_TYPE_Coord )
    383          uint8  chnnd[5][120];//数据缓存
    384          #endif
    385          
    386          #if((SENSOR_TYPE ==0X31)||(SENSOR_TYPE ==0XA3))

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    387          uint8  chnndr[120];//数据缓存
   \                     chnndr:
   \   000000                DS 120
   \   000078                REQUIRE __INIT_XDATA_Z
    388          #endif
    389          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    390          unsigned int GenericApp_applicationdata=0;
   \                     GenericApp_applicationdata:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    391          unsigned char GenericApp_time=0;
   \                     GenericApp_time:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    392          unsigned int  GenericApp_applicationbuf=0;
   \                     GenericApp_applicationbuf:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    393          unsigned int GenericApp_uart_data=0;
   \                     GenericApp_uart_data:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    394          unsigned char  GenericApp_CR;
   \                     GenericApp_CR:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    395          uint8  openoff=0;
   \                     openoff:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    396          uint8  PWRMGR_ALWAYS_ON_OFF=0;
   \                     PWRMGR_ALWAYS_ON_OFF:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    397          unsigned char OSAL_SET_CPU_INTO_SLEEP=0;
   \                     OSAL_SET_CPU_INTO_SLEEP:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    398          unsigned int GenericApp_sbum=0;
   \                     GenericApp_sbum:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    399          unsigned int GenericApp_KSH_H=0;
   \                     GenericApp_KSH_H:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    400          unsigned int GenericApp_KSH=0;    //86盒 按键计数
   \                     GenericApp_KSH:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    401          unsigned int GenericApp_KSH86=0;  //86盒 按键速度计数
   \                     GenericApp_KSH86:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    402          //**********************************************************88

   \                                 In  segment XDATA_I, align 1, keep-with-next
    403          unsigned long T3_t1Val=100;//定时3 时间计数设置 ms
   \                     T3_t1Val:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for T3_t1Val>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    404          unsigned long t1Val=0;  //定时3 计数变量
   \                     t1Val:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    405          unsigned char T_MG=0;    // 控制设备 状态信息变量
   \                     T_MG:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    406          uint8 T_MGSbit=0;    // 状态信息 数据信息  连数据信息记录
   \                     T_MGSbit:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    407          //关闭定时  主动   控制类  综合型  

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    408          unsigned char  GenericApp_appIO=0;
   \                     GenericApp_appIO:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    409          unsigned char GenericApp_BX=0;
   \                     GenericApp_BX:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    410          unsigned int GenericApp_ON_OFF=0;
   \                     GenericApp_ON_OFF:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    411          unsigned int GenericApp_switch=0;//开关量定时反馈
   \                     GenericApp_switch:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    412          unsigned int GenericApp_switchk2=0;//开关量定时反馈
   \                     GenericApp_switchk2:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    413          #define LMOUT P2_0
    414          /*********************************************************************
    415           * CONSTANTS
    416           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    417          unsigned char T_MUMPT1=0;    // 记录数值进行比较
   \                     T_MUMPT1:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    418          unsigned int T_MUMPTS=0;    //   近似真实数据转换
   \                     T_MUMPTS:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    419          #if(SENSOR_TYPE ==0X22)
    420          unsigned char  T_MUMPTZ1=0;//记录最大数值 
    421          #endif 
    422          #if((SENSOR_TYPE ==0X18)||(SENSOR_TYPE ==0X5A)||(SENSOR_TYPE ==0X5B)||(SENSOR_TYPE ==0X70))
    423          unsigned char  GenericApp_uart_485=0;
    424          #endif 
    425          #if(SENSOR_TYPE ==0X23)
    426          unsigned char  SFG_R30X=0;
    427          unsigned char  SFG_R30XA[3]={0};
    428          #endif 
    429          #if(SENSOR_TYPE ==0X31)

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    430          uint8 Uart_Rev_Buff_1[6]={0};
   \                     Uart_Rev_Buff_1:
   \   000000                DS 6
   \   000006                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    431          uint8 Uart_Rev_Buff_2[6]={0};
   \                     Uart_Rev_Buff_2:
   \   000000                DS 6
   \   000006                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    432          uint8 car_stata;
   \                     car_stata:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    433          uint8 car_op;//读卡计数
   \                     car_op:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    434          uint8 car_sum;
   \                     car_sum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    435          uint8 holzer=0;
   \                     holzer:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    436          #endif
    437          /*********************************************************************
    438           * TYPEDEFS
    439           */
    440          /*********************************************************************
    441           * GLOBAL VARIABLES
    442           */
    443          // This list should be filled with Application specific Cluster IDs.

   \                                 In  segment XDATA_ROM_C, align 1
    444          const cId_t GenericApp_ClusterList[GENERICAPP_MAX_CLUSTERS] =
   \                     GenericApp_ClusterList:
   \   000000   0100         DW 1
    445          {
    446            GENERICAPP_CLUSTERID
    447          };

   \                                 In  segment XDATA_ROM_C, align 1
    448          const SimpleDescriptionFormat_t GenericApp_SimpleDesc =
   \                     GenericApp_SimpleDesc:
   \   000000   0A           DB 10
   \   000001   040F0100     DW 3844, 1
   \   000005   0001         DB 0, 1
   \   000007   ....         DW GenericApp_ClusterList
   \   000009   01           DB 1
   \   00000A   ....         DW GenericApp_ClusterList
    449          {
    450            GENERICAPP_ENDPOINT,              //  int Endpoint;
    451            GENERICAPP_PROFID,                //  uint16 AppProfId[2];
    452            GENERICAPP_DEVICEID,              //  uint16 AppDeviceId[2];
    453            GENERICAPP_DEVICE_VERSION,        //  int   AppDevVer:4;
    454            GENERICAPP_FLAGS,                 //  int   AppFlags:4;
    455            GENERICAPP_MAX_CLUSTERS,          //  byte  AppNumInClusters;
    456            (cId_t *)GenericApp_ClusterList,  //  byte *pAppInClusterList;
    457            GENERICAPP_MAX_CLUSTERS,          //  byte  AppNumInClusters;
    458            (cId_t *)GenericApp_ClusterList   //  byte *pAppInClusterList;
    459          };
    460          
    461          // This is the Endpoint/Interface description.  It is defined here, but
    462          // filled-in in GenericApp_Init().  Another way to go would be to fill
    463          // in the structure here and make it a "const" (in code space).  The
    464          // way it's defined in this sample app it is define in RAM.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    465          endPointDesc_t GenericApp_epDesc;
   \                     GenericApp_epDesc:
   \   000000                DS 6
   \   000006                REQUIRE __INIT_XDATA_Z
    466          /*********************************************************************
    467           * EXTERNAL VARIABLES
    468           */
    469          
    470          /*********************************************************************
    471           * EXTERNAL FUNCTIONS
    472           */
    473          
    474          /*********************************************************************
    475           * LOCAL VARIABLES
    476           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    477          byte GenericApp_TaskID;   // Task ID for internal task/event processing
   \                     GenericApp_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    478                                    // This variable will be received when
    479                                    // GenericApp_Init() is called.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    480          devStates_t GenericApp_NwkState;
   \                     GenericApp_NwkState:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    481          byte GenericApp_TransID;  // This is the unique message ID (counter)
   \                     GenericApp_TransID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    482          afAddrType_t GenericApp_DstAddr;
   \                     GenericApp_DstAddr:
   \   000000                DS 12
   \   00000C                REQUIRE __INIT_XDATA_Z
    483          /*********************************************************************
    484           * LOCAL FUNCTIONS
    485           */
    486          //void GenericApp_ProcessZDOMsgs( zdoIncomingMsg_t *inMsg );
    487          void GenericApp_HandleKeys( byte shift, byte keys );
    488          void GenericApp_MessageMSGCB( afIncomingMSGPacket_t *pckt );
    489          void GenericApp_SendTheMessage( void );
    490          void GenericApp_SendFT( void );
    491          void GenericAppEndDeviceEB(void);
    492          
    493          /*********************************************************************
    494           * NETWORK LAYER CALLBACKS
    495           */
    496          
    497          /*********************************************************************
    498           * PUBLIC FUNCTIONS
    499           */
    500          #if(SENSOR_TYPE =='B')
    501          void MMA7660_XYZ_Read_and_Filter(void);
    502          void MMA7660_XYZ_Read_and_Filter(void)
    503          {
    504            int i;
    505            int temp16;
    506            IIC_Read_MMA7660_XYZ6(&Xnew8, &Ynew8, &Znew8);
    507            if((++RawDataPointer)>=RawDataLength) RawDataPointer = 0;
    508            Xraw[RawDataPointer] = Xnew8;
    509            Yraw[RawDataPointer] = Ynew8;
    510            Zraw[RawDataPointer] = Znew8;
    511            for(i=0, temp16=0;i<RawDataLength;i++)
    512            {
    513              temp16 += (int)Xraw[i];
    514            }
    515            Xavg8 = (int)(temp16/RawDataLength);
    516            for(i=0, temp16=0;i<RawDataLength;i++)
    517            {
    518              temp16 += (int)Yraw[i];
    519            }
    520            Yavg8 = (int)(temp16/RawDataLength);
    521            for(i=0, temp16=0;i<RawDataLength;i++)
    522            {
    523              temp16 += (int)Zraw[i];
    524            }
    525            Zavg8 = (int)(temp16/RawDataLength);
    526          }
    527          #endif  
    528          #if((SENSOR_TYPE ==0X6C)||(SENSOR_TYPE ==0X6F))
    529          void wr_lcd(unsigned char dat_com,unsigned char content);
    530          void delay_us(unsigned int us_value);
    531          void delay_ms(unsigned int ms_value);
    532          void init_lcd (void);
    533          void txt_disp(const unsigned char code *cn,unsigned char adr,unsigned char len);
    534          void lcd_disp(unsigned char *cn,unsigned char adr,unsigned char len);
    535          void hzkdis(unsigned char adr,const unsigned char code *s);
    536          void hzkdis_b(unsigned char adr,unsigned char *s,unsigned char len);
    537          void lcd_txt_clr(void);
    538          void lcd_gra_clr(void);
    539          void sendbyte(unsigned char zdata);
    540          /******************************************************************************************
    541          *函数名称： init_lcd
    542          *功能描述： 初始化
    543          ******************************************************************************************/
    544          void init_lcd (void)
    545          {
    546           wr_lcd(com,0x30);  /*30---功能设定,8-bit模式*/   
    547           wr_lcd(com,0x30);  /*30---功能设定,基本指令*/  
    548           wr_lcd(com,0x01);  /*清屏，地址指针指向00H*/
    549           wr_lcd(com,0x06);  /*光标的移动方向*/
    550           wr_lcd(com,0x0c);  /*开显示，关游标*/
    551          }
    552          
    553          /********************************************************************
    554          * 名称 : hzkdis()
    555          * 功能 : 显示字符串
    556          * 输入 : *s
    557          * 输出 : 无
    558          ***********************************************************************/
    559          void hzkdis(unsigned char adr,const unsigned char code *s)
    560          {
    561           wr_lcd(com,0x30);
    562          //delay_ms(50); 
    563          //wr_lcd(com,0x80);
    564           int i=0;char x[4]={0};
    565          switch(adr)
    566          {
    567          case 0:x[0]=0x80;x[1]=0x90;x[2]=0x88;x[3]=0x98;break; 
    568          case 1:x[0]=0x90;x[1]=0x88;x[2]=0x98;break; 
    569          case 2:x[0]=0x88;x[1]=0x98;break; 
    570          case 3:x[0]=0x98;break; 
    571          default:break;
    572          }
    573          while(*s > 0)
    574          { switch(i)
    575          {case 0:wr_lcd(com,x[0]);break; 
    576          case 16:wr_lcd(com,x[1]);break;
    577          case 32:wr_lcd(com,x[2]);break;
    578          case 48:wr_lcd(com,x[3]);break;
    579          default:break;
    580          }
    581          wr_lcd(dat,*s);
    582          s++;
    583          i++;
    584          delay_ms(50);
    585          }
    586          }
    587          /********************************************************************
    588          * 名称 : hzkdis-b()
    589          * 功能 : 显示字符串
    590          * 输入 : *s
    591          * 输出 : 无
    592          ***********************************************************************/
    593          void hzkdis_b(unsigned char adr,unsigned char *s,unsigned char len)
    594          {
    595           wr_lcd(com,0x30);
    596          //delay_ms(50); 
    597          //wr_lcd(com,0x80);
    598           int i=0;char x[4]={0};
    599          switch(adr)
    600          {
    601          case 0:x[0]=0x80;x[1]=0x90;x[2]=0x88;x[3]=0x98;break; 
    602          case 1:x[0]=0x90;x[1]=0x88;x[2]=0x98;break; 
    603          case 2:x[0]=0x88;x[1]=0x98;break; 
    604          case 3:x[0]=0x98;break; 
    605          default:break;
    606          }
    607          while(i < len)
    608          { switch(i)
    609          {case 0:wr_lcd(com,x[0]);break; 
    610          case 16:wr_lcd(com,x[1]);break;
    611          case 32:wr_lcd(com,x[2]);break;
    612          case 48:wr_lcd(com,x[3]);break;
    613          default:break;
    614          }
    615          wr_lcd(dat,*s);
    616          s++;
    617          i++;
    618          delay_ms(50);
    619          }
    620          }
    621          /******************************************************************************************
    622          *函数名称： lcd_disp
    623          *功能描述： 显示一行汉字或字符
    624          ******************************************************************************************/
    625          void lcd_disp(unsigned char *cn,unsigned char adr,unsigned char len)
    626          {
    627           unsigned char i;
    628           wr_lcd(com,0x30);
    629           wr_lcd(com,adr);   //第一到四行地址分别是0x80,0x90,0x88,0x98
    630           for(i=0;i<len;i++)
    631            wr_lcd(dat,cn[i]);
    632          }
    633          /******************************************************************************************
    634          *函数名称： txt_disp
    635          *功能描述： 显示一行汉字或字符
    636          ******************************************************************************************/
    637          void txt_disp(const unsigned char code *cn,unsigned char adr,unsigned char len)
    638          {
    639           unsigned char i;
    640           wr_lcd(com,0x30);
    641           wr_lcd(com,adr);   //第一到四行地址分别是0x80,0x90,0x88,0x98
    642           for(i=0;i<len;i++)
    643            wr_lcd(dat,cn[i]);
    644          }
    645          /********************************************************************
    646          * 名称 : sendbyte()
    647          * 功能 : 按照液晶的串口通信协议，发送数据
    648          * 输入 : zdata
    649          * 输出 : 无
    650          ***********************************************************************/
    651          void sendbyte(unsigned char zdata)
    652          {
    653          unsigned int i;
    654          for(i=0; i<8; i++)
    655          {
    656          if((zdata << i) & 0x80)
    657          {
    658          SDA = 1;
    659          }
    660          else 
    661          {
    662          SDA = 0;
    663          }
    664          SCLK = 0;
    665          SCLK = 1;
    666          }
    667          }
    668          /******************************************************************************************
    669          *函数名称：wr_lcd
    670          *功能描述：写入指令/数据子程序 
    671          ******************************************************************************************/
    672          void wr_lcd (unsigned char dat_comm,unsigned char content)
    673          {CS = 1;
    674          if(dat_comm)
    675          sendbyte(0xfa);
    676          else sendbyte(0xf8);
    677          sendbyte(content & 0xf0);
    678          sendbyte((content << 4) & 0xf0);
    679          delay_us(2);
    680          }
    681          
    682          /******************************************************************************************
    683          *函数名称：delay_us
    684          *功能描述：延时us 
    685          ******************************************************************************************/
    686          void delay_us(unsigned int t)   //delay time
    687          {
    688           unsigned int i,j;
    689          for(i=0; i<t; i++)
    690          for(j=0; j<10; j++);
    691          }
    692          /******************************************************************************************
    693          *函数名称：delay_ms
    694          *功能描述：延时ms
    695          ******************************************************************************************/
    696          void delay_ms(unsigned int ms_value)
    697          {
    698           unsigned int i,j;
    699           for(i=0;i<ms_value;i++)
    700            for(j=0;j<20;j++)
    701             delay_us(1);
    702          }
    703          
    704          /******************************************************************************************
    705          *函数名称： lcd_txt_clr
    706          *功能描述： 文本区清RAM函数
    707          ******************************************************************************************/
    708          void lcd_txt_clr(void)
    709          {
    710           wr_lcd(com,0x30);
    711           wr_lcd(com,0x01);
    712           delay_ms(20);
    713          }
    714          /******************************************************************************************
    715          *函数名称： lcd_gra_clr
    716          *功能描述： 图形区清RAM函数
    717          ******************************************************************************************/
    718          void lcd_gra_clr(void)
    719          {
    720           unsigned char i,j;
    721           wr_lcd(com,0x34);      //8Bit扩充指令集,即使是36H也要写两次
    722           for(j=0;j<32;j++)
    723            {
    724             for(i=0;i<16;i++)
    725              {
    726               wr_lcd(com,0x34);
    727               wr_lcd(com,0x80+j);
    728               wr_lcd(com,0x80+i);
    729               wr_lcd(com,0x30);
    730               wr_lcd(dat,0);
    731               wr_lcd(dat,0);
    732              }
    733            }
    734          }
    735          #endif 
    736          #if(SENSOR_TYPE ==0X78)
    737          void send_Instruction(void);
    738          void send_Instruction(void)
    739          {halMcuWaitMs(1000);
    740          	unsigned  char send_data[3]={0};
    741          	send_data[0]=0xa5;
    742          	send_data[1]=0x15;//加计功能字节
    743          	send_data[2]=(unsigned char)(send_data[0]+send_data[1]);//指令校验和
    744                   HalUARTWrite(HAL_UART_PORT_0, send_data,3);//发送加速度输出指令
    745          	halMcuWaitMs(10);
    746          	send_data[0]=0xa5;
    747          	send_data[1]=0x25;
    748          	send_data[2]=(unsigned char)(send_data[0]+send_data[1]);
    749          	 HalUARTWrite(HAL_UART_PORT_0,send_data,3);//发送陀螺仪数据输出指令
    750          	halMcuWaitMs(10);
    751          	send_data[0]=0xa5;
    752          	send_data[1]=0x35;
    753          	send_data[2]=(unsigned char)(send_data[0]+send_data[1]);
    754          	 HalUARTWrite(HAL_UART_PORT_0,send_data,3);//发送磁场数据输出指令
    755          	halMcuWaitMs(10);
    756          	send_data[0]=0xa5;
    757          	send_data[1]=0x45;
    758          	send_data[2]=(unsigned char)(send_data[0]+send_data[1]);
    759          	 HalUARTWrite(HAL_UART_PORT_0,send_data,3);//发送欧拉角数据输出指令
    760          	halMcuWaitMs(10);
    761          	send_data[0]=0xa5;
    762          	send_data[1]=0x65;
    763          	send_data[2]=(unsigned char)(send_data[0]+send_data[1]);
    764          	 HalUARTWrite(HAL_UART_PORT_0,send_data,3);//发送四元数数据输出指令
    765          }
    766          
    767          #endif 
    768          #if(SENSOR_TYPE ==0X81)
    769          unsigned int read_max6675(void);
    770          unsigned int read_max6675(void)    
    771            { max_byte=0;   
    772                 unsigned char i=0;    
    773                CS=0;   
    774                SCK=0;        
    775                  for(i=0;i<16;i++)    
    776                   {    
    777                    halMcuWaitMs(1);	  
    778                    SCK=1;     
    779                    halMcuWaitMs(1);	   
    780                    if(SO)     
    781                     max_byte|=(1<<(15-i));   
    782                    SCK=0;    
    783                   }   
    784                  CS=1;   
    785                  SCK=0;    
    786                  bytee=max_byte;   
    787                  if(bytee&0x8000)max_byte=0x8000;   //错误  D15 模拟位   0正常 1 模拟位
    788                  else if(bytee&0x4)max_byte=0x8001;   //错误 D2 电偶开路位检测 0 连接 1 开路
    789                  else   
    790                   {   
    791                     max_byte=max_byte&0x7ff8;   
    792                     max_byte=max_byte>>3;   
    793                    }   
    794                 return max_byte;    
    795          
    796          
    797          
    798            }    
    799          #endif  
    800          #if(SENSOR_TYPE =='F')
    801          #if defined(BMP085) 
    802          void BMP085_init(void);
    803          void BMP085_sample(uchar oss);
    804          //====================================================
    805          //压力传感器驱动函数 （BMP085）
    806          //====================================================
    807          void BMP085_init(void)//读取BMP085中E2PROM的参数，并赋给全局变量
    808          {		
    809          	char memo[22];
    810          	uchar i;
    811          	//void *pf;
    812          	//从EEPROM中读取预设参数
    813          	for(i=0;i<22;i++){memo[i]=Single_Read_(0xAA+i);}
    814                  AC1=(memo[0]<<8)+memo[1];
    815          	AC2=(memo[2]<<8)+memo[3];	
    816                  AC3=(memo[4]<<8)+memo[5];	
    817                  AC4=(memo[6]<<8)+memo[7];	
    818                  AC5=(memo[8]<<8)+memo[9];	
    819                  AC6=(memo[10]<<8)+memo[11];	
    820                  B1=(memo[12]<<8)+memo[13];	
    821                  B2=(memo[14]<<8)+memo[15];	
    822                  MB=(memo[16]<<8)+memo[17];	
    823                  MC=(memo[18]<<8)+memo[19];	
    824                  MD=(memo[20]<<8)+memo[21];	
    825                  //AC1=408;
    826                 /*  AC2=-72;
    827                   AC3=-14383;
    828                  AC4=32741;
    829                  AC5=32757;
    830                  AC6=23153;
    831                  B1=6190;
    832                  B2=4;
    833                  MB=-32768;
    834                  MC=-8711;
    835                  MD=2868; 
    836                  */
    837          }
    838          void BMP085_sample(uchar oss)//温度、压力采样
    839          //oss为工作方式：
    840          //0-ultra low power;
    841          //1-standard;
    842          //2-high resolution;
    843          //3-ultra high resolution
    844          {
    845          	 long UT=0;			//温度原始值	
    846          	 long UP=0;			//压力原始值
    847          	 long X1,X2,X3;
    848          	long B3,B5,B6;
    849          	unsigned long B4,B7;
    850          	char i,BMPmemo[3];
    851          	//void *pf;
    852          	Single_Write_(0xF4,0x2E);	//发命令采温度
    853          	mDelay(100); //延时						//等待AD，延迟4.5ms以上
    854          	for(i=0;i<2;i++){BMPmemo[i]=Single_Read_(0xF6+i);}//读取结果	
    855                  UT=BMPmemo[0]*256+BMPmemo[1];
    856                 // UT=UT-5000;  //误差补偿（根据实际测试）
    857          	Single_Write_(0xF4,0x34+(oss<<6));//发命令采压力
    858          	mDelay(200); //延时								//延迟时间视工作方式而定，具体查手册
    859          	for(i=0;i<3;i++){BMPmemo[i]=Single_Read_(0xF6+i);}//读取结果	
    860                  
    861                  UP=BMPmemo[0]*65536+BMPmemo[1]*256+BMPmemo[2];
    862          	UP=(UP>>(8-oss));
    863                  
    864                  X1=(UT-AC6)*AC5/32768; 		//计算温度
    865          	X2=MC;
    866          	X2=X2*2048/(X1+MD);
    867          	B5=X1+X2;
    868          	T=(B5+8)/16;
    869          	B6=B5-4000;			//计算压力
    870          	X1=B2;
    871          	X1=(X1*(B6*B6/4096))/2048;
    872          	X2=AC2;
    873          	X2=X2*B6/2048;
    874          	X3=X1+X2;
    875          	B3=AC1;
    876          	B3=(((B3*4+X3)<<oss)+2)/4;	
    877          	X1=AC3;
    878          	X1=X1*B6/8192;
    879          	X2=B1;
    880          	X2=(X2*(B6*B6/4096))/65536;
    881          	X3=((X1+X2)+2)/4;
    882          	B4=AC4;
    883          	B4=B4*(unsigned long)(X3+32768)/32768;
    884          	B7=((unsigned long)UP-B3)*(50000>>oss);	
    885          	if(B7<0x80000000){p=(B7*2)/B4;}
    886          	else {p=(B7/B4)*2;}
    887          	X1=(p/256)*(p/256); 
    888          	X1=(X1*3038)/65536;        
    889          	X2=(-7357*p)/65536; 
    890          	p=p+(X1+X2+3791)/16;  
    891          }
    892          #endif 
    893          #endif  
    894          
    895          #if(SENSOR_TYPE =='D')
    896          float TCS3200(uchar t);
    897          //===================TCS3200测颜色=========================
    898          float TCS3200(uchar t)
    899          {       float OUTS;
    900                  uint8 n=1;
    901                  switch(t)
    902                 { case 1:L2=0;L3=0;break;//R
    903                   case 2:L2=1;L3=1;break;//G
    904                   case 3:L2=0;L3=1;break;//B
    905                   default:L2=1;L3=0;break;//无
    906                  }
    907          	for(unsigned int i=0;i<100;i++);
    908          	times = 0;
    909          	OE=0;//检测一次
    910          	for(unsigned int i=0;i<50000;i++)
    911                    {if(n)
    912                      {if(OUT){times++;n=0;}}
    913                       if(!n){if(!OUT)n=1;}
    914                      }
    915          	OE=1;
    916          	OUTS= times;
    917          	times = 0;
    918          	OE=0;			//两次
    919          	for(unsigned int i=0;i<50000;i++)
    920                    {if(n)
    921                      {if(OUT){times++;n=0;}}
    922                       if(!n){if(!OUT)n=1;}
    923                      }
    924          	OE=1;	
    925          	OUTS += times;
    926          	times = 0;
    927          	OE=0;			//三次
    928          	for(unsigned int i=0;i<50000;i++)
    929                    {if(n)
    930                      {if(OUT){times++;n=0;}}
    931                       if(!n){if(!OUT)n=1;}
    932                      }
    933          	OE=1;	
    934          	OUTS += times;
    935          	times = 0;
    936          	OE=0;				//四次
    937          	for(unsigned int i=0;i<50000;i++)
    938                    {if(n)
    939                      {if(OUT){times++;n=0;}}
    940                       if(!n){if(!OUT)n=1;}
    941                      }
    942          	OE=1;	
    943          	OUTS += times;
    944          	OUTS/=4.0;					//取四次的平均值
    945          	return OUTS;
    946          }
    947          #endif    
    948          #if((SENSOR_TYPE ==0X27)||(SENSOR_TYPE ==0X6F))
    949          void SYN_FrameInfo(uint8 Music,uint8 GBK,uint8 *HZdata,uint8 lens);
    950          /***********************************************************
    951          * 名    称：  YS-SYN6288 文本合成函数
    952          * 功    能：  发送合成文本到SYN6288芯片进行合成播放
    953          * 入口参数：Music(背景音乐选择):0无背景音乐。1-15：相关背景音乐
    954                      GBK : 汉字编码格式  0: GB2312  1: GBK  2:BIG5  3 :UNICODE
    955                      *HZdata:文本指针变量 
    956          * 出口参数：
    957          * 说    明： 本函数只用于文本合成，具备背景音乐选择。默认波特率9600bps。					 
    958          **********************************************************/
    959          void SYN_FrameInfo(uint8 Music,uint8 GBK,uint8 *HZdata,uint8 lens)
    960          {
    961          /****************需要发送的文本**********************************/ 
    962          		 unsigned  char  Frame_Info[85];
    963                   unsigned  char  HZ_Length;  
    964          		 unsigned  char  ecc  = 0;  			//定义校验字节
    965          	     unsigned  int i=0; 
    966          		 HZ_Length =strlen(HZdata); 			//需要发送文本的长度
    967                           if(HZ_Length>lens)
    968                             HZ_Length =lens; 
    969           
    970          /*****************帧固定配置信息**************************************/           
    971          		 Frame_Info[0] = 0xFD ; 			//构造帧头FD
    972          		 Frame_Info[1] = 0x00 ; 			//构造数据区长度的高字节
    973          		 Frame_Info[2] = HZ_Length + 3; 		//构造数据区长度的低字节
    974          		 Frame_Info[3] = 0x01 ; 			//构造命令字：合成播放命令		 		 
    975          		 Frame_Info[4] =( 0x00 | Music<<4 )|GBK;  //构造命令参数：背景音乐设定
    976          
    977          /*******************校验码计算***************************************/		 
    978          		 for(i = 0; i<5; i++)   				//依次发送构造好的5个帧头字节
    979          	     {  
    980          	         ecc=ecc^(Frame_Info[i]);		//对发送的字节进行异或校验	
    981          	     }
    982          
    983          	   	 for(i= 0; i<HZ_Length; i++)   		//依次发送待合成的文本数据
    984          	     {  
    985          	         ecc=ecc^(HZdata[i]); 				//对发送的字节进行异或校验		
    986          	     }		 
    987          /*******************发送帧信息***************************************/		  
    988          		  memcpy(&Frame_Info[5], HZdata, HZ_Length);
    989          		  Frame_Info[5+HZ_Length]=ecc;
    990          		//  PrintCom(Frame_Info,5+HZ_Length+1);
    991                            HalUARTWrite(HAL_UART_PORT_0,Frame_Info,5+HZ_Length+1);//智能语言播报
    992          }
    993          #endif    
    994          #if(SENSOR_TYPE ==0X66)
    995          void display(void);
    996          void display()			   //显示子程序
    997          {     
    998          	unsigned int LedOut[2];
    999                  LedOut[0]=Disp_Tab[LedNumVal%100/10];
   1000          	LedOut[1]=Disp_Tab[LedNumVal%100%10];
   1001                    SendData(LedOut[LED_HL]);
   1002          	  switch(LED_HL)					  
   1003          	     {	case 0:DS1=1;DS2=0;break; 
   1004          		case 1:DS2=1;DS1=0;break;
   1005          	    }
   1006          }
   1007          #endif 
   1008          #if((SENSOR_TYPE ==0X30)||(SENSOR_TYPE ==0X67))
   1009          void DAchange(unsigned int dat);
   1010          //da驱动程序，入口参数dat,必须小于4096！4096对应5v电压！
   1011          void DAchange(unsigned int dat)
   1012          {
   1013          unsigned char DA,i,j,DAL,DAH;
   1014           NSYNC=1;
   1015          if(dat>4095)dat=0;
   1016          else
   1017          {DAL=dat%256;
   1018            DAH=dat/256;
   1019              NSYNC=0;
   1020              i=0;
   1021                  while(i<2)
   1022                  {if(i<1)DA=DAH;else DA=DAL;
   1023                  for(j=8;j>0;j--)
   1024                  {
   1025                      if(DA&0x80)DIN=1;else DIN=0;
   1026                      DA=(DA<<1);SCLK=1;SCLK=0;
   1027                   }
   1028                  i=i+1;
   1029                  }
   1030              NSYNC=1;
   1031              }
   1032          }
   1033          #endif
   1034          #if(SENSOR_TYPE ==0X13) 
   1035          #if defined(HUABANG) 
   1036          float ieee754(void);
   1037          float ieee754(void)
   1038          {
   1039            typedef union                                        
   1040          {
   1041             float Float_buf;
   1042             unsigned char  unchar_Buf[4];
   1043          }un_DtformConver;
   1044          
   1045          un_DtformConver   DtformConver;
   1046          
   1047          unsigned char i;
   1048          long long_buf;
   1049          long long_bufS;
   1050          float Float_buf;
   1051          	
   1052          long_buf=0;
   1053          long_bufS=Send_data[8];
   1054          long_buf=long_bufS<<24;
   1055          long_bufS=Send_data[9];
   1056          long_buf+=long_bufS<<16;
   1057          long_bufS=Send_data[10];
   1058          long_buf+=long_bufS<<8;
   1059          long_buf+=Send_data[11];
   1060           //long_bufS=long_buf(((long)Send_data[8]<<24)+((long)Send_data[9]<<16)+((long)Send_data[10]<<8)+Send_data[11]);
   1061           
   1062           memset((unsigned char *)&DtformConver.unchar_Buf[0],0,4);
   1063          
   1064            for(i=0;i<4;i++)
   1065           {
   1066              DtformConver.unchar_Buf[i] = (unsigned char )(long_buf>>(i*8));
   1067           }
   1068           Float_buf = DtformConver.Float_buf;
   1069           
   1070            return Float_buf;
   1071          }
   1072          #endif
   1073          #endif
   1074          #if(SENSOR_TYPE =='S')
   1075          void DimmingAppControl(unsigned char cmd,unsigned char ch);
   1076          void DimmingAppControl(unsigned char cmd,unsigned char ch)
   1077          {
   1078          	unsigned char i,dl,dh;			
   1079          	unsigned int datas=0;
   1080          	if(cmd<0X76)
   1081          	{if(cmd==0)
   1082                    dh=cmd;
   1083                   else
   1084                    dh = 0X76-cmd;
   1085          	if(ch == 1)
   1086          	dh |= 0x80;	
   1087          	dl = ~dh;
   1088          	datas  = dl;
   1089                 //datas=0xaa;
   1090          	datas |= dh<<8;					//最终要发送的数据为16位
   1091          							//高8位命令 低8位取反效验
   1092          	P1_2 = 0;					//拉低片选
   1093          	halMcuWaitUs(50);
   1094          	for(i=0;i<16;i++)
   1095          	{
   1096          		P1_1 = 0;
   1097          		halMcuWaitUs(10);					//这里大约是100us
   1098          		if(datas & 0x8000)	P1_0 = 1;
   1099          		else 			P1_0 = 0;
   1100          		halMcuWaitUs(90);
   1101          		P1_1 = 1;			
   1102          		halMcuWaitUs(100);					//这里大约是100us
   1103          		datas <<= 1;
   1104          	}
   1105          	P1_0 = 1;
   1106          	P1_2 = 1;
   1107          	P1_1 = 1;
   1108                  }
   1109          }
   1110          #endif 
   1111          
   1112          
   1113          //定时3启动或关闭
   1114          #define BOOL int
   1115          void halSetTimer3Period(uint16 period);
   1116          __interrupt void T3_IRQ(void);
   1117          
   1118          //设置定时器1的定时周期
   1119          /*********************************************************************
   1120           * 函数名称：halSetTimer3Period
   1121           * 功    能：设置定时器3定时周期
   1122           * 入口参数：period   定时周期
   1123           * 出口参数：无
   1124           * 返 回 值：无
   1125           ********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1126          void halSetTimer3Period(uint16 period)
   \                     halSetTimer3Period:
   1127          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1128            /* 给T3CC0写入最终计数值period */
   1129            T3CC0 = period & 0xFF;             // 把period值写入T3CC0
   \   000000   EA           MOV     A,R2
   \   000001   F5CD         MOV     0xcd,A
   1130          }
   \   000003   02....       LJMP    ?BRET
   \   000006                REQUIRE T3CC0
   1131          /*********************************************************************
   1132           * 函数名称：T3_IRQ
   1133           * 功    能：定时器3中断服务函数
   1134           * 入口参数：无
   1135           * 出口参数：无
   1136           * 返 回 值：无
   1137           ********************************************************************/
   1138          #pragma vector=T3_VECTOR

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   1139          __interrupt void T3_IRQ(void)
   \                     T3_IRQ:
   1140          {
   \   000000   C0E0         PUSH    A
   \   000002   74EB         MOV     A,#-0x15
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 22
   \   000007                ; Auto size: 0
   1141          
   1142              EA=FALSE;
   \   000007   C2AF         CLR     0xa8.7
   1143             if(TIMIF & 0x01)
   \   000009   A2D8         MOV     C,0xd8.0
   \   00000B   5057         JNC     ??T3_IRQ_0
   1144              { t1Val++;
   \   00000D   90....       MOV     DPTR,#__Constant_1
   \   000010   78..         MOV     R0,#?V0 + 0
   \   000012   12....       LCALL   ?L_MOV_X
   \   000015   90....       MOV     DPTR,#t1Val
   \   000018   78..         MOV     R0,#?V0 + 0
   \   00001A   12....       LCALL   ?L_ADD_TO_X
   1145              //if(t1Val>=12500)  //100ms
   1146              if(t1Val>=(125*T3_t1Val))  //T3_t1Val ms    
   \   00001D   90....       MOV     DPTR,#t1Val
   \   000020   C082         PUSH    DPL
   \   000022   90....       MOV     DPTR,#T3_t1Val
   \   000025   78..         MOV     R0,#?V0 + 0
   \   000027   12....       LCALL   ?L_MOV_X
   \   00002A   90....       MOV     DPTR,#__Constant_7d
   \   00002D   78..         MOV     R0,#?V0 + 4
   \   00002F   12....       LCALL   ?L_MOV_X
   \   000032   78..         MOV     R0,#?V0 + 0
   \   000034   79..         MOV     R1,#?V0 + 4
   \   000036   12....       LCALL   ?L_MUL
   \   000039   7583..       MOV     DPH,#((t1Val >> 8) & 0xff)
   \   00003C   D082         POP     DPL
   \   00003E   78..         MOV     R0,#?V0 + 0
   \   000040   12....       LCALL   ?UL_GT_X
   \   000043   401F         JC      ??T3_IRQ_0
   1147              { t1Val=0;
   \   000045   90....       MOV     DPTR,#__Constant_0
   \   000048   78..         MOV     R0,#?V0 + 0
   \   00004A   12....       LCALL   ?L_MOV_X
   \   00004D   90....       MOV     DPTR,#t1Val
   \   000050   78..         MOV     R0,#?V0 + 0
   \   000052   12....       LCALL   ?L_MOV_TO_X
   1148                GenericApp_applicationbuf=60001;
   \   000055   90....       MOV     DPTR,#GenericApp_applicationbuf
   \   000058   7461         MOV     A,#0x61
   \   00005A   F0           MOVX    @DPTR,A
   \   00005B   A3           INC     DPTR
   \   00005C   74EA         MOV     A,#-0x16
   \   00005E   F0           MOVX    @DPTR,A
   1149                GenericApp_time=0;
   \   00005F   E4           CLR     A
   \   000060   90....       MOV     DPTR,#GenericApp_time
   \   000063   F0           MOVX    @DPTR,A
   1150              }
   1151              }
   1152               EA=TRUE;
   \                     ??T3_IRQ_0:
   \   000064   D2AF         SETB    0xa8.7
   1153           TIMIF &= ~0x01;
   \   000066   C2D8         CLR     0xd8.0
   1154           }
   \   000068   7F08         MOV     R7,#0x8
   \   00006A   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   00006D                REQUIRE _A_IEN0
   \   00006D                REQUIRE _A_TIMIF
   1155          /*********************************************************************
   1156           * @fn      GenericApp_Init
   1157           *
   1158           * @brief   Initialization function for the Generic App Task.
   1159           *          This is called during initialization and should contain
   1160           *          any application specific initialization (ie. hardware
   1161           *          initialization/setup, table initialization, power up
   1162           *          notificaiton ... ).
   1163           *
   1164           * @param   task_id - the ID assigned by OSAL.  This ID should be
   1165           *                    used to send messages and set timers.
   1166           *
   1167           * @return  none
   1168           */
   1169          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1170          void GenericApp_Init( byte task_id )
   \                     GenericApp_Init:
   1171          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   1172            GenericApp_TaskID = task_id;
   \   000006   90....       MOV     DPTR,#GenericApp_TaskID
   \   000009   F0           MOVX    @DPTR,A
   1173            GenericApp_NwkState = DEV_INIT;
   \   00000A   7401         MOV     A,#0x1
   \   00000C   90....       MOV     DPTR,#GenericApp_NwkState
   \   00000F   F0           MOVX    @DPTR,A
   1174            GenericApp_TransID = 0;
   \   000010   E4           CLR     A
   \   000011   90....       MOV     DPTR,#GenericApp_TransID
   \   000014   F0           MOVX    @DPTR,A
   1175            openoff=0xaa;
   \   000015   74AA         MOV     A,#-0x56
   \   000017   90....       MOV     DPTR,#openoff
   \   00001A   F0           MOVX    @DPTR,A
   1176            // Device hardware initialization can be added here or in main() (Zmain.c).
   1177            // If the hardware is application specific - add it here.
   1178            // If the hardware is other parts of the device add it in main().
   1179            GenericApp_DstAddr.addrMode = (afAddrMode_t)Addr16Bit;;
   \   00001B   7402         MOV     A,#0x2
   \   00001D   90....       MOV     DPTR,#(GenericApp_DstAddr + 8)
   \   000020   F0           MOVX    @DPTR,A
   1180            GenericApp_DstAddr.endPoint = GENERICAPP_ENDPOINT;;
   \   000021   740A         MOV     A,#0xa
   \   000023   90....       MOV     DPTR,#(GenericApp_DstAddr + 9)
   \   000026   F0           MOVX    @DPTR,A
   1181            GenericApp_DstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVALL;
   \   000027   90....       MOV     DPTR,#GenericApp_DstAddr
   \   00002A   74FF         MOV     A,#-0x1
   \   00002C   F0           MOVX    @DPTR,A
   \   00002D   A3           INC     DPTR
   \   00002E   F0           MOVX    @DPTR,A
   1182          #if defined( POWER_SAVING )
   1183            GenericApp_DstAddr.addr.shortAddr =NWK_BROADCAST_SHORTADDR_AABB;
   1184          #endif
   1185            // Fill out the endpoint description.
   1186            GenericApp_epDesc.endPoint = GENERICAPP_ENDPOINT;
   \   00002F   740A         MOV     A,#0xa
   \   000031   90....       MOV     DPTR,#GenericApp_epDesc
   \   000034   F0           MOVX    @DPTR,A
   1187            GenericApp_epDesc.task_id = &GenericApp_TaskID;
   \   000035   90....       MOV     DPTR,#(GenericApp_epDesc + 1)
   \   000038   74..         MOV     A,#(GenericApp_TaskID & 0xff)
   \   00003A   F0           MOVX    @DPTR,A
   \   00003B   A3           INC     DPTR
   \   00003C   74..         MOV     A,#((GenericApp_TaskID >> 8) & 0xff)
   \   00003E   F0           MOVX    @DPTR,A
   1188            GenericApp_epDesc.simpleDesc = (SimpleDescriptionFormat_t *)&GenericApp_SimpleDesc;
   \   00003F   90....       MOV     DPTR,#(GenericApp_epDesc + 3)
   \   000042   74..         MOV     A,#(GenericApp_SimpleDesc & 0xff)
   \   000044   F0           MOVX    @DPTR,A
   \   000045   A3           INC     DPTR
   \   000046   74..         MOV     A,#((GenericApp_SimpleDesc >> 8) & 0xff)
   \   000048   F0           MOVX    @DPTR,A
   1189            GenericApp_epDesc.latencyReq = noLatencyReqs;
   \   000049   E4           CLR     A
   \   00004A   90....       MOV     DPTR,#(GenericApp_epDesc + 5)
   \   00004D   F0           MOVX    @DPTR,A
   1190            // Register the endpoint description with the AF
   1191            afRegister( &GenericApp_epDesc );
   \   00004E                ; Setup parameters for call to function afRegister
   \   00004E   7A..         MOV     R2,#(GenericApp_epDesc & 0xff)
   \   000050   7B..         MOV     R3,#((GenericApp_epDesc >> 8) & 0xff)
   \   000052   12....       LCALL   ??afRegister?relay
   1192            // Register for all key events - This app will handle all key events
   1193            RegisterForKeys( GenericApp_TaskID );
   \   000055                ; Setup parameters for call to function RegisterForKeys
   \   000055   90....       MOV     DPTR,#GenericApp_TaskID
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F9           MOV     R1,A
   \   00005A   12....       LCALL   ??RegisterForKeys?relay
   1194          #if defined( ZigBee_C_R_E_Transparent )
   1195          #if !defined( SENSOR_TYPE_Coord )
   1196          #if defined( SENSOR_TYPE_R_E )
   1197                   Send_data[4]= SENSOR_TYPE_R_E;
   1198                   Send_data[5]= SENSOR_TYPE;
   1199          #endif
   1200          #endif
   1201          #endif
   1202          #if defined( SENSOR_TYPE_Coord )
   1203          #if (ZDO_COORDINATOR)
   1204          #if(ZDO_COORDINATOR==2)  //ZIGBEE  AT命令模式 透传模式
   1205                uint16 nv_data,nv_data1;
   1206              osal_nv_read(ZCD_NV_APP_PANID_H,0,sizeof(nv_data),&nv_data);
   1207              osal_nv_read(ZCD_NV_APP_PANID_L,0,sizeof(nv_data1),&nv_data1);
   1208              if((nv_data!=0)&&(zgConfigPANID==0XFFFF)&&(nv_data1!=0)&&(nv_data1==nv_data))
   1209              {zgConfigPANID=nv_data;
   1210             //  HalUARTWrite(HAL_UART_PORT_0,"AAAAA",5);
   1211              }
   1212          #else
   1213               ZigBee_C_R_E_Engineering_G();
   1214          #endif 
   1215          #endif 
   1216          #endif  
   1217          Send_data[0]=0XFA;
   \   00005D   74FA         MOV     A,#-0x6
   \   00005F   90....       MOV     DPTR,#Send_data
   \   000062   F0           MOVX    @DPTR,A
   1218          #if defined( SENSOR_TYPE_Coord )
   1219          Send_data[0]=0XFD;
   1220          #endif
   1221          #if defined( SENSOR_TYPE_POWER )
   1222          Send_data[0]=0XFD;
   1223          #if defined( CC2530_V30 )
   1224           Send_data[0]=0XFE;
   1225          #endif
   1226          #endif
   1227          T_MGSbit=0x0A;//00001010可控类 综合型 
   \   000063   740A         MOV     A,#0xa
   \   000065   90....       MOV     DPTR,#T_MGSbit
   \   000068   F0           MOVX    @DPTR,A
   1228          
   1229          #if defined (NB_IOT_S10)
   1230            NBliucheng=0;
   1231          #endif
   1232            
   1233          #if((SENSOR_TYPE =='E')||(SENSOR_TYPE =='B')||(SENSOR_TYPE =='C')||(SENSOR_TYPE =='D')\
   1234            ||(SENSOR_TYPE =='F')||(SENSOR_TYPE =='U')||(SENSOR_TYPE ==0X10)||(SENSOR_TYPE ==0X21)\
   1235              ||(SENSOR_TYPE ==0X11)||(SENSOR_TYPE ==0X1A)||(SENSOR_TYPE ==0X0F)||(SENSOR_TYPE ==0X13)||(SENSOR_TYPE ==0X14)\
   1236                ||(SENSOR_TYPE ==0X24)||(SENSOR_TYPE ==0X6A)||(SENSOR_TYPE =='A')||(SENSOR_TYPE =='J')||\
   1237                  (SENSOR_TYPE =='L')||(SENSOR_TYPE =='M')||(SENSOR_TYPE ==0X33)\
   1238            ||(SENSOR_TYPE =='N')||(SENSOR_TYPE ==0X04)||(SENSOR_TYPE ==0X22)||(SENSOR_TYPE ==0X0C)\
   1239              ||(SENSOR_TYPE ==0X16)||(SENSOR_TYPE ==0X19)||(SENSOR_TYPE ==0X61)||(SENSOR_TYPE ==0X62)||(SENSOR_TYPE ==0X63)\
   1240                ||(SENSOR_TYPE ==0X5A)||(SENSOR_TYPE ==0X5B)||(SENSOR_TYPE ==0X72) ||(SENSOR_TYPE ==0X34)||(SENSOR_TYPE ==0X35)||(SENSOR_TYPE ==0X36)\
   1241                  ||(SENSOR_TYPE ==0X37)||(SENSOR_TYPE ==0X38)||(SENSOR_TYPE ==0X39)||(SENSOR_TYPE ==0X3A)||(SENSOR_TYPE ==0X80)\
   1242                    ||(SENSOR_TYPE ==0X3D)||(SENSOR_TYPE ==0X81)||(SENSOR_TYPE ==0X82)||(SENSOR_TYPE ==0X3B)||(SENSOR_TYPE ==0X3C)\
   1243                      ||(SENSOR_TYPE ==0X3E)||(SENSOR_TYPE ==0X3F)||(SENSOR_TYPE ==0X74)||(SENSOR_TYPE ==0X84)||(SENSOR_TYPE ==0X85)\
   1244                       ||(SENSOR_TYPE ==0X75)||(SENSOR_TYPE ==0X78) )
   1245                GenericApp_applicationbuf=60001;
   1246                GenericApp_time=1;
   1247          #if defined( POWER_SAVING )
   1248                GenericApp_time=25;
   1249          #endif
   1250          #endif
   1251          
   1252            
   1253          #if((SENSOR_TYPE =='A')||(SENSOR_TYPE =='J')||(SENSOR_TYPE =='L')||(SENSOR_TYPE =='M')||\
   1254            (SENSOR_TYPE =='N')||(SENSOR_TYPE ==0X04)||(SENSOR_TYPE ==0X0C)||(SENSOR_TYPE ==0X19)\
   1255              ||(SENSOR_TYPE ==0X22)||(SENSOR_TYPE ==0X61)||(SENSOR_TYPE ==0X62)||(SENSOR_TYPE ==0X63)||(SENSOR_TYPE ==0X72)\
   1256                ||(SENSOR_TYPE ==0X34)||(SENSOR_TYPE ==0X35)||(SENSOR_TYPE ==0X36)||(SENSOR_TYPE ==0X37)||(SENSOR_TYPE ==0X38)\
   1257                  ||(SENSOR_TYPE ==0X39)||(SENSOR_TYPE ==0X3A)||(SENSOR_TYPE ==0X3E)||(SENSOR_TYPE ==0X3F)||(SENSOR_TYPE ==0X75)) 
   1258          T_MGSbit=0x12;    // 00010010状态信息 数据信息  连数据信息记录
   1259          //采集类  BOOL型
   1260          #endif  
   1261          #if((SENSOR_TYPE =='B')||(SENSOR_TYPE =='C')||(SENSOR_TYPE =='D')||(SENSOR_TYPE =='G')||\
   1262            (SENSOR_TYPE =='I')||(SENSOR_TYPE ==0X77)||(SENSOR_TYPE =='Q')||(SENSOR_TYPE =='T')||(SENSOR_TYPE ==0X03)||(SENSOR_TYPE ==0X07)\
   1263              ||(SENSOR_TYPE ==0X0F)||(SENSOR_TYPE ==0X10)||(SENSOR_TYPE ==0X0E)\
   1264                ||(SENSOR_TYPE ==0X16)||(SENSOR_TYPE ==0X17)||(SENSOR_TYPE ==0X20)||(SENSOR_TYPE ==0X21)\
   1265                  ||(SENSOR_TYPE ==0X24)||(SENSOR_TYPE ==0X5A)||(SENSOR_TYPE ==0X5B)||(SENSOR_TYPE ==0X64)||(SENSOR_TYPE ==0X33)||(SENSOR_TYPE ==0X80)) 
   1266          T_MGSbit=0x14;    // 00010100状态信息 数据信息  连数据信息记录
   1267          //采集类  整型
   1268          #endif 
   1269          #if((SENSOR_TYPE =='E')||(SENSOR_TYPE =='F')||(SENSOR_TYPE =='U')||(SENSOR_TYPE ==0X81)||(SENSOR_TYPE ==0X82)||(SENSOR_TYPE ==0X85)) 
   1270          T_MGSbit=0x16; // 00010110状态信息 数据信息  连数据信息记录
   1271          //采集类  浮点型
   1272          #endif
   1273          #if((SENSOR_TYPE ==0X08)||(SENSOR_TYPE ==0X0A)||(SENSOR_TYPE ==0X0B)||(SENSOR_TYPE ==0X0D)) 
   1274          T_MGSbit=0x18;    // 00011000状态信息 数据信息  连数据信息记录
   1275          //采集类  字符串  数据第三位开始
   1276          #endif
   1277           ////////////////////////////////////////////////////////////////////////////////////////////
   1278          //OLED屏显示内容
   1279          /*
   1280          OLED_Init(); //OLED初始化 
   1281          OLED_P8x16Str(0,0,"R       ID:");//第一行 -- 8x16的显示单元显示ASCII码
   1282          #if defined( SENSOR_TYPE_Coord )
   1283          #if (ZDO_COORDINATOR)
   1284             OLED_P8x16Str(0,0,"C    PANID:");//第一行 -- 8x16的显示单元显示ASCII码
   1285          #endif 
   1286          #endif 
   1287          #if defined( POWER_SAVING )
   1288           OLED_P8x16Str(0,0,"E       ID:");//第一行 -- 8x16的显示单元显示ASCII码
   1289          #endif
   1290          char *s=0;
   1291          uint16 nv_data; 
   1292          osal_nv_read(ZCD_NV_APP_CHANLIST,0,sizeof(nv_data),&nv_data);
   1293          sprintf(s, "%02d", (nv_data&0x00ff)); 
   1294          OLED_P8x16Str(16,0,s);//第一行 -- 8x16的显示单元显示ASCII码
   1295          #if !defined( SENSOR_TYPE_Coord )
   1296          sprintf(s, "%02X", SENSOR_TYPE); 
   1297          OLED_P8x16Str(40,0,s);//第一行 -- 8x16的显示单元显示ASCII码
   1298          #endif 
   1299          osal_nv_read(ZCD_NV_APP_PANID_H,0,sizeof(nv_data),&nv_data);
   1300          sprintf(s, "%04X", nv_data); 
   1301          OLED_P8x16Str(88,0,s);//第一行 -- 8x16的显示单元显示ASCII码
   1302          OLED_P8x16Str(0,2,"V2.45");
   1303          #if defined( CC2530_V30 )
   1304          OLED_P8x16Str(0,2,"V3.00");
   1305          #endif
   1306          sprintf(s, "%04X", NLME_GetCoordShortAddr()); 
   1307          OLED_P8x16Str(48,2,s);
   1308          sprintf(s, "%04X", NLME_GetShortAddr());
   1309          OLED_P8x16Str(88,2,s);
   1310           byte * Send_d;
   1311            Send_d=NLME_GetExtAddr();
   1312          sprintf(s, "%02X%02X%02X%02X%02X%02X%02X%02X", *Send_d,*(Send_d+1),*(Send_d+2),*(Send_d+3),*(Send_d+4),*(Send_d+5),*(Send_d+6),*(Send_d+7));
   1313          OLED_P8x16Str(0,4,s);
   1314          */
   1315           ////////////////////////////////////////////////////////////////////////////////////////////
   1316          #if(SENSOR_TYPE =='Q') 
   1317            P1DIR|=0x02 ;  //数据输出 P1_1
   1318            P1DIR&=~0X04;  //数据输入 P1_2
   1319            P1DIR |= 0XF9;  
   1320            Send_data[6]='Q';//传感器类型
   1321           Send_datalend=0x03;    
   1322           RSn=50;
   1323           HX_Q=0;
   1324           HXtime=0;
   1325           HXS=0;
   1326           T_MUMPT1=0;
   1327            uint16 nv_data=0X0000;
   1328           osal_nv_read(ZCD_NV_APP_AD_SHINING,0,sizeof(nv_data),&nv_data);  
   1329           if((nv_data>49)&&(nv_data<151))AD_SHINING=nv_data;
   1330           else AD_SHINING=90;
   1331           
   1332           Ht1621_Init(); //上电初始化LCD
   1333           char t;
   1334            P1_0=0;
   1335            for (char i=0;i<15;i++) //30个字段 18个字段 SEG0～SEG17 
   1336                   {t=0x01;
   1337                    for (char j=0;j<4;j++)//4个一组 COM0-3
   1338                           {
   1339                            Ht1621WrOneData(i,t); //SEG0 COM0-3. SEG1 COM0-3. SEG2 COM0-3. SEG3 COM0-3. .......
   1340                           t<<=1;
   1341                            t++;
   1342                            }
   1343                     }
   1344           halMcuWaitMs(5000);//延时5秒 去皮操作 //延时一段时间
   1345            Ht1621WrAllData(0,Ht1621Tab,9);//清除1621寄存器数据，暨清屏 //SEG0～SEG17 COM0-3=0X00 0000 全灭
   1346           Tozero();//自动归零
   1347          #endif   
   1348          #if(SENSOR_TYPE ==0X08) 
   1349             Send_data[7]=0xA1;//读卡  15693
   1350             GenericApp_appIO=0;
   1351            GenericApp_BX=0;
   1352          #endif  
   1353          #if(SENSOR_TYPE ==0X0D) 
   1354          #if defined(TGRD15693) 
   1355             Send_data[7]=0xA1;//读卡  15693
   1356          #endif 
   1357          #if defined(PN532) 
   1358             Send_data[7]=0xA2;//M1卡
   1359          #endif 
   1360          #endif 
   1361          #if(SENSOR_TYPE ==0X0A) 
   1362             Send_datalend=0X14;
   1363              Send_data[7]=0xA1;//读卡  15693
   1364          #endif  
   1365          #if(SENSOR_TYPE ==0X0B) 
   1366             Send_datalend=0X14;
   1367              Send_data[7]=0x01;//读卡  125K
   1368          #endif  
   1369          #if((SENSOR_TYPE ==0X10)||(SENSOR_TYPE ==0X0F)||(SENSOR_TYPE ==0X17)||(SENSOR_TYPE ==0X21)) 
   1370           Send_datalend=0x03;   
   1371          HalAdcInit ();
   1372          #endif  
   1373          #if((SENSOR_TYPE ==0X11)||(SENSOR_TYPE ==0X1A)||(SENSOR_TYPE ==0X3D)||(SENSOR_TYPE ==0X3B)||(SENSOR_TYPE ==0X3C))
   1374           Send_datalend=0x06;   
   1375           GenericApp_sbum=0;
   1376           T_MUMPT1=0;
   1377          HalAdcInit ();
   1378          #endif  
   1379          #if(SENSOR_TYPE ==0X84) 
   1380           Send_datalend=0x05;   
   1381           GenericApp_sbum=0;
   1382            P1DIR|=0x1E;   //数据输出
   1383           T_MUMPT1=0;
   1384          HalAdcInit ();
   1385          #endif 
   1386          #if(SENSOR_TYPE ==0X23) 
   1387             Send_datalend=0X05;
   1388          #endif 
   1389          #if(SENSOR_TYPE ==0X24)
   1390             P1DIR|=0x04;   //数据输出 P1_2
   1391             P1DIR&=~0x02;  //数据输入 P1_1
   1392             P1_1=0;   P1_2=0;     //初始化引脚
   1393             Send_datalend=0x05;
   1394          #endif 
   1395          #if(SENSOR_TYPE ==0X80)
   1396             P2DIR&=~0x01;  //数据输入 P2_0  起始检测点
   1397             P2INP&=~0x01;//上拉
   1398             Send_datalend=0x07;
   1399          #endif 
   1400          #if(SENSOR_TYPE ==0X27)
   1401            // uint8 syn[11]={0XFD,0X00,0X08,0X01,0X01,0X5B,0X76,0X31,0X36,0X5D,0X82};//音量最大
   1402            // uint8 syn[11]={0XFD,0X00,0X08,0X01,0X01,0X5B,0X76,0X31,0X31,0X5D,0X82};//音量最中大
   1403             
   1404             //FD 00 07 01 01 5B 76 39 5D B3 //音量小中
   1405             //FD 00 07 01 01 5B 76 32 5D 82// 音量小
   1406               Send_datalend=3;
   1407                SYN_FrameInfo(0,1,"msgh",250) ;//ringo
   1408                // HalUARTWrite(HAL_UART_PORT_0,syn,11);//智能语言播报
   1409          #endif
   1410          #if(SENSOR_TYPE ==0X6F)
   1411            
   1412           P1DIR|=0XE0;
   1413           P1DIR|=0x1E;       //P1.1-P1.4数据输出
   1414           P1|=0X1E;           //
   1415           delay_ms(1);
   1416           init_lcd();
   1417           lcd_gra_clr();
   1418           lcd_txt_clr(); 
   1419           //hzkdis_b(0,"msgh",4);
   1420                hzkdis_b(0,"  无锡泛太科技",14);
   1421                Send_datalend=0x05;
   1422                SYN_FrameInfo(0,1,"msgh",250) ;//ringo
   1423                // HalUARTWrite(HAL_UART_PORT_0,syn,11);//智能语言播报
   1424          #endif
   1425                
   1426          #if(SENSOR_TYPE ==0X28)
   1427          { 
   1428            LCD_Init();   // LCD初始化
   1429            LCD_Clear();  // LCD清屏
   1430            /* 显示信息 */
   1431            LCD_WriteString(0,6,"WWW.fantaitech.com");
   1432           // LCD_WriteString(0,3,"FANTAI ELECTRONICS");
   1433           // LCD_WriteString(0,5,"WWW.fantaitech.com");
   1434           // LCD_WriteString(6,7,"453:0510-88236212");
   1435            Send_datalend=5;
   1436          } 
   1437          #endif 
   1438          #if(SENSOR_TYPE ==0X31)
   1439          car_stata=0;
   \   000069   E4           CLR     A
   \   00006A   90....       MOV     DPTR,#car_stata
   \   00006D   F0           MOVX    @DPTR,A
   1440          car_op=0; //清零，可处理读卡
   \   00006E   90....       MOV     DPTR,#car_op
   \   000071   F0           MOVX    @DPTR,A
   1441          car_sum=0;
   \   000072   90....       MOV     DPTR,#car_sum
   \   000075   F0           MOVX    @DPTR,A
   1442            P1SEL&=~0X01;
   \   000076   53F4FE       ANL     0xf4,#0xfe
   1443            P1DIR&=~0X01;  //P1_0输入模式
   \   000079   53FEFE       ANL     0xfe,#0xfe
   1444          #endif
   1445          #if(SENSOR_TYPE ==0X64)
   1446          { Send_datalend=0x03;
   1447            P1SEL&=~0Xff;
   1448            P1DIR&=~0X99;
   1449            P1DIR|=0X55;
   1450          }  
   1451          #endif
   1452          #if(SENSOR_TYPE ==0X65)
   1453           P0SEL=0X00;
   1454              P1SEL&=0X00;
   1455              P1DIR|=0Xff;
   1456              P1INP|=0Xf0;
   1457              Send_datalend=0x05;
   1458              LCD_lni();    //lcd初始化
   1459              LCD_clrscr(); //lcd清屏
   1460              show_left_up();  //lcd左半屏上面4个字显示函数   无锡泛
   1461              show_right_up();//lcd右半屏上面4个字显示函数   太科技
   1462              show_left_down();
   1463          #endif
   1464          #if(SENSOR_TYPE ==0X6C)
   1465           P1DIR|=0XE0;
   1466           P1DIR|=0x1E;       //P1.1-P1.4数据输出
   1467           P1|=0X1E;           //
   1468          Send_datalend=0x05;
   1469           delay_ms(1);
   1470           init_lcd();
   1471           lcd_gra_clr();
   1472           lcd_txt_clr(); 
   1473            hzkdis(0,tab0);
   1474          #endif
   1475          #if(SENSOR_TYPE ==0X33)
   1476            P1SEL &= ~(0x18);		//选择IO口
   1477            B_LUX30_Init();
   1478          #endif
   1479          #if((SENSOR_TYPE ==0X66)||(SENSOR_TYPE ==0X6E))
   1480           P0SEL=0X00;
   1481              P1SEL&=0X00;
   1482              P1DIR|=0Xff;
   1483              P1INP|=0Xf0;
   1484               P2SEL&=0X00;
   1485              P2DIR|=0X01;
   1486              Send_datalend=0x05;
   1487              uint8 spt[2]={0,0};
   1488               SendDataS(spt,2);
   1489          #endif
   1490          #if(SENSOR_TYPE ==0X76)
   1491               P2DIR&=~0X01;//输入
   1492              P2INP&=~0x01;//上拉
   1493              Send_datalend=0x05;
   1494          #endif
   1495          #if(SENSOR_TYPE ==0X30)
   1496              P1DIR|=0XE0;//输出
   1497              P1DIR|=0X0f;
   1498              P2DIR&=~0X01;//输入
   1499              P2INP&=~0x01;//上拉
   1500              Coil_OFF;
   1501              Send_datalend=0x05;
   1502              DAchange(4095);
   1503          #endif
   1504          #if(SENSOR_TYPE ==0X73)
   1505              P1DIR|=0Xf0;   //P1.6 P1.7输出
   1506              P2DIR&=~0X01;//输入
   1507              P2INP&=~0x01;//上拉
   1508              A8n=1;
   1509              Send_datalend=0x05;
   1510          #endif
   1511              
   1512          #if(SENSOR_TYPE ==0X7C)
   1513                uint8  hr[5]={0XF7,0x03,0xB1,0X52,0X00};
   1514               HalUARTWrite(HAL_UART_PORT_0,hr,5);//开关绑定模式 
   1515          #endif
   1516          #if(SENSOR_TYPE =='D') 
   1517          { Send_datalend=0x05;
   1518                 P1DIR|=0xff;       //数据输出
   1519                 P1SEL&=~0x01;P1DIR&=~0X01;
   1520                 P2SEL|=0x01;P2DIR|=0X01;
   1521                 P1_3=0;
   1522                 for(unsigned int i=0;i<50000;i++);
   1523                  S0=1;S1=1;
   1524          //----------------------白平衡调整-----------------------------
   1525          	 OUTR = 255.0/TCS3200(1);
   1526          	 OUTG = 255.0/TCS3200(2);
   1527          	 OUTB = 255.0/TCS3200(3);
   1528          } 
   1529          #endif                           
   1530          #if(SENSOR_TYPE =='S') 
   1531              P1SEL &=0xF7;
   1532              P1DIR |= 0x07;//P1.1,P1.2,P1.3数据输出
   1533              P1DIR &= ~(0xE0);//P1.5,P1.6,P1.7数据输入
   1534              P1INP |= 0x07;
   1535            Send_datalend=0x05;                         
   1536          #endif   
   1537          #if(SENSOR_TYPE ==0X67) 
   1538              P0SEL &=0x30;
   1539              P0DIR |= 0x30;//P0.4,P0.5,数据输出
   1540              P1DIR|=0XE0;//输出
   1541              P1DIR|=0X0F;//输出
   1542              P1_0=0;
   1543              P1_1=0;
   1544              P1_2=0;
   1545              P1_3=0;
   1546              P0_4=0;
   1547              P0_5=0;
   1548            Send_datalend=0x05;   
   1549          int mled=0;
   1550          //DAchange(4095);
   1551              mled=1000;
   1552              for(int i=0;i<3000;i++)
   1553              {halMcuWaitMs(1);
   1554              DAchange(mled);
   1555              mled+=1;
   1556              }
   1557          DAchange(0);
   1558          #endif  
   1559          #if(ENSOR_TYPE ==0X68) 
   1560              P0DIR |= 0x0F;//P0.0-3,数据输出
   1561              P0_0=0;P0_1=0;P0_2=0;P0_3=0;
   1562            Send_datalend=0x05;                         
   1563          #endif  
   1564          #if(SENSOR_TYPE ==0X6A) 
   1565          #if defined(ADCP) 
   1566              HalAdcInit ();
   1567          #endif 
   1568              Send_data[7]=0;
   1569          #if defined(HX711P) 
   1570               P1DIR|=0x02 ;  //数据输出 P1_1
   1571              P1DIR&=~0X04;  //数据输入 P1_2
   1572              Tozero();//自动归零
   1573          #endif 
   1574            Send_datalend=0x05;                         
   1575          #endif 
   1576          #if(SENSOR_TYPE ==0X03)  //P1.0-P1.3  D0-D3  P0.7 VT
   1577             
   1578              P1DIR &= ~(0x1F);//P1.0,P1.1,P1.2,P1.3,P1.4数据输入
   1579               P1INP |= 0x1F;
   1580             Send_datalend=0x03;                         
   1581          #endif   
   1582          #if(SENSOR_TYPE ==0X05) 
   1583           //P1DIR&=(~0x06);       //P1.1 P1.2数据输入
   1584          P1DIR|=0xC0;       //P1.6,P1.7数据输出
   1585          P1_6=0;
   1586          P1_7=0;
   1587          Send_datalend=0x05;                                             
   1588          #endif   
   1589          #if(SENSOR_TYPE =='U') 
   1590            Send_datalend=0x04;
   1591           P1SEL &= ~0X04;P1INP|=0X04;
   1592          #endif    
   1593          #if(SENSOR_TYPE =='H') 
   1594           P1DIR|=0xC1;       //P1.0,P1.6,P1.7数据输出
   1595          P1_0=1;
   1596          P1_6=1;
   1597          P1_7=1;
   1598          Send_datalend=0x05;                         
   1599          #endif      
   1600          #if((SENSOR_TYPE =='P')||(SENSOR_TYPE ==0X02))
   1601          Send_datalend=0x05;
   1602          #endif  
   1603          #if(SENSOR_TYPE ==0X77)
   1604          Send_datalend=0x03;
   1605            P1SEL&=~0Xff;
   1606            P1DIR&=~0Xff;
   1607           // P1INP&=~0Xff;P2INP&=~0X40;
   1608          #endif  
   1609          #if(SENSOR_TYPE =='I')
   1610          { Send_datalend=0x05;
   1611            P1SEL&=~0Xff;
   1612            P1DIR&=~0Xff;
   1613           // P1INP|= 0Xff;
   1614            
   1615            P2SEL&=~0X07;
   1616            P2DIR&=~0X07;
   1617           // P2INP|= 0X07;
   1618            P0SEL&=~0X10;
   1619            P0DIR&=~0X10;
   1620            //P0INP|= 0X10;
   1621          }  
   1622          #endif  
   1623          
   1624          #if(SENSOR_TYPE =='G')
   1625          { Send_datalend=0x08;
   1626           P1DIR|=0X0f;
   1627           Coil_OFF;
   1628          Coil_AB=0;
   1629          } 
   1630          #endif                            
   1631          #if(SENSOR_TYPE =='F')
   1632          #if defined(BMP085) 
   1633          { Send_datalend=0x06;
   1634           XCLROUT;
   1635            BMP085_init();	//读取BMP085的E2PROM中的11个标定参数
   1636          }
   1637          #endif 
   1638          #if defined(BMP180) 
   1639          
   1640          #define XCLR P1_5 
   1641          #define XCLROUT P1DIR|=0x20       //数据输出
   1642          Send_datalend=0x06;
   1643           XCLROUT;
   1644           XCLR=1; 
   1645           
   1646           Init_BMP180();
   1647           
   1648          #endif
   1649          #endif                         
   1650          #if(SENSOR_TYPE =='C')
   1651          { Send_datalend=0x03;}
   1652          #endif            
   1653          
   1654          #if(SENSOR_TYPE =='B')
   1655          { Send_datalend=0x05;
   1656            MMA7660_Startup();
   1657          } 
   1658          #endif   
   1659          #if((SENSOR_TYPE ==0X13)||(SENSOR_TYPE ==0X5A)||(SENSOR_TYPE ==0X5B)||(SENSOR_TYPE ==0X70))
   1660                P1DIR|=0x01;       //P1.0数据输出  485控制端
   1661            P1_0=0;
   1662            Send_data[6]=SENSOR_TYPE;
   1663            Send_data[7]=0XAA;
   1664             Send_datalend=0X04;
   1665            //U0UCR|=0X38;
   1666          #endif 
   1667          #if(SENSOR_TYPE ==0X14) 
   1668            P1DIR|=0x01;       //P1.0数据输出  485控制端
   1669            P1_0=0;
   1670             Send_datalend=0X07;
   1671          #if defined(PH_E201C)
   1672           P1SEL &= ~0X04;P1INP|=0X04;
   1673             HalAdcInit ();
   1674          #endif 
   1675          #endif 
   1676          #if(SENSOR_TYPE ==0X74)
   1677            P1DIR|=0x01;       //P1.0数据输出  485控制端
   1678            P1_0=0;
   1679            Send_datalend=0X05;
   1680          #endif 
   1681          #if(SENSOR_TYPE ==0X15)
   1682          { 
   1683          P1DIR|=0x1E;       //P1.0-P1.4数据输出
   1684          P1=0X1E;           //
   1685          Send_datalend=0x05;
   1686          } 
   1687          #endif 
   1688          #if(SENSOR_TYPE =='K')
   1689          { 
   1690          P1DIR&=(~0x06);       //P1.1 P1.2数据输入
   1691          P1SEL &= ~0X06;P1INP|=0X06;  //上啦
   1692          P1DIR|=0x01;       //P1.0数据输出
   1693          P1_0=1;  T_MG=0X00;       //继电器关
   1694          Send_datalend=0x05;
   1695          } 
   1696          #endif  
   1697          #if(SENSOR_TYPE ==0X79)
   1698          PDI=0;
   1699          ERR_TEMP=0;
   1700          P1DIR|=0x21;       //P1_5  P1_0数据输出
   1701          P1_5=P1_0=0X01;         //继电器关
   1702          Send_datalend=0x05;
   1703            P1SEL &= ~0X06;P1INP|=0X04; P1DIR|=0x06;
   1704            s_connectionreset(); //温湿度初始化
   1705           HalAdcInit (); //ad采集初始化
   1706          #endif  
   1707          #if(SENSOR_TYPE ==0X83)
   1708          {
   1709          P0DIR&=(~0xf0);       //P07 P06 P05数据输入
   1710          P0SEL &= ~0Xf0;P0INP|=0Xf0;  //上啦
   1711          P1DIR|=0xFF;       //P1数据输出
   1712          P1=0XFF; T_MG=0X00;       //继电器关
   1713          Send_datalend=0x05;
   1714          } 
   1715          #endif  
   1716          #if(SENSOR_TYPE ==0X40)
   1717          { 
   1718          P1DIR|=0x0E;       //P1.1 P1.2 P1.3数据输出
   1719          P1DIR|=0x91;       //P1.7 P1.4 P1.0数据输出
   1720          P1_1=1;           //
   1721          P1_2=1;           //
   1722          P1_3=1;           //
   1723          P1_0=0;           //蜂鸣器
   1724          P1_4=0;           //红灯
   1725          P1_7=0;           //蓝灯
   1726          Send_datalend=0x05;
   1727          } 
   1728          #endif 
   1729          
   1730          #if(SENSOR_TYPE ==0X07)
   1731          AB=0x0A;
   1732          #endif 
   1733          #if(SENSOR_TYPE ==0X12)
   1734          { 
   1735          P1DIR&=(~0x06);       //P1.1 P1.2数据输入
   1736          P1SEL &= ~0X06;P1INP|=0X06;  //上啦
   1737          P1DIR|=0xC1;       //P1.0,P1.6,P1.7数据输出
   1738          P1_0=1;//继电器关
   1739          P1_6=1;
   1740          P1_7=1;     
   1741          Send_datalend=0x05;
   1742          } 
   1743          #endif 
   1744          #if(SENSOR_TYPE ==0X18)
   1745          { 
   1746          P1DIR&=(~0x06);       //P1.1 P1.2数据输入
   1747          P1SEL &= ~0X06;P1INP|=0X06;  //上啦
   1748          P1DIR|=0xC1;       //P1.0,P1.6,P1.7数据输出
   1749          P1_0=1;   
   1750          U0UCR|=0X38;
   1751          Send_datalend=0x05;
   1752          } 
   1753          #endif 
   1754          #if(SENSOR_TYPE ==0X06)
   1755          Send_datalend=0x05;
   1756           P1SEL &= ~0X04;P1INP|=0X04;
   1757           ReadTemperature(); 
   1758          #endif
   1759          #if(SENSOR_TYPE ==0X09)
   1760          Send_datalend=0x05;
   1761          #endif
   1762          
   1763          #if defined (NB_IOT_S10)
   1764          P0SEL &= ~0X10;
   1765          P0DIR|=0x10;       //P0.4,数据输出
   1766          P0_4=0;   
   1767          #endif
   1768          
   1769          #if(SENSOR_TYPE =='E')
   1770          { Send_datalend=0x06;
   1771            P1SEL &= ~0X06;P1INP|=0X04; P1DIR|=0x06;
   1772            s_connectionreset();
   1773          } 
   1774          #endif 
   1775          #if(SENSOR_TYPE ==0X85)
   1776                _SCL_IO;                                            //引用宏定义-设置SCL为开漏式I/O口
   1777               _SDA_OUTPUT;                                //引用宏定义-设置SDA为开漏式输出
   1778               SCL=0;				//
   1779               Delay_mlx90615(30000);		 //SMBus请求时间，将PWM模式转换为SMBus模式(21ms - 39ms)
   1780               SCL=1;				//	
   1781          #endif 
   1782          #if(SENSOR_TYPE ==0X82)
   1783          { Send_datalend=0x09;
   1784            P1SEL &= ~0X18;P1INP|=0X18; P1DIR|=0x18;
   1785            P1DIR&=(~0x04)  ; //P1_2数据输入 上拉
   1786            Init_HMC5883();
   1787          } 
   1788          #endif 
   1789          #if(SENSOR_TYPE ==0X81)
   1790          { 
   1791            Send_datalend=0x06;
   1792            P1DIR&=(~0x20);       // P1.5数据输入
   1793          P1SEL &= ~0X20;P1INP|=0X20;  //上啦
   1794          P1DIR|=0xC0;       //PP1.6,P1.7数据输出
   1795          } 
   1796          #endif 
   1797          #if(SENSOR_TYPE ==0X78)
   1798          Send_datalend=34;
   1799          send_Instruction();//向模块发送5个指令
   1800          
   1801          #endif 
   1802          
   1803          #if((SENSOR_TYPE =='A')||(SENSOR_TYPE =='J')||(SENSOR_TYPE =='L')||(SENSOR_TYPE =='M')||(SENSOR_TYPE =='N')\
   1804            ||(SENSOR_TYPE ==0X04)||(SENSOR_TYPE ==0X22)||(SENSOR_TYPE ==0X0C)||(SENSOR_TYPE ==0X16)||(SENSOR_TYPE ==0X19)\
   1805              ||(SENSOR_TYPE ==0X61)||(SENSOR_TYPE ==0X62)||(SENSOR_TYPE ==0X63)||(SENSOR_TYPE ==0X72) ||(SENSOR_TYPE ==0X34)\
   1806                ||(SENSOR_TYPE ==0X35)||(SENSOR_TYPE ==0X36)||(SENSOR_TYPE ==0X37)||(SENSOR_TYPE ==0X38)||(SENSOR_TYPE ==0X39)\
   1807                  ||(SENSOR_TYPE ==0X3A)||(SENSOR_TYPE ==0X3E)||(SENSOR_TYPE ==0X3F)||(SENSOR_TYPE ==0X75))
   1808          {
   1809            Send_datalend=0x04;
   1810          #if(SENSOR_TYPE ==0X72)
   1811              Send_datalend=0x06;
   1812          #if defined( SDS011 )
   1813          Send_datalend=0x08;
   1814          #endif
   1815          #endif   
   1816          #if(SENSOR_TYPE ==0X22)
   1817          Send_datalend=0x05;
   1818          #endif
   1819          HalAdcInit ();
   1820          P2SEL &=( ~0X01);
   1821          P2DIR&=(~0x01);       // P2.0数据输入
   1822          P2INP=0X00;  //上啦  
   1823          P2INP &=(~0X01); //上啦
   1824          T_MUMPT1=0;
   1825          }  
   1826          #endif     
   1827          
   1828            // Update the display
   1829          #ifdef SERIAL_DEBUG_SUPPORTED
   1830            //printf("GenericApp\n"); 
   1831          #endif
   1832            
   1833            //ZDO_RegisterForZDOMsg( GenericApp_TaskID, End_Device_Bind_rsp );
   1834            //ZDO_RegisterForZDOMsg( GenericApp_TaskID, Match_Desc_rsp );
   1835          }
   \   00007C   02....       LJMP    ??Subroutine32_0 & 0xFFFF
   \   00007F                REQUIRE P1SEL
   \   00007F                REQUIRE P1DIR
   1836          /*********************************************************************
   1837           * @fn      GenericApp_ProcessEvent
   1838           *
   1839           * @brief   Generic Application Task event processor.  This function
   1840           *          is called to process all events for the task.  Events
   1841           *          include timers, messages and any other user defined events.
   1842           *
   1843           * @param   task_id  - The OSAL assigned task ID.
   1844           * @param   events - events to process.  This is a bit map and can
   1845           *                   contain more than one event.
   1846           *
   1847           * @return  none
   1848           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1849          UINT16 GenericApp_ProcessEvent( byte task_id, UINT16 events )
   \                     GenericApp_ProcessEvent:
   1850          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1851            afIncomingMSGPacket_t *MSGpkt;
   1852            afDataConfirm_t *afDataConfirm;
   1853            // Data Confirmation message fields
   1854            byte sentEP;
   1855            ZStatus_t sentStatus;
   1856            byte sentTransID;       // This should match the value sent
   1857            (void)task_id;  // Intentionally unreferenced parameter
   1858          
   1859            if ( events & SYS_EVENT_MSG )
   \   00000E   7480         MOV     A,#-0x80
   \   000010   5F           ANL     A,R7
   \   000011   F9           MOV     R1,A
   \   000012   E4           CLR     A
   \   000013   7001         JNZ     ??GenericApp_ProcessEvent_0
   \   000015   E9           MOV     A,R1
   \                     ??GenericApp_ProcessEvent_0:
   \   000016   7003         JNZ     $+5
   \   000018   02....       LJMP    ??GenericApp_ProcessEvent_1 & 0xFFFF
   1860            {
   1861              MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( GenericApp_TaskID );
   \   00001B                ; Setup parameters for call to function osal_msg_receive
   \   00001B   801F         SJMP    ??GenericApp_ProcessEvent_2
   1862              while ( MSGpkt )
   1863              { 
   1864                switch ( MSGpkt->hdr.event )
                       ^
Warning[Pe546]: transfer of control bypasses initialization of:
            variable "s" (declared at line 1908 of
                      "C:\Users\win7\Desktop\ZStack传感器透明传输源程序V2.45-13
                      (带回码2018-5-20)\Projects\GenericApp\Source\GenericApp.c
                      ")
   1865                {
   1866                  /*case ZDO_CB_MSG:
   1867                    GenericApp_ProcessZDOMsgs( (zdoIncomingMsg_t *)MSGpkt );
   1868                    break;*/
   1869                    
   1870                  case KEY_CHANGE:
   1871                    GenericApp_HandleKeys(((keyChange_t *)MSGpkt)->state, ((keyChange_t *)MSGpkt)->keys);
   \                     ??GenericApp_ProcessEvent_3:
   \   00001D                ; Setup parameters for call to function GenericApp_HandleKeys
   \   00001D   85..82       MOV     DPL,?V0 + 0
   \   000020   85..83       MOV     DPH,?V0 + 1
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   E0           MOVX    A,@DPTR
   \   000027   FA           MOV     R2,A
   \   000028   85..82       MOV     DPL,?V0 + 0
   \   00002B   85..83       MOV     DPH,?V0 + 1
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F9           MOV     R1,A
   \   000032   12....       LCALL   ??GenericApp_HandleKeys?relay
   1872          		  break; 
   1873          
   1874                  case AF_DATA_CONFIRM_CMD:
   1875                    // This message is received as a confirmation of a data packet sent.
   1876                    // The status is of ZStatus_t type [defined in ZComDef.h]
   1877                    // The message fields are defined in AF.h
   1878                    afDataConfirm = (afDataConfirm_t *)MSGpkt;
   1879                    sentEP = afDataConfirm->endpoint;
   1880                    sentStatus = afDataConfirm->hdr.status;
   1881                    sentTransID = afDataConfirm->transID;
   1882                    (void)sentEP;
   1883                    (void)sentTransID;
   1884          
   1885                    // Action taken when confirmation is received.
   1886                    if ( sentStatus != ZSuccess )
   1887                    {
   1888                      // The data wasn't delivered -- Do something
   1889                    }
   1890                    break;
   1891          
   1892                  case AF_INCOMING_MSG_CMD:
   1893                    GenericApp_MessageMSGCB( MSGpkt );
   1894                    break;
   1895          
   1896                  case ZDO_STATE_CHANGE:
   1897                    GenericApp_NwkState = (devStates_t)(MSGpkt->hdr.status);
   1898                    if ( (GenericApp_NwkState == DEV_ZB_COORD)
   1899                        /*|| (GenericApp_NwkState == DEV_ROUTER)
   1900                        || (GenericApp_NwkState == DEV_END_DEVICE)*/ )
   1901                    {
   1902                      // Start sending "the" message in a regular interval.
   1903                      osal_start_timerEx( GenericApp_TaskID, GENERICAPP_SEND_MSG_EVT,
   1904                                          GENERICAPP_SEND_MSG_TIMEOUT );
   1905                    }
   1906          ////////////////////////////////////////////////////////////////////////////////////////////
   1907          //OLED屏显示内容        
   1908          char *s=0;
   1909          uint16 nv_data; 
   1910          osal_nv_read(ZCD_NV_APP_PANID_H,0,sizeof(nv_data),&nv_data);
   1911          sprintf(s, "%04X", nv_data); 
   1912          OLED_P8x16Str(88,0,s);//第一行 -- 8x16的显示单元显示ASCII码
   1913          sprintf(s, "%04X", NLME_GetCoordShortAddr());  
   1914          OLED_P8x16Str(48,2,s);
   1915          sprintf(s, "%04X", NLME_GetShortAddr());  
   1916          OLED_P8x16Str(88,2,s); 
   1917           ////////////////////////////////////////////////////////////////////////////////////////////
   1918                    break;
   1919                  default:
   1920                    break;
   1921          }
   1922                // Release the memory
   1923                osal_msg_deallocate( (uint8 *)MSGpkt );
   \                     ??GenericApp_ProcessEvent_4:
   \   000035                ; Setup parameters for call to function osal_msg_deallocate
   \   000035   AA..         MOV     R2,?V0 + 0
   \   000037   AB..         MOV     R3,?V0 + 1
   \   000039   12....       LCALL   ??osal_msg_deallocate?relay
   1924                // Next
   1925                MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( GenericApp_TaskID );
   \   00003C                ; Setup parameters for call to function osal_msg_receive
   \                     ??GenericApp_ProcessEvent_2:
   \   00003C   90....       MOV     DPTR,#GenericApp_TaskID
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F9           MOV     R1,A
   \   000041   12....       LCALL   ??osal_msg_receive?relay
   \   000044   8A..         MOV     ?V0 + 0,R2
   \   000046   8B..         MOV     ?V0 + 1,R3
   \   000048   E5..         MOV     A,?V0 + 0
   \   00004A   7002         JNZ     ??GenericApp_ProcessEvent_5
   \   00004C   E5..         MOV     A,?V0 + 1
   \                     ??GenericApp_ProcessEvent_5:
   \   00004E   7003         JNZ     $+5
   \   000050   02....       LJMP    ??GenericApp_ProcessEvent_6 & 0xFFFF
   \   000053   85..82       MOV     DPL,?V0 + 0
   \   000056   85..83       MOV     DPH,?V0 + 1
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for GenericApp_ProcessEvent>_0`:
   \   00005D   00           DB        0
   \   00005E   04           DB        4
   \   00005F   1A           DB        26
   \   000060   ....         DW        ??GenericApp_ProcessEvent_7
   \   000062   C0           DB        192
   \   000063   ....         DW        ??GenericApp_ProcessEvent_3
   \   000065   D1           DB        209
   \   000066   ....         DW        ??GenericApp_ProcessEvent_8
   \   000068   FD           DB        253
   \   000069   ....         DW        ??GenericApp_ProcessEvent_4
   \   00006B   ....         DW        ??GenericApp_ProcessEvent_4
   \                     ??GenericApp_ProcessEvent_7:
   \   00006D                ; Setup parameters for call to function GenericApp_MessageMSGCB
   \   00006D   AA..         MOV     R2,?V0 + 0
   \   00006F   AB..         MOV     R3,?V0 + 1
   \   000071   12....       LCALL   ??GenericApp_MessageMSGCB?relay
   \   000074   80BF         SJMP    ??GenericApp_ProcessEvent_4
   \                     ??GenericApp_ProcessEvent_8:
   \   000076   85..82       MOV     DPL,?V0 + 0
   \   000079   85..83       MOV     DPH,?V0 + 1
   \   00007C   A3           INC     DPTR
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   90....       MOV     DPTR,#GenericApp_NwkState
   \   000081   F0           MOVX    @DPTR,A
   \   000082   6409         XRL     A,#0x9
   \   000084   7010         JNZ     ??GenericApp_ProcessEvent_9
   \   000086                ; Setup parameters for call to function osal_start_timerEx
   \   000086   7CF4         MOV     R4,#-0xc
   \   000088   7D01         MOV     R5,#0x1
   \   00008A   7A01         MOV     R2,#0x1
   \   00008C   7B00         MOV     R3,#0x0
   \   00008E   90....       MOV     DPTR,#GenericApp_TaskID
   \   000091   E0           MOVX    A,@DPTR
   \   000092   F9           MOV     R1,A
   \   000093   12....       LCALL   ??osal_start_timerEx?relay
   \                     ??GenericApp_ProcessEvent_9:
   \   000096                ; Setup parameters for call to function osal_nv_read
   \   000096   85..82       MOV     DPL,?XSP + 0
   \   000099   85..83       MOV     DPH,?XSP + 1
   \   00009C   8582..       MOV     ?V0 + 4,DPL
   \   00009F   8583..       MOV     ?V0 + 5,DPH
   \   0000A2   78..         MOV     R0,#?V0 + 4
   \   0000A4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A7   75..02       MOV     ?V0 + 4,#0x2
   \   0000AA   75..00       MOV     ?V0 + 5,#0x0
   \   0000AD   78..         MOV     R0,#?V0 + 4
   \   0000AF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B2   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   0000B5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B8                ; Setup parameters for call to function sprintf
   \   0000B8   85..82       MOV     DPL,?XSP + 0
   \   0000BB   85..83       MOV     DPH,?XSP + 1
   \   0000BE   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000C1   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   0000C4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C7                ; Setup parameters for call to function OLED_P8x16Str
   \   0000C7   7C00         MOV     R4,#0x0
   \   0000C9   7D00         MOV     R5,#0x0
   \   0000CB   7A00         MOV     R2,#0x0
   \   0000CD   7958         MOV     R1,#0x58
   \   0000CF   12....       LCALL   ??OLED_P8x16Str?relay
   \   0000D2                ; Setup parameters for call to function sprintf
   \   0000D2                ; Setup parameters for call to function NLME_GetCoordShortAddr
   \   0000D2   12....       LCALL   ??NLME_GetCoordShortAddr?relay
   \   0000D5   8A..         MOV     ?V0 + 4,R2
   \   0000D7   8B..         MOV     ?V0 + 5,R3
   \   0000D9   78..         MOV     R0,#?V0 + 4
   \   0000DB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000DE   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   0000E1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E4                ; Setup parameters for call to function OLED_P8x16Str
   \   0000E4   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   0000E7   8A..         MOV     ?V0 + 4,R2
   \   0000E9   8B..         MOV     ?V0 + 5,R3
   \   0000EB   78..         MOV     R0,#?V0 + 4
   \   0000ED   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F0   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   0000F3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F6                ; Setup parameters for call to function OLED_P8x16Str
   \   0000F6   7C00         MOV     R4,#0x0
   \   0000F8   7D00         MOV     R5,#0x0
   \   0000FA   7A02         MOV     R2,#0x2
   \   0000FC   7958         MOV     R1,#0x58
   \   0000FE   12....       LCALL   ??OLED_P8x16Str?relay
   \   000101   02....       LJMP    ??GenericApp_ProcessEvent_4 & 0xFFFF
   1926              }
   1927              // return unprocessed events
   1928              return (events ^ SYS_EVENT_MSG);
   \                     ??GenericApp_ProcessEvent_6:
   \   000104   EE           MOV     A,R6
   \   000105   FA           MOV     R2,A
   \   000106   7480         MOV     A,#-0x80
   \   000108   6F           XRL     A,R7
   \                     ??GenericApp_ProcessEvent_10:
   \   000109   FB           MOV     R3,A
   \   00010A   8020         SJMP    ??GenericApp_ProcessEvent_11
   1929            }
   1930            // Send a message out - This event is generated by a timer
   1931            // (setup in GenericApp_Init()).
   1932            if ( events & GENERICAPP_SEND_MSG_EVT )
   \                     ??GenericApp_ProcessEvent_1:
   \   00010C   EE           MOV     A,R6
   \   00010D   A2E0         MOV     C,0xE0 /* A   */.0
   \   00010F   5017         JNC     ??GenericApp_ProcessEvent_12
   1933            {
   1934              // Send "the" message
   1935            //  GenericApp_SendTheMessage();
   1936              // Setup to send message again
   1937             osal_start_timerEx( GenericApp_TaskID, GENERICAPP_SEND_MSG_EVT,
   1938                                 GENERICAPP_SEND_MSG_TIMEOUT );
   \   000111                ; Setup parameters for call to function osal_start_timerEx
   \   000111   7CF4         MOV     R4,#-0xc
   \   000113   7D01         MOV     R5,#0x1
   \   000115   7A01         MOV     R2,#0x1
   \   000117   7B00         MOV     R3,#0x0
   \   000119   90....       MOV     DPTR,#GenericApp_TaskID
   \   00011C   E0           MOVX    A,@DPTR
   \   00011D   F9           MOV     R1,A
   \   00011E   12....       LCALL   ??osal_start_timerEx?relay
   1939              // return unprocessed events
   1940              return (events ^ GENERICAPP_SEND_MSG_EVT);
   \   000121   7401         MOV     A,#0x1
   \   000123   6E           XRL     A,R6
   \   000124   FA           MOV     R2,A
   \   000125   EF           MOV     A,R7
   \   000126   80E1         SJMP    ??GenericApp_ProcessEvent_10
   1941            }
   1942            // Discard unknown events
   1943            return 0;
   \                     ??GenericApp_ProcessEvent_12:
   \   000128   7A00         MOV     R2,#0x0
   \   00012A   7B00         MOV     R3,#0x0
   \                     ??GenericApp_ProcessEvent_11:
   \   00012C   7402         MOV     A,#0x2
   \   00012E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000131                REQUIRE ?Subroutine2
   \   000131                ; // Fall through to label ?Subroutine2
   1944          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   7C00         MOV     R4,#0x0
   \   000002   7D00         MOV     R5,#0x0
   \   000004   7A01         MOV     R2,#0x1
   \   000006                REQUIRE ??Subroutine33_0
   \   000006                ; // Fall through to label ??Subroutine33_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine33_0:
   \   000000   7B04         MOV     R3,#0x4
   \   000002   12....       LCALL   ??osal_nv_read?relay
   \   000005   7404         MOV     A,#0x4
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   7C..         MOV     R4,#(`?<Constant "%04X">` & 0xff)
   \   000002   7D..         MOV     R5,#((`?<Constant "%04X">` >> 8) & 0xff)
   \   000004                REQUIRE ??Subroutine34_0
   \   000004                ; // Fall through to label ??Subroutine34_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine34_0:
   \   000000   7A00         MOV     R2,#0x0
   \   000002   7B00         MOV     R3,#0x0
   \   000004   12....       LCALL   ??sprintf?relay
   \   000007   7402         MOV     A,#0x2
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   7C00         MOV     R4,#0x0
   \   000002   7D00         MOV     R5,#0x0
   \   000004   7A02         MOV     R2,#0x2
   \   000006   7930         MOV     R1,#0x30
   \   000008   12....       LCALL   ??OLED_P8x16Str?relay
   \   00000B                ; Setup parameters for call to function sprintf
   \   00000B                ; Setup parameters for call to function NLME_GetShortAddr
   \   00000B                ; Setup parameters for call to function sprintf
   \   00000B                ; Setup parameters for call to function NLME_GetShortAddr
   \   00000B                ; Setup parameters for call to function sprintf
   \   00000B                ; Setup parameters for call to function NLME_GetShortAddr
   \   00000B   12....       LCALL   ??NLME_GetShortAddr?relay
   \   00000E   22           RET
   1945          
   1946          /*********************************************************************
   1947           * Event Generation Functions
   1948           */
   1949          
   1950          /*********************************************************************
   1951           * @fn      GenericApp_ProcessZDOMsgs()
   1952           *
   1953           * @brief   Process response messages
   1954           *
   1955           * @param   none
   1956           *
   1957           * @return  none
   1958           *//*
   1959          void GenericApp_ProcessZDOMsgs( zdoIncomingMsg_t *inMsg )
   1960          {
   1961            switch ( inMsg->clusterID )
   1962            {
   1963              case End_Device_Bind_rsp:
   1964                if ( ZDO_ParseBindRsp( inMsg ) == ZSuccess )
   1965                {
   1966                  // Light LED
   1967                  HalLedSet( HAL_LED_2, HAL_LED_MODE_ON );
   1968                }
   1969          #if defined(BLINK_LEDS)
   1970                else
   1971                {
   1972                  // Flash LED to show failure
   1973                  HalLedSet ( HAL_LED_2, HAL_LED_MODE_FLASH );
   1974                }
   1975          #endif
   1976                break;
   1977          
   1978              case Match_Desc_rsp:
   1979                {
   1980                  ZDO_ActiveEndpointRsp_t *pRsp = ZDO_ParseEPListRsp( inMsg );
   1981                  if ( pRsp )
   1982                  {
   1983                    if ( pRsp->status == ZSuccess && pRsp->cnt )
   1984                    {
   1985                      GenericApp_DstAddr.addrMode = (afAddrMode_t)Addr16Bit;
   1986                      GenericApp_DstAddr.addr.shortAddr = pRsp->nwkAddr;
   1987                      // Take the first endpoint, Can be changed to search through endpoints
   1988                      GenericApp_DstAddr.endPoint = pRsp->epList[0];
   1989          
   1990                      // Light LED
   1991                      HalLedSet( HAL_LED_2, HAL_LED_MODE_ON );
   1992                    }
   1993                    osal_mem_free( pRsp );
   1994                  }
   1995                }
   1996                break;
   1997            }
   1998          }*/
   1999          
   2000          /*********************************************************************
   2001           * @fn      GenericApp_HandleKeys
   2002           *
   2003           * @brief   Handles all key events for this device.
   2004           *
   2005           * @param   shift - true if in shift/alt.
   2006           * @param   keys - bit field for key events. Valid entries:
   2007           *                 HAL_KEY_SW_2
   2008           *                 HAL_KEY_SW_1
   2009           *
   2010           * @return  none
   2011           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2012          void GenericApp_HandleKeys( byte shift, byte keys )
   \                     GenericApp_HandleKeys:
   2013          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   2014            zAddrType_t dstAddr;
   2015            // Shift is used to make each button/switch dual purpose.
   2016            if ( true )
   2017            {
   2018              if ( keys & HAL_KEY_SW_1 )
   \   00000C   EA           MOV     A,R2
   \   00000D   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000F   4003         JC      $+5
   \   000011   02....       LJMP    ??GenericApp_HandleKeys_0 & 0xFFFF
   2019              {
   2020          #if(SENSOR_TYPE =='O')
   2021                char hr[5]={0xCE,0x03,0xFC,0x00,0xDE};
   2022                hr[3]=0XCC;
   2023                HalUARTWrite(HAL_UART_PORT_0, (uint8*)hr,5);
   2024          #endif    
   2025          #if(SENSOR_TYPE =='G')
   2026          if(Coil_AB==0)Coil_AB=1;
   2027          else if(Coil_AB<5)Coil_AB=10;
   2028          else Coil_AB=0;
   2029          #endif 
   2030          #if(SENSOR_TYPE =='P')
   2031                uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   2032              GenericApp_applicationbuf=0;
   2033              GenericApp_SendTheMessage();
   2034               HalUARTWrite(HAL_UART_PORT_0,hr,8);//学习
   2035          #endif
   2036          #if(SENSOR_TYPE ==0X25)
   2037                uint8  hr[10]={0XF7,0x08,0xAA,0X02,0X01,0X01,0X00,0X0B,0X0B,0X0B};
   2038               Send_datalend=2;
   2039              GenericApp_SendTheMessage();
   2040               HalUARTWrite(HAL_UART_PORT_0,hr,10);//学习红外
   2041          #endif
   2042          #if(SENSOR_TYPE ==0X7C)
   2043                uint8  hr[5]={0XF7,0x03,0xB1,0X52,0X00};
   2044               Send_datalend=2;
   2045              GenericApp_SendTheMessage();
   2046               HalUARTWrite(HAL_UART_PORT_0,hr,5);//开关绑定模式 
   2047          #endif
   2048          #if(SENSOR_TYPE ==0X7B)
   2049               Send_datalend=6;
   2050              GenericApp_SendTheMessage();
   2051          #endif
   2052          #if(SENSOR_TYPE ==0X71)
   2053                uint8  hr[6]={0XF7, 0X03,0XBB,0X65,0X40, 0X01,};
   2054               Send_datalend=2;
   2055              GenericApp_SendTheMessage();
   2056              HalUARTWrite(HAL_UART_PORT_0,&hr[5],1);halMcuWaitMs(100);
   2057              HalUARTWrite(HAL_UART_PORT_0,hr,5);
   2058          #endif
   2059          #if(SENSOR_TYPE ==0X70)
   2060                uint8  hr[11]={0XF7,0x09,0x01,0X01,0XC0,0X10,0X10,0X40,0X06,0X06,0X20};
   2061               Send_datalend=2;
   2062             GenericApp_SendTheMessage();
   2063               P1_0=1; 
   2064               GenericApp_uart_485=0;
   2065               HalUARTWrite(HAL_UART_PORT_0,hr,11);
   2066          #endif
   2067          #if(SENSOR_TYPE ==0X86)
   2068               // uint8  hr[9]={0XF7,0x07,0xBA,0X01,0X01,0XA0,0X00,0X00,0X00};
   2069               Send_datalend=2;
   2070               GenericApp_SendTheMessage();
   2071             //  HalUARTWrite(HAL_UART_PORT_0,hr,9);//智能语言播报
   2072          #endif
   2073          #if(SENSOR_TYPE ==0X87)
   2074               // uint8  hr[9]={0XF7,0x07,0xBA,0X01,0X01,0XA0,0X00,0X00,0X00};
   2075               Send_datalend=2;
   2076               GenericApp_SendTheMessage();
   2077             //  HalUARTWrite(HAL_UART_PORT_0,hr,9);//智能语言播报
   2078          #endif
   2079          #if(SENSOR_TYPE ==0X26)
   2080                uint8  hr[9]={0XF7,0x07,0xBA,0X01,0X01,0XA0,0X00,0X00,0X00};
   2081               Send_datalend=2;
   2082               GenericApp_SendTheMessage();
   2083               HalUARTWrite(HAL_UART_PORT_0,hr,9);//智能语言播报
   2084          #endif
   2085           #if(SENSOR_TYPE ==0X27)
   2086                SYN_FrameInfo(0,1,"soundy",250) ;
   2087          #endif
   2088                
   2089          #if(SENSOR_TYPE ==0X28)
   2090                 LCD_Init();   // LCD初始化
   2091            LCD_Clear();  // LCD清屏
   2092            /* 显示信息 */
   2093            LCD_WriteString(0,0,"WWW.fantaitech.com");
   2094                GenericApp_switch=0;
   2095                 GenericApp_SendTheMessage();
   2096          #endif
   2097            #if(SENSOR_TYPE ==0X6F)
   2098                SYN_FrameInfo(0,1,"soundy",250) ;
   2099                   lcd_txt_clr(); 
   2100                hzkdis_b(0,"  无锡泛太科技",14);
   2101                GenericApp_switch=0;
   2102                 GenericApp_SendTheMessage();
   2103          #endif
   2104          #if(SENSOR_TYPE ==0X6B)
   2105          #if defined(LED16X64)
   2106                uint8  hr[4]={0X02,0x33,0x01,0X00};
   2107               HalUARTWrite(HAL_UART_PORT_0,hr,4);
   2108          #endif
   2109              GenericApp_applicationbuf=0;
   2110              GenericApp_SendTheMessage();
   2111          #endif
   2112          #if((SENSOR_TYPE ==0X05)||(SENSOR_TYPE ==0X0A)||(SENSOR_TYPE ==0X0B)||\
   2113               (SENSOR_TYPE =='R')||(SENSOR_TYPE =='S')||(SENSOR_TYPE =='H')||(SENSOR_TYPE ==0X65)\
   2114                 ||(SENSOR_TYPE ==0X66)||(SENSOR_TYPE ==0X67)||(SENSOR_TYPE ==0X76))
   2115                 GenericApp_SendTheMessage();
   2116          #endif
   2117          #if(SENSOR_TYPE ==0X6E)
   2118                uint8 spt[2]={0,0};
   2119               SendDataS(spt,2);
   2120              GenericApp_SendTheMessage();
   2121          #endif
   2122          #if(SENSOR_TYPE ==0X6C)
   2123                   lcd_txt_clr(); 
   2124            hzkdis(2,tab0);
   2125                 GenericApp_SendTheMessage();
   2126          #endif
   2127          
   2128          #if(SENSOR_TYPE ==0X6D)
   2129              GenericApp_applicationbuf=0;
   2130              GenericApp_SendTheMessage();
   2131          #endif
   2132          #if(SENSOR_TYPE ==0XF0)
   2133              GenericApp_applicationbuf=0;
   2134              GenericApp_SendTheMessage();
   2135          #endif
   2136          #if(SENSOR_TYPE ==0X30)
   2137                 if(a68!=0Xba){a68=0xba;b68=B01;c68=150;}
   2138                 else {a68=0xab;b68=B01;c68=0;}
   2139                 GenericApp_SendTheMessage();
   2140          #endif
   2141          #if(SENSOR_TYPE ==0X73)
   2142              if(a68!=0Xba){a68=0xba;b68=5000;}
   2143                 else {a68=0xab;b68=5000;}
   2144              Send_data[10]=0X00;
   2145              uint8 data8[6]={0X05,0XA8,0X01,0XA0,0X10,0X00};
   2146               if(A8n<8)A8n++;
   2147                else A8n=1;
   2148              data8[2]=A8n;
   2149                  HalUARTWrite(HAL_UART_PORT_0, data8,0X06);
   2150                 GenericApp_SendTheMessage();
   2151          #endif
   2152          #if(SENSOR_TYPE ==0X23)
   2153             
   2154              if(SFG_R30X)
   2155              {SFG_R30XA[0]=0X00;SFG_R30X=0;}
   2156              else
   2157              { SFG_R30XA[0]=0XA1;SFG_R30X=1;}
   2158              
   2159               GenericApp_applicationbuf=0;
   2160               GenericApp_SendTheMessage();
   2161          #endif
   2162          #if(SENSOR_TYPE ==0X20)
   2163                 GenericApp_ON_OFF=10;
   2164          #endif
   2165          #if(SENSOR_TYPE ==0X77)
   2166                GenericApp_appIO=0x00;
   2167                 GenericApp_SendTheMessage(); //应用函数
   2168          #endif
   2169          #if((SENSOR_TYPE =='I')||(SENSOR_TYPE ==0X64))
   2170                GenericApp_appIO=0x01;
   2171          #endif
   2172          #if((SENSOR_TYPE =='E')||(SENSOR_TYPE =='B')||(SENSOR_TYPE =='C')||(SENSOR_TYPE =='D')\
   2173            ||(SENSOR_TYPE =='F')||(SENSOR_TYPE =='U')||(SENSOR_TYPE ==0X10)||(SENSOR_TYPE ==0X21)\
   2174              ||(SENSOR_TYPE ==0X11)||(SENSOR_TYPE ==0X1A)||(SENSOR_TYPE ==0X0F)||(SENSOR_TYPE ==0X13)||(SENSOR_TYPE ==0X14)\
   2175                ||(SENSOR_TYPE ==0X17)||(SENSOR_TYPE ==0X24)||(SENSOR_TYPE ==0X6A)||(SENSOR_TYPE =='A')\
   2176                  ||(SENSOR_TYPE =='J')||(SENSOR_TYPE =='L')||(SENSOR_TYPE =='M')\
   2177            ||(SENSOR_TYPE =='N')||(SENSOR_TYPE ==0X04)||(SENSOR_TYPE ==0X22)||(SENSOR_TYPE ==0X0C)\
   2178              ||(SENSOR_TYPE ==0X16)||(SENSOR_TYPE ==0X17)||(SENSOR_TYPE ==0X61)||(SENSOR_TYPE ==0X62)\
   2179                ||(SENSOR_TYPE ==0X19)||(SENSOR_TYPE ==0X5A)||(SENSOR_TYPE ==0X5B)||(SENSOR_TYPE ==0X63)||(SENSOR_TYPE ==0X33)||(SENSOR_TYPE ==0X72)\
   2180                   ||(SENSOR_TYPE ==0X34)||(SENSOR_TYPE ==0X35)||(SENSOR_TYPE ==0X36)||(SENSOR_TYPE ==0X37)||(SENSOR_TYPE ==0X38)\
   2181                     ||(SENSOR_TYPE ==0X39)||(SENSOR_TYPE ==0X3A)||(SENSOR_TYPE ==0X80)||(SENSOR_TYPE ==0X3D)||(SENSOR_TYPE ==0X81)\
   2182                       ||(SENSOR_TYPE ==0X82)||(SENSOR_TYPE ==0X3B)||(SENSOR_TYPE ==0X3C)||(SENSOR_TYPE ==0X3E)||(SENSOR_TYPE ==0X3F)\
   2183                         ||(SENSOR_TYPE ==0X74)||(SENSOR_TYPE ==0X84)||(SENSOR_TYPE ==0X85)||(SENSOR_TYPE ==0X75)||(SENSOR_TYPE ==0X78))
   2184                GenericApp_applicationbuf=60001; //单次发送 不改变定时状态
   2185               //  GenericApp_time=0;
   2186                // TIMER3_RUN(FALSE);  //关闭定时
   2187          if(!(T_MGSbit&(0XC0)))  //1100 0000 判断是否为 关闭定时状态
   2188          {
   2189                GenericApp_time=0;
   2190                 TIMER3_RUN(FALSE);  //关闭定时
   2191          }
   2192          #endif
   2193          #if(SENSOR_TYPE ==0X79)
   2194                    P1_5=~P1_5;
   2195                    Send_data[7]=0X02;
   2196                    Send_data[8]=0XDD;
   2197                    Send_data[9]=P1_5;
   2198                    Send_data[9]=~((((Send_data[9]<<1)+P1_0)&0X03)|0XFC);
   2199                    Send_datalend=0x04;
   2200                    GenericApp_SendTheMessage(); //应用函数
   2201          #endif  
   2202          #if(SENSOR_TYPE ==0X83)
   2203                 P1_1=~P1_1;
   2204                GenericApp_applicationbuf=0;
   2205                GenericApp_SendTheMessage();
   2206          #endif  
   2207          #if((SENSOR_TYPE =='K')||(SENSOR_TYPE ==0X02)||(SENSOR_TYPE ==0X06)||(SENSOR_TYPE ==0X40)\
   2208            ||(SENSOR_TYPE ==0X09)||(SENSOR_TYPE ==0X12)||(SENSOR_TYPE ==0X18)||(SENSOR_TYPE ==0X15)\
   2209              ||(SENSOR_TYPE ==0X29)||(SENSOR_TYPE ==0X31)||(SENSOR_TYPE ==0XA3))
   2210              //  P1_1=~P1_1;
   2211                GenericApp_applicationbuf=0;
   \   000014   12....       LCALL   ?Subroutine19 & 0xFFFF
   2212                GenericApp_SendTheMessage();
   2213          #endif
   2214           ////////////////////////////////////////////////////////////////////////////////////////////
   2215          //OLED屏显示内容
   2216          OLED_Init(); //OLED初始化 
   2217          OLED_P8x16Str(0,0,"R       ID:");//第一行 -- 8x16的显示单元显示ASCII码
   2218          #if defined( SENSOR_TYPE_Coord )
   2219          #if (ZDO_COORDINATOR)
   2220             OLED_P8x16Str(0,0,"C    PANID:");//第一行 -- 8x16的显示单元显示ASCII码
   2221          #endif 
   2222          #endif 
   2223          #if defined( POWER_SAVING )
   2224           OLED_P8x16Str(0,0,"E       ID:");//第一行 -- 8x16的显示单元显示ASCII码
   2225          #endif
   2226          char *s=0;
   2227          uint16 nv_data; 
   2228          osal_nv_read(ZCD_NV_APP_CHANLIST,0,sizeof(nv_data),&nv_data);
   \                     ??CrossCallReturnLabel_28:
   \   000017   8582..       MOV     ?V0 + 10,DPL
   \   00001A   8583..       MOV     ?V0 + 11,DPH
   \   00001D   78..         MOV     R0,#?V0 + 10
   \   00001F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000022   75..02       MOV     ?V0 + 10,#0x2
   \   000025   75..00       MOV     ?V0 + 11,#0x0
   \   000028   78..         MOV     R0,#?V0 + 10
   \   00002A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002D   7C00         MOV     R4,#0x0
   \   00002F   7D00         MOV     R5,#0x0
   \   000031   7A0F         MOV     R2,#0xf
   \   000033   12....       LCALL   ??Subroutine33_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000036   12....       LCALL   ?DEALLOC_XSTACK8
   2229          sprintf(s, "%02d", (nv_data&0x00ff)); 
   \   000039                ; Setup parameters for call to function sprintf
   \   000039   85..82       MOV     DPL,?XSP + 0
   \   00003C   85..83       MOV     DPH,?XSP + 1
   \   00003F   12....       LCALL   ??Subroutine44_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   000042   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000045   7C..         MOV     R4,#(`?<Constant "%02d">` & 0xff)
   \   000047   7D..         MOV     R5,#((`?<Constant "%02d">` >> 8) & 0xff)
   \   000049   12....       LCALL   ??Subroutine34_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   00004C   12....       LCALL   ?DEALLOC_XSTACK8
   2230          OLED_P8x16Str(16,0,s);//第一行 -- 8x16的显示单元显示ASCII码
   \   00004F                ; Setup parameters for call to function OLED_P8x16Str
   \   00004F   7C00         MOV     R4,#0x0
   \   000051   7D00         MOV     R5,#0x0
   \   000053   7A00         MOV     R2,#0x0
   \   000055   7910         MOV     R1,#0x10
   \   000057   12....       LCALL   ??OLED_P8x16Str?relay
   2231          #if !defined( SENSOR_TYPE_Coord )
   2232          sprintf(s, "%02X", SENSOR_TYPE); 
   \   00005A                ; Setup parameters for call to function sprintf
   \   00005A   75..31       MOV     ?V0 + 10,#0x31
   \   00005D   78..         MOV     R0,#?V0 + 10
   \   00005F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000062   7C..         MOV     R4,#(`?<Constant "%02X">` & 0xff)
   \   000064   7D..         MOV     R5,#((`?<Constant "%02X">` >> 8) & 0xff)
   \   000066   12....       LCALL   ??Subroutine34_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   000069   12....       LCALL   ?DEALLOC_XSTACK8
   2233          OLED_P8x16Str(40,0,s);//第一行 -- 8x16的显示单元显示ASCII码
   \   00006C                ; Setup parameters for call to function OLED_P8x16Str
   \   00006C   12....       LCALL   ?Subroutine27 & 0xFFFF
   2234          #endif 
   2235          osal_nv_read(ZCD_NV_APP_PANID_H,0,sizeof(nv_data),&nv_data);
   \                     ??CrossCallReturnLabel_48:
   \   00006F   8582..       MOV     ?V0 + 10,DPL
   \   000072   8583..       MOV     ?V0 + 11,DPH
   \   000075   78..         MOV     R0,#?V0 + 10
   \   000077   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007A   75..02       MOV     ?V0 + 10,#0x2
   \   00007D   75..00       MOV     ?V0 + 11,#0x0
   \   000080   78..         MOV     R0,#?V0 + 10
   \   000082   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000085   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   000088   12....       LCALL   ?DEALLOC_XSTACK8
   2236          sprintf(s, "%04X", nv_data); 
   \   00008B                ; Setup parameters for call to function sprintf
   \   00008B   85..82       MOV     DPL,?XSP + 0
   \   00008E   85..83       MOV     DPH,?XSP + 1
   \   000091   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000094   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   000097   12....       LCALL   ?DEALLOC_XSTACK8
   2237          OLED_P8x16Str(88,0,s);//第一行 -- 8x16的显示单元显示ASCII码
   \   00009A                ; Setup parameters for call to function OLED_P8x16Str
   \   00009A   12....       LCALL   ?Subroutine23 & 0xFFFF
   2238          OLED_P8x16Str(0,2,"V2.45");
   2239          #if defined( CC2530_V30 )
   2240          OLED_P8x16Str(0,2,"V3.00");
   2241          #endif
   2242          sprintf(s, "%04X", NLME_GetCoordShortAddr()); 
   \                     ??CrossCallReturnLabel_34:
   \   00009D   8A..         MOV     ?V0 + 10,R2
   \   00009F   8B..         MOV     ?V0 + 11,R3
   \   0000A1   78..         MOV     R0,#?V0 + 10
   \   0000A3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A6   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   0000A9   12....       LCALL   ?DEALLOC_XSTACK8
   2243          OLED_P8x16Str(48,2,s);
   \   0000AC                ; Setup parameters for call to function OLED_P8x16Str
   \   0000AC   12....       LCALL   ?Subroutine26 & 0xFFFF
   2244          sprintf(s, "%04X", NLME_GetShortAddr());
   \                     ??CrossCallReturnLabel_46:
   \   0000AF   8A..         MOV     ?V0 + 10,R2
   \   0000B1   8B..         MOV     ?V0 + 11,R3
   \   0000B3   78..         MOV     R0,#?V0 + 10
   \   0000B5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B8   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   0000BB   12....       LCALL   ?DEALLOC_XSTACK8
   2245          OLED_P8x16Str(88,2,s);
   \   0000BE                ; Setup parameters for call to function OLED_P8x16Str
   \   0000BE   12....       LCALL   ?Subroutine24 & 0xFFFF
   2246           byte * Send_d;
   2247            Send_d=NLME_GetExtAddr();
   2248          sprintf(s, "%02X%02X%02X%02X%02X%02X%02X%02X", *Send_d,*(Send_d+1),*(Send_d+2),*(Send_d+3),*(Send_d+4),*(Send_d+5),*(Send_d+6),*(Send_d+7));
   \                     ??CrossCallReturnLabel_36:
   \   0000C1   F5..         MOV     ?V0 + 10,A
   \   0000C3   75..00       MOV     ?V0 + 11,#0x0
   \   0000C6   78..         MOV     R0,#?V0 + 10
   \   0000C8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000CB   8A82         MOV     DPL,R2
   \   0000CD   8B83         MOV     DPH,R3
   \   0000CF   A3           INC     DPTR
   \   0000D0   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   0000D3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000D6   8A82         MOV     DPL,R2
   \   0000D8   8B83         MOV     DPH,R3
   \   0000DA   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   0000DD   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000E0   8A82         MOV     DPL,R2
   \   0000E2   8B83         MOV     DPH,R3
   \   0000E4   12....       LCALL   ??Subroutine40_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   0000E7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000EA   8A82         MOV     DPL,R2
   \   0000EC   8B83         MOV     DPH,R3
   \   0000EE   12....       LCALL   ??Subroutine41_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   0000F1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F4   8A82         MOV     DPL,R2
   \   0000F6   8B83         MOV     DPH,R3
   \   0000F8   12....       LCALL   ??Subroutine42_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   0000FB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000FE   8A82         MOV     DPL,R2
   \   000100   8B83         MOV     DPH,R3
   \   000102   12....       LCALL   ??Subroutine43_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000105   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000108   8A82         MOV     DPL,R2
   \   00010A   8B83         MOV     DPH,R3
   \   00010C   12....       LCALL   ??Subroutine44_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   00010F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000112   7C..         MOV     R4,#(`?<Constant "%02X%02X%02X%02X%02X%...">` & 0xff)
   \   000114   7D..         MOV     R5,#((`?<Constant "%02X%02X%02X%02X%02X%...">` >> 8) & 0xff)
   \   000116   7A00         MOV     R2,#0x0
   \   000118   7B00         MOV     R3,#0x0
   \   00011A   12....       LCALL   ??sprintf?relay
   \   00011D   7410         MOV     A,#0x10
   \   00011F   12....       LCALL   ?DEALLOC_XSTACK8
   2249          OLED_P8x16Str(0,4,s);
   \   000122                ; Setup parameters for call to function OLED_P8x16Str
   \   000122   7C00         MOV     R4,#0x0
   \   000124   7D00         MOV     R5,#0x0
   \   000126   7A04         MOV     R2,#0x4
   \   000128   7900         MOV     R1,#0x0
   \   00012A   12....       LCALL   ??OLED_P8x16Str?relay
   2250           /////////////////////////////////////////////////////////////////////////////////   
   2251          
   2252          #if !defined (SENSOR_TYPE_Coord)
   2253          #if((SENSOR_TYPE =='K')||(SENSOR_TYPE ==0X28))
   2254          ZigBee_C_R_E_Engineering_E();
   2255          #endif
   2256          #endif
   2257            }
   2258              if ( keys & HAL_KEY_SW_2 )
   \                     ??GenericApp_HandleKeys_0:
   \   00012D   E5..         MOV     A,?V0 + 0
   \   00012F   A2E1         MOV     C,0xE0 /* A   */.1
   \   000131   4003         JC      $+5
   \   000133   02....       LJMP    ??GenericApp_HandleKeys_1 & 0xFFFF
   2259              {
   2260          #if(SENSOR_TYPE =='O')
   2261                char hr[5]={0xCE,0x03,0xFC,0x00,0xDE};
   2262                hr[3]=0XAA;
   2263                HalUARTWrite(HAL_UART_PORT_0, (uint8*)hr,5);
   2264                GenericApp_SendTheMessage();
   2265          #endif 
   2266          #if(SENSOR_TYPE =='G')
   2267          if(Coil_AB==0)Coil_AB=1;
   2268          else if(Coil_AB<5)Coil_AB=10;
   2269          else Coil_AB=0;
   2270          #endif 
   2271          #if((SENSOR_TYPE ==0X03)||(SENSOR_TYPE ==0X17))
   2272               GenericApp_SendTheMessage();
   2273          #endif 
   2274          #if(SENSOR_TYPE ==0X07)
   2275           //    if(AB==0X0A)AB=0X0B;
   2276           //    else AB=0X0A;
   2277               Send_datalend=0X04;
   2278          GenericApp_SendTheMessage();
   2279          #endif 
   2280          #if(SENSOR_TYPE ==0X08)
   2281               if(GenericApp_BX)
   2282              { GenericApp_BX=0; 
   2283              Send_data[7]=0xA1;//读卡  15693
   2284               //printf("010C00030410002101020000\n"); //设置 15693卡
   2285              GenericApp_appIO=0;
   2286              }
   2287              else
   2288              {GenericApp_BX=1;
   2289               Send_data[7]=0xA2; //读卡 14443A
   2290             // printf("010C00030410002101020000\n"); //设置 15693卡
   2291               GenericApp_appIO=0;
   2292              }
   2293          #endif 
   2294          #if(SENSOR_TYPE ==0X0D)
   2295          #if defined(TGRD15693) 
   2296               if(GenericApp_BX)
   2297              { GenericApp_BX=0; 
   2298              Send_data[7]=0xA1;//读卡  15693
   2299               //printf("010C00030410002101020000\n"); //设置 15693卡
   2300              GenericApp_appIO=0;
   2301              }
   2302              else
   2303              {GenericApp_BX=1;
   2304               Send_data[7]=0xA2; //读卡 14443A
   2305             // printf("010C00030410002101020000\n"); //设置 15693卡
   2306               GenericApp_appIO=0;
   2307              }
   2308          #endif 
   2309          #if defined(PN532) 
   2310             
   2311          #endif 
   2312          #endif 
   2313          #if((SENSOR_TYPE =='R')||(SENSOR_TYPE =='S')||(SENSOR_TYPE =='H')||(SENSOR_TYPE ==0X65)||(SENSOR_TYPE ==0X66)||\
   2314            (SENSOR_TYPE ==0X67)||(SENSOR_TYPE ==0X05)||(SENSOR_TYPE ==0X0A)||(SENSOR_TYPE ==0X0B)\
   2315             ||(SENSOR_TYPE ==0X76) )
   2316                GenericApp_SendTheMessage();
   2317          #endif
   2318          #if(SENSOR_TYPE ==0X6E)
   2319                uint8 spt[2]={0XFF,0XFF};
   2320               SendDataS(spt,2);
   2321              GenericApp_SendTheMessage();
   2322          #endif
   2323          #if(SENSOR_TYPE ==0X6C)
   2324                  lcd_txt_clr(); 
   2325            hzkdis(1,tab0);
   2326                 GenericApp_SendTheMessage();
   2327          #endif
   2328          
   2329          #if(SENSOR_TYPE ==0X6D)
   2330              GenericApp_applicationbuf=0;
   2331              GenericApp_SendTheMessage();
   2332          #endif
   2333          #if(SENSOR_TYPE ==0XF0)
   2334              GenericApp_applicationbuf=0;
   2335              GenericApp_SendTheMessage();
   2336          #endif
   2337          #if(SENSOR_TYPE =='P')
   2338                uint8  hrx[8]={0X01,0x03,0x06,0X81,0X00,0X8a,0X0D,0X0A};
   2339               GenericApp_applicationbuf=0;
   2340                 GenericApp_SendTheMessage();
   2341                HalUARTWrite(HAL_UART_PORT_0,hrx,8);//发送
   2342                // GenericApp_SendTheMessage();
   2343          #endif 
   2344          #if(SENSOR_TYPE ==0X25)
   2345              Send_datalend=2;
   2346              GenericApp_SendTheMessage();
   2347          #endif 
   2348          #if(SENSOR_TYPE ==0X7C)
   2349              Send_datalend=2;
   2350              GenericApp_SendTheMessage();
   2351          #endif 
   2352          #if(SENSOR_TYPE ==0X7B)
   2353              Send_datalend=6;
   2354              GenericApp_SendTheMessage();
   2355          #endif 
   2356          #if(SENSOR_TYPE ==0X71)
   2357              uint8  hr[6]={0XF7, 0X03,0XBB,0X65,0X60, 0X01,};
   2358              Send_datalend=2;
   2359                HalUARTWrite(HAL_UART_PORT_0,hr,5);
   2360              GenericApp_SendTheMessage();
   2361          #endif 
   2362          #if(SENSOR_TYPE ==0X70)
   2363                uint8  hr[11]={0XF7,0x09,0x01,0X01,0XA0,0X10,0X10,0X40,0X06,0X06,0X20};
   2364               Send_datalend=2;
   2365              GenericApp_SendTheMessage();
   2366               P1_0=1; 
   2367               GenericApp_uart_485=0;
   2368               HalUARTWrite(HAL_UART_PORT_0,hr,11);
   2369          #endif 
   2370          #if(SENSOR_TYPE ==0X73)
   2371               if(a68!=0Xba){a68=0xba;b68=5000;}
   2372                 else {a68=0xab;b68=5000;}
   2373               Send_data[10]=0X00;
   2374                uint8 data8[6]={0X05,0XA8,0X01,0XA0,0X10,0X00};
   2375               if(A8n>1)A8n--;
   2376                else A8n=8;
   2377              data8[2]=A8n;
   2378                  HalUARTWrite(HAL_UART_PORT_0, data8,0X06);
   2379                 GenericApp_SendTheMessage();
   2380          #endif
   2381           #if(SENSOR_TYPE ==0X86)
   2382              Send_datalend=2;
   2383              GenericApp_SendTheMessage();
   2384          #endif 
   2385          #if(SENSOR_TYPE ==0X87)
   2386              Send_datalend=2;
   2387              GenericApp_SendTheMessage();
   2388          #endif 
   2389          #if(SENSOR_TYPE ==0X26)
   2390              Send_datalend=2;
   2391              GenericApp_SendTheMessage();
   2392          #endif 
   2393          #if(SENSOR_TYPE ==0X27)
   2394               SYN_FrameInfo(0,1,"soundy",250) ;
   2395              
   2396          #endif 
   2397               
   2398          #if(SENSOR_TYPE ==0X28)
   2399                LCD_Init();   // LCD初始化
   2400            LCD_Clear();  // LCD清屏
   2401            /* 显示信息 */
   2402            LCD_WriteString(0,2,"   WUXIFANTAIKEJI");
   2403                  GenericApp_switch=0;
   2404                 GenericApp_SendTheMessage();
   2405          #endif
   2406          
   2407          #if(SENSOR_TYPE ==0X6F)
   2408                SYN_FrameInfo(0,1,"soundy",250) ;
   2409                 // lcd_txt_clr(); 
   2410                hzkdis_b(1,"  公交管理系统",14);
   2411                  GenericApp_switch=0;
   2412                 GenericApp_SendTheMessage();
   2413          #endif
   2414          #if(SENSOR_TYPE ==0X6B)
   2415          #if defined(LED16X64)
   2416                uint8  hr[4]={0X02,0x33,0x02,0X00};
   2417               HalUARTWrite(HAL_UART_PORT_0,hr,4);
   2418          #endif
   2419               GenericApp_applicationbuf=0;
   2420                 GenericApp_SendTheMessage();
   2421          #endif 
   2422          #if(SENSOR_TYPE ==0X77)
   2423                GenericApp_appIO=0x00;
   2424                 GenericApp_SendTheMessage(); //应用函数
   2425          #endif
   2426          #if((SENSOR_TYPE =='I')||(SENSOR_TYPE ==0X64))
   2427                GenericApp_appIO=0x02;
   2428          #endif
   2429          #if((SENSOR_TYPE =='E')||(SENSOR_TYPE =='B')||(SENSOR_TYPE =='C')||(SENSOR_TYPE =='D')\
   2430            ||(SENSOR_TYPE =='F')||(SENSOR_TYPE =='U')||(SENSOR_TYPE ==0X10)||(SENSOR_TYPE ==0X21)\
   2431              ||(SENSOR_TYPE ==0X11)||(SENSOR_TYPE ==0X1A)||(SENSOR_TYPE ==0X0F)||(SENSOR_TYPE ==0X13)||(SENSOR_TYPE ==0X14)\
   2432                ||(SENSOR_TYPE ==0X24)||(SENSOR_TYPE ==0X6A)||(SENSOR_TYPE =='A')||(SENSOR_TYPE =='J')||\
   2433                  (SENSOR_TYPE =='L')||(SENSOR_TYPE =='M')||(SENSOR_TYPE ==0X33)\
   2434            ||(SENSOR_TYPE =='N')||(SENSOR_TYPE ==0X04)||(SENSOR_TYPE ==0X22)||(SENSOR_TYPE ==0X0C)\
   2435              ||(SENSOR_TYPE ==0X16)||(SENSOR_TYPE ==0X19)||(SENSOR_TYPE ==0X61)||(SENSOR_TYPE ==0X62)||(SENSOR_TYPE ==0X63)\
   2436                ||(SENSOR_TYPE ==0X5A)||(SENSOR_TYPE ==0X5B)||(SENSOR_TYPE ==0X72) ||(SENSOR_TYPE ==0X34)||(SENSOR_TYPE ==0X35)||(SENSOR_TYPE ==0X36)\
   2437                  ||(SENSOR_TYPE ==0X37)||(SENSOR_TYPE ==0X38)||(SENSOR_TYPE ==0X39)||(SENSOR_TYPE ==0X3A)||(SENSOR_TYPE ==0X80)\
   2438                    ||(SENSOR_TYPE ==0X3D)||(SENSOR_TYPE ==0X81)||(SENSOR_TYPE ==0X82)||(SENSOR_TYPE ==0X3B)||(SENSOR_TYPE ==0X3C)\
   2439                      ||(SENSOR_TYPE ==0X3E)||(SENSOR_TYPE ==0X3F)||(SENSOR_TYPE ==0X74)||(SENSOR_TYPE ==0X84)||(SENSOR_TYPE ==0X85)\
   2440                       ||(SENSOR_TYPE ==0X75)||(SENSOR_TYPE ==0X78) )
   2441                GenericApp_applicationbuf=60001;
   2442          if(!(T_MGSbit&(0XC0)))  //1100 0000 判断是否为 关闭定时状态
   2443          {
   2444                GenericApp_time=1;
   2445          #if defined( POWER_SAVING )
   2446                GenericApp_time=25;
   2447          #endif
   2448          }
   2449          #endif
   2450          #if(SENSOR_TYPE ==0X23)
   2451               if(SFG_R30X)
   2452              {SFG_R30XA[0]=0X00;SFG_R30X=0;}
   2453              else
   2454              { SFG_R30XA[0]=0XA1;SFG_R30X=1;}
   2455              
   2456              GenericApp_applicationbuf=0;
   2457             GenericApp_SendTheMessage();
   2458          #endif
   2459          #if(SENSOR_TYPE ==0X20)
   2460                 GenericApp_ON_OFF=10;
   2461          #endif
   2462          #if(SENSOR_TYPE ==0X79)
   2463                 P1_0=~P1_0; //P1_5=~P1_5;
   2464                Send_data[7]=0X02;
   2465                    Send_data[8]=0XDD;
   2466                    Send_data[9]=P1_5;
   2467                     Send_data[9]=~((((Send_data[9]<<1)+P1_0)&0X03)|0XFC);
   2468                    Send_datalend=0x04;
   2469                    GenericApp_SendTheMessage(); //应用函数
   2470          #endif  
   2471          #if(SENSOR_TYPE ==0X83)
   2472                P1_2=~P1_2; //P1_0=~P1_0;
   2473                GenericApp_applicationbuf=0;
   2474                GenericApp_SendTheMessage();
   2475          #endif  
   2476          #if((SENSOR_TYPE =='K')||(SENSOR_TYPE ==0X02)||(SENSOR_TYPE ==0X06)||(SENSOR_TYPE ==0X40)||\
   2477            (SENSOR_TYPE ==0X09)||(SENSOR_TYPE ==0X12)||(SENSOR_TYPE ==0X18)||(SENSOR_TYPE ==0X15)\
   2478               ||(SENSOR_TYPE ==0X29)||(SENSOR_TYPE ==0X31)||(SENSOR_TYPE ==0XA3))
   2479               // P1_2=~P1_2; //P1_0=~P1_0;
   2480                GenericApp_applicationbuf=0;
   \   000136   12....       LCALL   ?Subroutine19 & 0xFFFF
   2481                GenericApp_SendTheMessage();
   2482          #endif
   2483          ////////////////////////////////////////////////////////////////////////////////////////////
   2484          //OLED屏显示内容
   2485          OLED_Init(); //OLED初始化 
   2486          OLED_P8x16Str(0,0,"R       ID:");//第一行 -- 8x16的显示单元显示ASCII码
   2487          #if defined( SENSOR_TYPE_Coord )
   2488          #if (ZDO_COORDINATOR)
   2489             OLED_P8x16Str(0,0,"C    PANID:");//第一行 -- 8x16的显示单元显示ASCII码
   2490          #endif 
   2491          #endif 
   2492          #if defined( POWER_SAVING )
   2493           OLED_P8x16Str(0,0,"E       ID:");//第一行 -- 8x16的显示单元显示ASCII码
   2494          #endif
   2495          char *s=0;
   2496          uint16 nv_data; 
   2497          osal_nv_read(ZCD_NV_APP_CHANLIST,0,sizeof(nv_data),&nv_data);
   \                     ??CrossCallReturnLabel_29:
   \   000139   8582..       MOV     ?V0 + 2,DPL
   \   00013C   8583..       MOV     ?V0 + 3,DPH
   \   00013F   78..         MOV     R0,#?V0 + 2
   \   000141   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000144   75..02       MOV     ?V0 + 2,#0x2
   \   000147   75..00       MOV     ?V0 + 3,#0x0
   \   00014A   78..         MOV     R0,#?V0 + 2
   \   00014C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00014F   7C00         MOV     R4,#0x0
   \   000151   7D00         MOV     R5,#0x0
   \   000153   7A0F         MOV     R2,#0xf
   \   000155   12....       LCALL   ??Subroutine33_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000158   12....       LCALL   ?DEALLOC_XSTACK8
   2498          sprintf(s, "%02d", (nv_data&0x00ff)); 
   \   00015B                ; Setup parameters for call to function sprintf
   \   00015B   85..82       MOV     DPL,?XSP + 0
   \   00015E   85..83       MOV     DPH,?XSP + 1
   \   000161   12....       LCALL   ??Subroutine39_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   000164   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000167   7C..         MOV     R4,#(`?<Constant "%02d">` & 0xff)
   \   000169   7D..         MOV     R5,#((`?<Constant "%02d">` >> 8) & 0xff)
   \   00016B   12....       LCALL   ??Subroutine34_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   00016E   12....       LCALL   ?DEALLOC_XSTACK8
   2499          OLED_P8x16Str(16,0,s);//第一行 -- 8x16的显示单元显示ASCII码
   \   000171                ; Setup parameters for call to function OLED_P8x16Str
   \   000171   7C00         MOV     R4,#0x0
   \   000173   7D00         MOV     R5,#0x0
   \   000175   7A00         MOV     R2,#0x0
   \   000177   7910         MOV     R1,#0x10
   \   000179   12....       LCALL   ??OLED_P8x16Str?relay
   2500          #if !defined( SENSOR_TYPE_Coord )
   2501          sprintf(s, "%02X", SENSOR_TYPE); 
   \   00017C                ; Setup parameters for call to function sprintf
   \   00017C   75..31       MOV     ?V0 + 2,#0x31
   \   00017F   78..         MOV     R0,#?V0 + 2
   \   000181   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000184   7C..         MOV     R4,#(`?<Constant "%02X">` & 0xff)
   \   000186   7D..         MOV     R5,#((`?<Constant "%02X">` >> 8) & 0xff)
   \   000188   12....       LCALL   ??Subroutine34_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   00018B   12....       LCALL   ?DEALLOC_XSTACK8
   2502          OLED_P8x16Str(40,0,s);//第一行 -- 8x16的显示单元显示ASCII码
   \   00018E                ; Setup parameters for call to function OLED_P8x16Str
   \   00018E   12....       LCALL   ?Subroutine27 & 0xFFFF
   2503          #endif 
   2504          osal_nv_read(ZCD_NV_APP_PANID_H,0,sizeof(nv_data),&nv_data);
   \                     ??CrossCallReturnLabel_49:
   \   000191   8582..       MOV     ?V0 + 2,DPL
   \   000194   8583..       MOV     ?V0 + 3,DPH
   \   000197   78..         MOV     R0,#?V0 + 2
   \   000199   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00019C   75..02       MOV     ?V0 + 2,#0x2
   \   00019F   75..00       MOV     ?V0 + 3,#0x0
   \   0001A2   78..         MOV     R0,#?V0 + 2
   \   0001A4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001A7   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   0001AA   12....       LCALL   ?DEALLOC_XSTACK8
   2505          sprintf(s, "%04X", nv_data); 
   \   0001AD                ; Setup parameters for call to function sprintf
   \   0001AD   85..82       MOV     DPL,?XSP + 0
   \   0001B0   85..83       MOV     DPH,?XSP + 1
   \   0001B3   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0001B6   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   0001B9   12....       LCALL   ?DEALLOC_XSTACK8
   2506          OLED_P8x16Str(88,0,s);//第一行 -- 8x16的显示单元显示ASCII码
   \   0001BC                ; Setup parameters for call to function OLED_P8x16Str
   \   0001BC   12....       LCALL   ?Subroutine23 & 0xFFFF
   2507          OLED_P8x16Str(0,2,"V2.45");
   2508          #if defined( CC2530_V30 )
   2509          OLED_P8x16Str(0,2,"V3.00");
   2510          #endif
   2511          sprintf(s, "%04X", NLME_GetCoordShortAddr()); 
   \                     ??CrossCallReturnLabel_35:
   \   0001BF   8A..         MOV     ?V0 + 2,R2
   \   0001C1   8B..         MOV     ?V0 + 3,R3
   \   0001C3   78..         MOV     R0,#?V0 + 2
   \   0001C5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001C8   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   0001CB   12....       LCALL   ?DEALLOC_XSTACK8
   2512          OLED_P8x16Str(48,2,s);
   \   0001CE                ; Setup parameters for call to function OLED_P8x16Str
   \   0001CE   12....       LCALL   ?Subroutine26 & 0xFFFF
   2513          sprintf(s, "%04X", NLME_GetShortAddr());
   \                     ??CrossCallReturnLabel_47:
   \   0001D1   8A..         MOV     ?V0 + 2,R2
   \   0001D3   8B..         MOV     ?V0 + 3,R3
   \   0001D5   78..         MOV     R0,#?V0 + 2
   \   0001D7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001DA   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   0001DD   12....       LCALL   ?DEALLOC_XSTACK8
   2514          OLED_P8x16Str(88,2,s);
   \   0001E0                ; Setup parameters for call to function OLED_P8x16Str
   \   0001E0   12....       LCALL   ?Subroutine24 & 0xFFFF
   2515           byte * Send_d;
   2516            Send_d=NLME_GetExtAddr();
   2517          sprintf(s, "%02X%02X%02X%02X%02X%02X%02X%02X", *Send_d,*(Send_d+1),*(Send_d+2),*(Send_d+3),*(Send_d+4),*(Send_d+5),*(Send_d+6),*(Send_d+7));
   \                     ??CrossCallReturnLabel_37:
   \   0001E3   F5..         MOV     ?V0 + 2,A
   \   0001E5   75..00       MOV     ?V0 + 3,#0x0
   \   0001E8   78..         MOV     R0,#?V0 + 2
   \   0001EA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001ED   8A82         MOV     DPL,R2
   \   0001EF   8B83         MOV     DPH,R3
   \   0001F1   A3           INC     DPTR
   \   0001F2   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   0001F5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001F8   8A82         MOV     DPL,R2
   \   0001FA   8B83         MOV     DPH,R3
   \   0001FC   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   0001FF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000202   8A82         MOV     DPL,R2
   \   000204   8B83         MOV     DPH,R3
   \   000206   12....       LCALL   ??Subroutine35_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   000209   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00020C   8A82         MOV     DPL,R2
   \   00020E   8B83         MOV     DPH,R3
   \   000210   12....       LCALL   ??Subroutine36_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   000213   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000216   8A82         MOV     DPL,R2
   \   000218   8B83         MOV     DPH,R3
   \   00021A   12....       LCALL   ??Subroutine37_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   00021D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000220   8A82         MOV     DPL,R2
   \   000222   8B83         MOV     DPH,R3
   \   000224   12....       LCALL   ??Subroutine38_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   000227   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00022A   8A82         MOV     DPL,R2
   \   00022C   8B83         MOV     DPH,R3
   \   00022E   12....       LCALL   ??Subroutine39_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   000231   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000234   7C..         MOV     R4,#(`?<Constant "%02X%02X%02X%02X%02X%...">` & 0xff)
   \   000236   7D..         MOV     R5,#((`?<Constant "%02X%02X%02X%02X%02X%...">` >> 8) & 0xff)
   \   000238   7A00         MOV     R2,#0x0
   \   00023A   7B00         MOV     R3,#0x0
   \   00023C   12....       LCALL   ??sprintf?relay
   \   00023F   7410         MOV     A,#0x10
   \   000241   12....       LCALL   ?DEALLOC_XSTACK8
   2518          OLED_P8x16Str(0,4,s);
   \   000244                ; Setup parameters for call to function OLED_P8x16Str
   \   000244   7C00         MOV     R4,#0x0
   \   000246   7D00         MOV     R5,#0x0
   \   000248   7A04         MOV     R2,#0x4
   \   00024A   7900         MOV     R1,#0x0
   \   00024C   12....       LCALL   ??OLED_P8x16Str?relay
   2519           //////////////////////////////////////////////////////////////////////////////////////////// 
   2520                
   2521          #if !defined (SENSOR_TYPE_Coord)
   2522              ZigBee_C_R_E_Engineering_F();
   \   00024F                ; Setup parameters for call to function ZigBee_C_R_E_Engineering_F
   \   00024F   12....       LCALL   ??ZigBee_C_R_E_Engineering_F?relay
   2523          #endif
   2524              }
   2525            }
   2526            else
   2527            {
   2528              if ( keys & HAL_KEY_SW_1 )
   2529              {
   2530                //HalLedSet ( HAL_LED_2, HAL_LED_MODE_ON );
   2531          
   2532                // Initiate an End Device Bind Request for the mandatory endpoint
   2533                dstAddr.addrMode = Addr16Bit;
   2534                dstAddr.addr.shortAddr = 0x0000; // Coordinator
   2535                ZDP_EndDeviceBindReq( &dstAddr, NLME_GetShortAddr(), 
   2536                                      GenericApp_epDesc.endPoint,
   2537                                      GENERICAPP_PROFID,
   2538                                      GENERICAPP_MAX_CLUSTERS, (cId_t *)GenericApp_ClusterList,
   2539                                      GENERICAPP_MAX_CLUSTERS, (cId_t *)GenericApp_ClusterList,
   2540                                      FALSE );
   2541              }
   2542          
   2543              if ( keys & HAL_KEY_SW_2 )
   2544              {
   2545                // Initiate a Match Description Request (Service Discovery)
   2546                dstAddr.addrMode = AddrBroadcast;
   2547                dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR;
   2548                ZDP_MatchDescReq( &dstAddr, NWK_BROADCAST_SHORTADDR,
   2549                                  GENERICAPP_PROFID,
   2550                                  GENERICAPP_MAX_CLUSTERS, (cId_t *)GenericApp_ClusterList,
   2551                                  GENERICAPP_MAX_CLUSTERS, (cId_t *)GenericApp_ClusterList,
   2552                                  FALSE );
   2553              }
   2554            }
   2555          }
   \                     ??GenericApp_HandleKeys_1:
   \   000252   7402         MOV     A,#0x2
   \   000254   12....       LCALL   ?DEALLOC_XSTACK8
   \   000257   7F0E         MOV     R7,#0xe
   \   000259   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   7C00         MOV     R4,#0x0
   \   000002   7D00         MOV     R5,#0x0
   \   000004   7A00         MOV     R2,#0x0
   \   000006   7928         MOV     R1,#0x28
   \   000008   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   7C00         MOV     R4,#0x0
   \   000002   7D00         MOV     R5,#0x0
   \   000004   7A02         MOV     R2,#0x2
   \   000006   7958         MOV     R1,#0x58
   \   000008   12....       LCALL   ??OLED_P8x16Str?relay
   \   00000B                ; Setup parameters for call to function NLME_GetExtAddr
   \   00000B                ; Setup parameters for call to function NLME_GetExtAddr
   \   00000B   12....       LCALL   ??NLME_GetExtAddr?relay
   \   00000E                ; Setup parameters for call to function sprintf
   \   00000E                ; Setup parameters for call to function sprintf
   \   00000E   8A82         MOV     DPL,R2
   \   000010   8B83         MOV     DPH,R3
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   7C00         MOV     R4,#0x0
   \   000002   7D00         MOV     R5,#0x0
   \   000004   7A00         MOV     R2,#0x0
   \   000006   7958         MOV     R1,#0x58
   \   000008   12....       LCALL   ??OLED_P8x16Str?relay
   \   00000B                ; Setup parameters for call to function OLED_P8x16Str
   \   00000B                ; Setup parameters for call to function OLED_P8x16Str
   \   00000B   7C..         MOV     R4,#(`?<Constant "V2.45">` & 0xff)
   \   00000D   7D..         MOV     R5,#((`?<Constant "V2.45">` >> 8) & 0xff)
   \   00000F   7A02         MOV     R2,#0x2
   \   000011   7900         MOV     R1,#0x0
   \   000013   12....       LCALL   ??OLED_P8x16Str?relay
   \   000016                ; Setup parameters for call to function sprintf
   \   000016                ; Setup parameters for call to function NLME_GetCoordShortAddr
   \   000016                ; Setup parameters for call to function sprintf
   \   000016                ; Setup parameters for call to function NLME_GetCoordShortAddr
   \   000016   12....       LCALL   ??NLME_GetCoordShortAddr?relay
   \   000019   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   90....       MOV     DPTR,#GenericApp_applicationbuf
   \   000003   E4           CLR     A
   \   000004   F0           MOVX    @DPTR,A
   \   000005   A3           INC     DPTR
   \   000006   F0           MOVX    @DPTR,A
   \   000007                ; Setup parameters for call to function GenericApp_SendTheMessage
   \   000007                ; Setup parameters for call to function GenericApp_SendTheMessage
   \   000007   12....       LCALL   ??GenericApp_SendTheMessage?relay
   \   00000A                ; Setup parameters for call to function OLED_Init
   \   00000A                ; Setup parameters for call to function OLED_Init
   \   00000A   12....       LCALL   ??OLED_Init?relay
   \   00000D                ; Setup parameters for call to function OLED_P8x16Str
   \   00000D                ; Setup parameters for call to function OLED_P8x16Str
   \   00000D   7C..         MOV     R4,#(`?<Constant "R       ID:">` & 0xff)
   \   00000F   7D..         MOV     R5,#((`?<Constant "R       ID:">` >> 8) & 0xff)
   \   000011   7A00         MOV     R2,#0x0
   \   000013   7900         MOV     R1,#0x0
   \   000015   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000018   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   12....       LCALL   ??OLED_P8x16Str?relay
   \   000003                ; Setup parameters for call to function osal_nv_read
   \   000003                ; Setup parameters for call to function osal_nv_read
   \   000003                ; Setup parameters for call to function osal_nv_read
   \   000003                ; Setup parameters for call to function osal_nv_read
   \   000003   85..82       MOV     DPL,?XSP + 0
   \   000006   85..83       MOV     DPH,?XSP + 1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine35_0
   \   000001                ; // Fall through to label ??Subroutine35_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine35_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine36_0
   \   000001                ; // Fall through to label ??Subroutine36_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine36_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine37_0
   \   000001                ; // Fall through to label ??Subroutine37_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine37_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine38_0
   \   000001                ; // Fall through to label ??Subroutine38_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine38_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine39_0
   \   000001                ; // Fall through to label ??Subroutine39_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine39_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 2,A
   \   000003   78..         MOV     R0,#?V0 + 2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine40_0
   \   000001                ; // Fall through to label ??Subroutine40_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine40_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine41_0
   \   000001                ; // Fall through to label ??Subroutine41_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine41_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine42_0
   \   000001                ; // Fall through to label ??Subroutine42_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine42_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine43_0
   \   000001                ; // Fall through to label ??Subroutine43_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine43_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine44_0
   \   000001                ; // Fall through to label ??Subroutine44_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine44_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 10,A
   \   000003   78..         MOV     R0,#?V0 + 10
   \   000005   22           RET
   2556          
   2557          /*********************************************************************
   2558           * LOCAL FUNCTIONS
   2559           */
   2560          
   2561          /*********************************************************************
   2562           * @fn      GenericApp_MessageMSGCB
   2563           *
   2564           * @brief   Data message processor callback.  This function processes
   2565           *          any incoming data - probably from other devices.  So, based
   2566           *          on cluster ID, perform the intended action.
   2567           *
   2568           * @param   none
   2569           *
   2570           * @return  none
   2571          
   2572           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2573          void GenericApp_MessageMSGCB( afIncomingMSGPacket_t *pkt )
   \                     GenericApp_MessageMSGCB:
   2574          { 
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   2575          #if defined( SENSOR_TYPE_Coord )
   2576          #if(ZDO_COORDINATOR==2)  //ZIGBEE  AT命令模式 透传模式
   2577            
   2578             if(FT_AT==1) // 透传模式
   2579             {HalUARTWrite(HAL_UART_PORT_0, (uint8*)pkt->cmd.Data,pkt->cmd.DataLength);
   2580             }
   2581           #else
   2582          #if defined( CC2530_V30 )
   2583            HalUARTWrite(HAL_UART_PORT_0, (uint8*)pkt->cmd.Data,pkt->cmd.Data[1]+11);
   2584          #else
   2585            HalUARTWrite(HAL_UART_PORT_0, (uint8*)pkt->cmd.Data,pkt->cmd.Data[1]+6);
   2586          #endif
   2587            
   2588          #endif
   2589             HalLedSet ( HAL_LED_1, HAL_LED_MODE_TOGGLE );
   2590          #else
   2591          
   2592             
   2593          if((pkt->cmd.Data[6]==0x11)&&(pkt->cmd.Data[7]==0x22)&&(pkt->cmd.Data[8]==0x33)&&(pkt->cmd.Data[9]==0x44))
   \   000005   EA           MOV     A,R2
   \   000006   2421         ADD     A,#0x21
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   3400         ADDC    A,#0x0
   \   00000C   FF           MOV     R7,A
   \   00000D   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000010   E0           MOVX    A,@DPTR
   \   000011   6411         XRL     A,#0x11
   \   000013   6003         JZ      $+5
   \   000015   02....       LJMP    ??GenericApp_MessageMSGCB_0 & 0xFFFF
   \   000018   8882         MOV     DPL,R0
   \   00001A   8983         MOV     DPH,R1
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   6422         XRL     A,#0x22
   \   000026   7072         JNZ     ??GenericApp_MessageMSGCB_0
   \   000028   8882         MOV     DPL,R0
   \   00002A   8983         MOV     DPH,R1
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   A3           INC     DPTR
   \   000034   E0           MOVX    A,@DPTR
   \   000035   6433         XRL     A,#0x33
   \   000037   7061         JNZ     ??GenericApp_MessageMSGCB_0
   \   000039   8882         MOV     DPL,R0
   \   00003B   8983         MOV     DPH,R1
   \   00003D   A3           INC     DPTR
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   E0           MOVX    A,@DPTR
   \   000047   6444         XRL     A,#0x44
   \   000049   704F         JNZ     ??GenericApp_MessageMSGCB_0
   2594          {if(pkt->cmd.Data[10]==0xCC){if(pkt->cmd.Data[12]==SENSOR_TYPE)openoff=pkt->cmd.Data[11];}
   \   00004B   8882         MOV     DPL,R0
   \   00004D   8983         MOV     DPH,R1
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   64CC         XRL     A,#0xcc
   \   00005C   7027         JNZ     ??GenericApp_MessageMSGCB_1
   \   00005E   E8           MOV     A,R0
   \   00005F   240C         ADD     A,#0xc
   \   000061   F582         MOV     DPL,A
   \   000063   E9           MOV     A,R1
   \   000064   3400         ADDC    A,#0x0
   \   000066   F583         MOV     DPH,A
   \   000068   E0           MOVX    A,@DPTR
   \   000069   6431         XRL     A,#0x31
   \   00006B   702D         JNZ     ??GenericApp_MessageMSGCB_0
   \                     ??GenericApp_MessageMSGCB_2:
   \   00006D   8E82         MOV     DPL,R6
   \   00006F   8F83         MOV     DPH,R7
   \   000071   E0           MOVX    A,@DPTR
   \   000072   240B         ADD     A,#0xb
   \   000074   F8           MOV     R0,A
   \   000075   A3           INC     DPTR
   \   000076   E0           MOVX    A,@DPTR
   \   000077   3400         ADDC    A,#0x0
   \   000079   F9           MOV     R1,A
   \   00007A   8882         MOV     DPL,R0
   \   00007C   8983         MOV     DPH,R1
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   90....       MOV     DPTR,#openoff
   \   000082   F0           MOVX    @DPTR,A
   \   000083   8015         SJMP    ??GenericApp_MessageMSGCB_0
   2595              else
   2596              {
   2597                char GetExtAddr=0;
   \                     ??GenericApp_MessageMSGCB_1:
   \   000085   12....       LCALL   ?Subroutine22 & 0xFFFF
   2598            byte * Send_d;
   2599            Send_d=NLME_GetExtAddr();
   2600            for(int i=0;i<8;i++)
   2601            {
   2602            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   \                     ??CrossCallReturnLabel_32:
   \   000088   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   00008B   7002         JNZ     ??GenericApp_MessageMSGCB_3
   2603              GetExtAddr++;
   \   00008D   05..         INC     ?V0 + 2
   2604            }
   \                     ??GenericApp_MessageMSGCB_3:
   \   00008F   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000092   40F4         JC      ??CrossCallReturnLabel_32
   2605               if(GetExtAddr==8)openoff=pkt->cmd.Data[11]; 
   \   000094   7408         MOV     A,#0x8
   \   000096   65..         XRL     A,?V0 + 2
   \   000098   60D3         JZ      ??GenericApp_MessageMSGCB_2
   2606              }
   2607          }
   2608          #if((SENSOR_TYPE =='E')||(SENSOR_TYPE =='B')||(SENSOR_TYPE =='C')||(SENSOR_TYPE =='D')||(SENSOR_TYPE =='F')\
   2609            ||(SENSOR_TYPE =='U')||(SENSOR_TYPE ==0X10)||(SENSOR_TYPE ==0X21)||(SENSOR_TYPE ==0X11)\
   2610              ||(SENSOR_TYPE ==0X0F)||(SENSOR_TYPE ==0X13)||(SENSOR_TYPE ==0X14)||(SENSOR_TYPE ==0X17)\
   2611                ||(SENSOR_TYPE ==0X24)||(SENSOR_TYPE ==0X5A)||(SENSOR_TYPE ==0X5B)||(SENSOR_TYPE ==0X6A)||(SENSOR_TYPE =='A')\
   2612                  ||(SENSOR_TYPE =='J')||(SENSOR_TYPE =='L')||(SENSOR_TYPE =='M')||(SENSOR_TYPE =='N')\
   2613            ||(SENSOR_TYPE ==0X04)||(SENSOR_TYPE ==0X22)||(SENSOR_TYPE ==0X0C)||(SENSOR_TYPE ==0X16)||(SENSOR_TYPE ==0X19)\
   2614              ||(SENSOR_TYPE ==0X61)||(SENSOR_TYPE ==0X62)||(SENSOR_TYPE ==0X63)||(SENSOR_TYPE ==0X1A)||(SENSOR_TYPE ==0X33)\
   2615                ||(SENSOR_TYPE ==0X72) ||(SENSOR_TYPE ==0X34)||(SENSOR_TYPE ==0X35)||(SENSOR_TYPE ==0X36)||(SENSOR_TYPE ==0X37)\
   2616                  ||(SENSOR_TYPE ==0X38)||(SENSOR_TYPE ==0X39)||(SENSOR_TYPE ==0X3A)||(SENSOR_TYPE ==0X80)||(SENSOR_TYPE ==0X3D)\
   2617                    ||(SENSOR_TYPE ==0X81)||(SENSOR_TYPE ==0X82)||(SENSOR_TYPE ==0X3B)||(SENSOR_TYPE ==0X3C)||(SENSOR_TYPE ==0X3E)\
   2618                      ||(SENSOR_TYPE ==0X3F)||(SENSOR_TYPE ==0X84)||(SENSOR_TYPE ==0X85)||(SENSOR_TYPE ==0X75)||(SENSOR_TYPE ==0X78))
   2619          //定时3
   2620          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==0X00))
   2621                { 
   2622          //定时发送命令
   2623                  if(pkt->cmd.Data[9]==0xAA)//定时发送命令
   2624                  {
   2625                     if((pkt->cmd.Data[7]==0xFF)&&(pkt->cmd.Data[8]==0XFF))
   2626                     { if(pkt->cmd.Data[11]==0xAA)//
   2627                      {T_MGSbit&=~0X80; //0XXXX XXXX
   2628                        T_MGSbit|=0X60; //x11x xxx0 默认定时 应答 正常 状态位
   2629                        GenericApp_time=1;
   2630          #if defined( POWER_SAVING )
   2631                        GenericApp_time=25;
   2632          #endif
   2633                        
   2634                        
   2635                      }
   2636                      if(pkt->cmd.Data[11]==0xBB)//
   2637                      { T_MGSbit&=~0XC0;//00XX XXXX 关闭定时 应答 正常 状态位
   2638                        TIMER3_RUN(FALSE);  //关闭定时
   2639                       GenericApp_time=0;;  
   2640                      }
   2641                     }
   2642                     else
   2643                     {
   2644                  #if defined( ZigBee_C_R_E_IEEE )
   2645                  char GetExtAddr=0;
   2646                  byte * Send_d;
   2647                  Send_d=NLME_GetExtAddr();
   2648                  for(int i=0;i<8;i++)
   2649                  {
   2650                  if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   2651                    GetExtAddr++;
   2652                  }
   2653                     if(GetExtAddr==8)
   2654                  #else
   2655                if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   2656                  #endif    
   2657                   { if(pkt->cmd.Data[11]==0xAA)//
   2658                      {T_MGSbit&=~0X40; //x0xx xxxx
   2659                        T_MGSbit|=0XA0; //1x1x xxx0 设定定时  应答 正常 状态位
   2660                        /* 使能定时器3的溢出中断 */
   2661                       TIMER34_INIT(3);
   2662                       if(pkt->cmd.Data[10]<2)
   2663                         pkt->cmd.Data[10]=1;
   2664                       halSetTimer3Period(100);  //100MS
   2665                       T3_t1Val=(10*pkt->cmd.Data[10]); //pkt->cmd.Data[10]秒
   2666                       IEN1 |= (0x01 << 3);             // 使能Timer3的中断T3IE
   2667                       TIMER3_RUN(TRUE);  
   2668                       GenericApp_applicationbuf=60001;
   2669                       GenericApp_time=0;  
   2670                      }
   2671                      if(pkt->cmd.Data[11]==0xBB)//
   2672                      {T_MGSbit&=~0XC0;//00XX XXXX 关闭定时 应答 正常 状态位
   2673                        T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   2674                        TIMER3_RUN(FALSE);  //关闭定时
   2675                       GenericApp_applicationbuf=60001;
   2676                       GenericApp_time=0;  
   2677                      }
   2678                    }
   2679                  } 
   2680                } 
   2681          //按MAC地址单次取数据命令 (采集类型)
   2682               if(pkt->cmd.Data[9]==0xA1)//按MAC地址单次取数据命令 (采集类型)
   2683                  {
   2684                  #if defined( ZigBee_C_R_E_IEEE )
   2685                  char GetExtAddr=0;
   2686                  byte * Send_d;
   2687                  Send_d=NLME_GetExtAddr();
   2688                  for(int i=0;i<8;i++)
   2689                  {
   2690                  if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   2691                    GetExtAddr++;
   2692                  }
   2693                     if(GetExtAddr==8)
   2694                  #else
   2695                if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   2696                  #endif    
   2697                   { T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   2698                       GenericApp_applicationbuf=60001;
   2699                   }
   2700                }
   2701            }
   2702          #endif 
   2703          //按类别触发命令
   2704          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   \                     ??GenericApp_MessageMSGCB_0:
   \   00009A   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   00009D   7043         JNZ     ??GenericApp_MessageMSGCB_4
   \   00009F   A3           INC     DPTR
   \   0000A0   A3           INC     DPTR
   \   0000A1   A3           INC     DPTR
   \   0000A2   A3           INC     DPTR
   \   0000A3   A3           INC     DPTR
   \   0000A4   A3           INC     DPTR
   \   0000A5   E0           MOVX    A,@DPTR
   \   0000A6   6431         XRL     A,#0x31
   \   0000A8   7038         JNZ     ??GenericApp_MessageMSGCB_4
   2705            {  
   2706              if((pkt->cmd.Data[2]==0XFF)&&(pkt->cmd.Data[3]==0XFF))
   \   0000AA   8882         MOV     DPL,R0
   \   0000AC   8983         MOV     DPH,R1
   \   0000AE   A3           INC     DPTR
   \   0000AF   A3           INC     DPTR
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   64FF         XRL     A,#0xff
   \   0000B3   702D         JNZ     ??GenericApp_MessageMSGCB_4
   \   0000B5   8882         MOV     DPL,R0
   \   0000B7   8983         MOV     DPH,R1
   \   0000B9   A3           INC     DPTR
   \   0000BA   A3           INC     DPTR
   \   0000BB   A3           INC     DPTR
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   64FF         XRL     A,#0xff
   \   0000BF   7021         JNZ     ??GenericApp_MessageMSGCB_4
   2707                {T_MGSbit|=0X21; //xx1x xxx1 应答 触发 状态位
   \   0000C1   90....       MOV     DPTR,#T_MGSbit
   \   0000C4   E0           MOVX    A,@DPTR
   \   0000C5   4421         ORL     A,#0x21
   \   0000C7   F0           MOVX    @DPTR,A
   2708                if(Send_datalend==0)Send_datalend=3;
   \   0000C8   90....       MOV     DPTR,#Send_datalend
   \   0000CB   E0           MOVX    A,@DPTR
   \   0000CC   7005         JNZ     ??GenericApp_MessageMSGCB_5
   \                     ??GenericApp_MessageMSGCB_6:
   \   0000CE   7403         MOV     A,#0x3
   \   0000D0   F0           MOVX    @DPTR,A
   \   0000D1   8005         SJMP    ??GenericApp_MessageMSGCB_7
   2709                 if(Send_datalend>0X20)Send_datalend=3;
   \                     ??GenericApp_MessageMSGCB_5:
   \   0000D3   C3           CLR     C
   \   0000D4   9421         SUBB    A,#0x21
   \   0000D6   50F6         JNC     ??GenericApp_MessageMSGCB_6
   2710                 GenericApp_applicationbuf=0;
   \                     ??GenericApp_MessageMSGCB_7:
   \   0000D8   90....       MOV     DPTR,#GenericApp_applicationbuf
   \   0000DB   E4           CLR     A
   \   0000DC   F0           MOVX    @DPTR,A
   \   0000DD   A3           INC     DPTR
   \   0000DE   F0           MOVX    @DPTR,A
   2711                 GenericApp_SendTheMessage();
   \   0000DF                ; Setup parameters for call to function GenericApp_SendTheMessage
   \   0000DF   12....       LCALL   ??GenericApp_SendTheMessage?relay
   2712                }
   2713            }
   2714          
   2715          
   2716          #if(SENSOR_TYPE =='S')
   2717          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   2718                {
   2719          #if defined( ZigBee_C_R_E_IEEE )
   2720            char GetExtAddr=0;
   2721            byte * Send_d;
   2722            Send_d=NLME_GetExtAddr();
   2723            for(int i=0;i<8;i++)
   2724            {
   2725            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   2726              GetExtAddr++;
   2727            }
   2728               if(GetExtAddr==8)
   2729          #else
   2730               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   2731          #endif    
   2732                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   2733                  if(pkt->cmd.Data[9]==0xAB)//调光
   2734                   { if(pkt->cmd.Data[10]==0xA1)  
   2735                      {GenericApp_ON_OFF=pkt->cmd.Data[11];
   2736                        DimmingAppControl(GenericApp_ON_OFF,0x00);
   2737                      GenericApp_applicationbuf=1;
   2738                      }
   2739                     if(pkt->cmd.Data[10]==0xB2)  
   2740                      { GenericApp_ON_OFF=pkt->cmd.Data[11];
   2741                        DimmingAppControl(GenericApp_ON_OFF,0x01);
   2742                       GenericApp_applicationbuf=1;
   2743                      }
   2744                   }
   2745                 if(pkt->cmd.Data[9]==0xCC)//检测设备
   2746                   {
   2747                    GenericApp_applicationbuf=2;
   2748                   }
   2749                   GenericApp_SendTheMessage();
   2750                }
   2751                }
   2752          #endif
   2753          #if(SENSOR_TYPE =='Q')
   2754          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   2755                {
   2756          #if defined( ZigBee_C_R_E_IEEE )
   2757            char GetExtAddr=0;
   2758            byte * Send_d;
   2759            Send_d=NLME_GetExtAddr();
   2760            for(int i=0;i<8;i++)
   2761            {
   2762            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   2763              GetExtAddr++;
   2764            }
   2765               if(GetExtAddr==8)
   2766          #else
   2767               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   2768          #endif    
   2769                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   2770                  if(pkt->cmd.Data[9]==0xAB)//默认
   2771                   { if(pkt->cmd.Data[10]==0xA1) //设置电子秤系数   50-150之间
   2772                      {if((pkt->cmd.Data[11]>49)&&(pkt->cmd.Data[11]<151))
   2773                        AD_SHINING=pkt->cmd.Data[11];
   2774                         uint16 nv_data=0X0000;
   2775                         nv_data=AD_SHINING;
   2776                      osal_nv_item_init( ZCD_NV_APP_AD_SHINING,sizeof(nv_data), &nv_data );
   2777                      osal_nv_write( ZCD_NV_APP_AD_SHINING, 0,sizeof(nv_data),&nv_data);
   2778                      Send_datalend=0x04;  
   2779                      Send_data[7]=0;//数值为0
   2780                      Send_data[8]=AD_SHINING;//返回设置系数
   2781                      Send_data[9]=(Send_data[6]+Send_data[7]+Send_data[8])%256;
   2782                      }
   2783                   }
   2784                   GenericApp_SendTheMessage();
   2785                }
   2786                }
   2787          #endif
   2788          
   2789          #if(SENSOR_TYPE ==0X29)
   2790          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   2791                { 
   2792                #if defined( ZigBee_C_R_E_IEEE )
   2793                  char GetExtAddr=0;
   2794                  byte * Send_d;
   2795                  Send_d=NLME_GetExtAddr();
   2796                  for(int i=0;i<8;i++)
   2797                  {
   2798                  if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   2799                    GetExtAddr++;
   2800                  }
   2801                     if(GetExtAddr==8)
   2802                #else
   2803                     if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   2804                #endif    
   2805                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   2806                  if(pkt->cmd.Data[9]==0xAF)//点阵价格修改
   2807                  {
   2808                    if(pkt->cmd.Data[10]<5)
   2809                       HalUARTWrite(HAL_UART_PORT_0,&pkt->cmd.Data[10],pkt->cmd.Data[10]+1); //03 05 06 bb // 02 05 BB
   2810                    else 
   2811                      HalUARTWrite(HAL_UART_PORT_0,&pkt->cmd.Data[10],3); //aa 05 bb
   2812                     GenericApp_applicationbuf=1;
   2813                  } 
   2814                  if(pkt->cmd.Data[9]==0xAD)//检测设备
   2815                  {
   2816                    GenericApp_applicationbuf=2;
   2817                  }
   2818                  GenericApp_SendTheMessage();
   2819                }
   2820                }  
   2821          #endif
   2822          #if(SENSOR_TYPE ==0X31)
   2823                if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   \                     ??GenericApp_MessageMSGCB_4:
   \   0000E2   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   0000E5   6003         JZ      $+5
   \   0000E7   02....       LJMP    ??GenericApp_MessageMSGCB_8 & 0xFFFF
   \   0000EA   A3           INC     DPTR
   \   0000EB   A3           INC     DPTR
   \   0000EC   A3           INC     DPTR
   \   0000ED   A3           INC     DPTR
   \   0000EE   A3           INC     DPTR
   \   0000EF   A3           INC     DPTR
   \   0000F0   E0           MOVX    A,@DPTR
   \   0000F1   6431         XRL     A,#0x31
   \   0000F3   6003         JZ      $+5
   \   0000F5   02....       LJMP    ??GenericApp_MessageMSGCB_8 & 0xFFFF
   2824                { 
   2825                #if defined( ZigBee_C_R_E_IEEE )
   2826                  char GetExtAddr=0;
   \   0000F8   12....       LCALL   ?Subroutine22 & 0xFFFF
   2827                  byte * Send_d;
   2828                  Send_d=NLME_GetExtAddr();
   2829                  for(int i=0;i<8;i++)
   2830                  {
   2831                  if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   \                     ??CrossCallReturnLabel_33:
   \   0000FB   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   0000FE   7002         JNZ     ??GenericApp_MessageMSGCB_9
   2832                    GetExtAddr++;
   \   000100   05..         INC     ?V0 + 2
   2833                  }
   \                     ??GenericApp_MessageMSGCB_9:
   \   000102   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000105   40F4         JC      ??CrossCallReturnLabel_33
   2834                     if(GetExtAddr==8)
   \   000107   7408         MOV     A,#0x8
   \   000109   65..         XRL     A,?V0 + 2
   \   00010B   707F         JNZ     ??GenericApp_MessageMSGCB_8
   2835                #else
   2836                     if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   2837                #endif    
   2838                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   \   00010D   90....       MOV     DPTR,#T_MGSbit
   \   000110   E0           MOVX    A,@DPTR
   \   000111   D2E5         SETB    0xE0 /* A   */.5
   \   000113   F0           MOVX    @DPTR,A
   2839                  if(pkt->cmd.Data[9]==0xB4)//向小车发命令
   \   000114   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   000117   A3           INC     DPTR
   \   000118   A3           INC     DPTR
   \   000119   A3           INC     DPTR
   \   00011A   E0           MOVX    A,@DPTR
   \   00011B   64B4         XRL     A,#0xb4
   \   00011D   7011         JNZ     ??GenericApp_MessageMSGCB_10
   2840                  {
   2841                      HalUARTWrite(HAL_UART_PORT_0,&pkt->cmd.Data[10],3);
   \   00011F                ; Setup parameters for call to function HalUARTWrite
   \   00011F   7C03         MOV     R4,#0x3
   \   000121   7D00         MOV     R5,#0x0
   \   000123   E8           MOV     A,R0
   \   000124   240A         ADD     A,#0xa
   \   000126   FA           MOV     R2,A
   \   000127   E9           MOV     A,R1
   \   000128   3400         ADDC    A,#0x0
   \   00012A   FB           MOV     R3,A
   \   00012B   7900         MOV     R1,#0x0
   \   00012D   12....       LCALL   ??HalUARTWrite?relay
   2842                      //HalUARTWrite(HAL_UART_PORT_0,&pkt->cmd.Data[10],3);
   2843                      //GenericApp_applicationbuf=1;
   2844                  }
   2845                  if(pkt->cmd.Data[9]==0xED)//关闭读卡自动停车
   \                     ??GenericApp_MessageMSGCB_10:
   \   000130   8E82         MOV     DPL,R6
   \   000132   8F83         MOV     DPH,R7
   \   000134   E0           MOVX    A,@DPTR
   \   000135   F8           MOV     R0,A
   \   000136   A3           INC     DPTR
   \   000137   E0           MOVX    A,@DPTR
   \   000138   F583         MOV     DPH,A
   \   00013A   8882         MOV     DPL,R0
   \   00013C   A3           INC     DPTR
   \   00013D   A3           INC     DPTR
   \   00013E   A3           INC     DPTR
   \   00013F   A3           INC     DPTR
   \   000140   A3           INC     DPTR
   \   000141   A3           INC     DPTR
   \   000142   A3           INC     DPTR
   \   000143   A3           INC     DPTR
   \   000144   A3           INC     DPTR
   \   000145   E0           MOVX    A,@DPTR
   \   000146   64ED         XRL     A,#0xed
   \   000148   7010         JNZ     ??GenericApp_MessageMSGCB_11
   2846                  {
   2847                     car_stata=0X01;//关闭读卡自动停车
   \   00014A   7401         MOV     A,#0x1
   \   00014C   90....       MOV     DPTR,#car_stata
   \   00014F   F0           MOVX    @DPTR,A
   2848                      GenericApp_applicationbuf=1;
   \   000150   90....       MOV     DPTR,#GenericApp_applicationbuf
   \   000153   F0           MOVX    @DPTR,A
   \   000154   A3           INC     DPTR
   \   000155   E4           CLR     A
   \   000156   F0           MOVX    @DPTR,A
   2849                      GenericApp_SendTheMessage();
   \   000157                ; Setup parameters for call to function GenericApp_SendTheMessage
   \   000157   12....       LCALL   ??GenericApp_SendTheMessage?relay
   2850                  }
   2851                  
   2852                  if((pkt->cmd.Data[9]==0xEA)&&(pkt->cmd.Data[11]==0xEA))
   \                     ??GenericApp_MessageMSGCB_11:
   \   00015A   8E82         MOV     DPL,R6
   \   00015C   8F83         MOV     DPH,R7
   \   00015E   E0           MOVX    A,@DPTR
   \   00015F   F8           MOV     R0,A
   \   000160   A3           INC     DPTR
   \   000161   E0           MOVX    A,@DPTR
   \   000162   F9           MOV     R1,A
   \   000163   E8           MOV     A,R0
   \   000164   2409         ADD     A,#0x9
   \   000166   FA           MOV     R2,A
   \   000167   E9           MOV     A,R1
   \   000168   3400         ADDC    A,#0x0
   \   00016A   FB           MOV     R3,A
   \   00016B   8A82         MOV     DPL,R2
   \   00016D   8B83         MOV     DPH,R3
   \   00016F   E0           MOVX    A,@DPTR
   \   000170   64EA         XRL     A,#0xea
   \   000172   7018         JNZ     ??GenericApp_MessageMSGCB_8
   \   000174   E8           MOV     A,R0
   \   000175   240B         ADD     A,#0xb
   \   000177   F582         MOV     DPL,A
   \   000179   E9           MOV     A,R1
   \   00017A   3400         ADDC    A,#0x0
   \   00017C   F583         MOV     DPH,A
   \   00017E   E0           MOVX    A,@DPTR
   \   00017F   64EA         XRL     A,#0xea
   \   000181   7009         JNZ     ??GenericApp_MessageMSGCB_8
   2853                  { HalUARTWrite(HAL_UART_PORT_0,&pkt->cmd.Data[9],3);
   \   000183                ; Setup parameters for call to function HalUARTWrite
   \   000183   7C03         MOV     R4,#0x3
   \   000185   7D00         MOV     R5,#0x0
   \   000187   7900         MOV     R1,#0x0
   \   000189   12....       LCALL   ??HalUARTWrite?relay
   2854                  }
   2855               //   GenericApp_SendTheMessage();
   2856                }
   2857                }  
   2858          #endif
   2859          
   2860          #if(SENSOR_TYPE ==0X67)
   2861          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   2862                {
   2863          #if defined( ZigBee_C_R_E_IEEE )
   2864            char GetExtAddr=0;
   2865            byte * Send_d;
   2866            Send_d=NLME_GetExtAddr();
   2867            for(int i=0;i<8;i++)
   2868            {
   2869            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   2870              GetExtAddr++;
   2871            }
   2872               if(GetExtAddr==8)
   2873          #else
   2874               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   2875          #endif    
   2876                { T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   2877                unsigned int dat16;
   2878                if(pkt->cmd.Data[9]==0xAA)//正转
   2879                   {  P0_4=1;P0_5=0;
   2880                      P1_0=1;P1_1=0;
   2881                      dat16=(pkt->cmd.Data[10])&0X0F;
   2882                      dat16=((dat16<<8)+pkt->cmd.Data[11]);
   2883                      DAchange(dat16);
   2884                      GenericApp_applicationbuf=1;
   2885                      }
   2886                     if(pkt->cmd.Data[9]==0xBB)  
   2887                      {P0_4=0;P0_5=1;
   2888                       P1_0=0;P1_1=1;
   2889                       dat16=(pkt->cmd.Data[10])&0X0F;
   2890                      dat16=((dat16<<8)+pkt->cmd.Data[11]);
   2891                      DAchange(dat16);
   2892                       GenericApp_applicationbuf=1;
   2893                      }
   2894                   if(pkt->cmd.Data[9]==0xCC)  
   2895                      {P0_4=0;P0_5=0;
   2896                       P1_0=0;P1_1=0;
   2897                      DAchange(0);
   2898                       GenericApp_applicationbuf=1;
   2899                      }
   2900                   GenericApp_SendTheMessage();
   2901                   }
   2902                }
   2903          #endif
   2904          
   2905          #if(SENSOR_TYPE ==0X6D)
   2906          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   2907          { 
   2908              // if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))  
   2909               if((pkt->cmd.Data[7]==0X01)&&(pkt->cmd.Data[8]==0X02))  
   2910                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   2911                  GenericApp_applicationbuf=1;
   2912                    HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[9]),pkt->cmd.Data[1]-3);
   2913                      GenericApp_SendTheMessage();
   2914                } 
   2915                }  
   2916          #endif
   2917          #if(SENSOR_TYPE ==0X30)
   2918           if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   2919                {
   2920          #if defined( ZigBee_C_R_E_IEEE )
   2921            char GetExtAddr=0;
   2922            byte * Send_d;
   2923            Send_d=NLME_GetExtAddr();
   2924            for(int i=0;i<8;i++)
   2925            {
   2926            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   2927              GetExtAddr++;
   2928            }
   2929               if(GetExtAddr==8)
   2930          #else
   2931               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   2932          #endif    
   2933                { T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   2934                if(pkt->cmd.Data[9]==0xAA)//2向4线步进电机
   2935                   { if(pkt->cmd.Data[10]==0xAB) //正转
   2936                        {a68=0xAB;b68=pkt->cmd.Data[11];
   2937                        }
   2938                     if(pkt->cmd.Data[10]==0xBA) //反转
   2939                        {a68=0xBA;b68=pkt->cmd.Data[11];
   2940                        }
   2941                      GenericApp_applicationbuf=1;
   2942                    }
   2943                  if(pkt->cmd.Data[9]==0xAF)//2向4线步进电机窗帘开启关闭
   2944                   { 
   2945                     if(pkt->cmd.Data[10]==0xAB) //正转//窗帘开启
   2946                        {a68=0xAB;b68=250;
   2947                        }
   2948                     if(pkt->cmd.Data[10]==0xBA) //反转//窗帘关闭
   2949                        {a68=0xBA;b68=250;
   2950                        }
   2951                      GenericApp_applicationbuf=1;
   2952                    }
   2953                  if(pkt->cmd.Data[9]==0xB0)//2向4线步进电机
   2954                   { if((pkt->cmd.Data[10]==0xAA)&&(pkt->cmd.Data[12]==0xBB)) //正转
   2955                        {
   2956                          if(pkt->cmd.Data[11]==0x01)//关闸
   2957                          {c68=0;if(a68!=0xab) {a68=0xab;b68=B01;}}
   2958                           if(pkt->cmd.Data[11]==0x02) //开闸
   2959                           {c68=150; if(a68!=0xba){a68=0xba;b68=B01;}}
   2960                        GenericApp_applicationbuf=1;
   2961                        } 
   2962                    }
   2963                   GenericApp_SendTheMessage();
   2964                   }
   2965          
   2966                }
   2967          #endif
   2968          #if(SENSOR_TYPE ==0X73)
   2969           if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   2970                {
   2971          #if defined( ZigBee_C_R_E_IEEE )
   2972            char GetExtAddr=0;
   2973            byte * Send_d;
   2974            Send_d=NLME_GetExtAddr();
   2975            for(int i=0;i<8;i++)
   2976            {
   2977            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   2978              GetExtAddr++;
   2979            }
   2980               if(GetExtAddr==8)
   2981          #else
   2982               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   2983          #endif    
   2984                { T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   2985                     if(pkt->cmd.Data[10]==0xA8)//8路堆垛机
   2986                   {pkt->cmd.Data[9]=0x05;
   2987                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[9]),0X06);
   2988                    }
   2989                     if(pkt->cmd.Data[10]==0xAC)//磁线控制器
   2990                   {pkt->cmd.Data[9]=0x05;
   2991                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[9]),0X06);
   2992                    }
   2993                  if(pkt->cmd.Data[10]==0xA1)//堆垛机
   2994                   { 
   2995                     if(pkt->cmd.Data[11]==0xAB) //正转//
   2996                        {
   2997                          a68=0xAB;b68=5000;
   2998                        b68=(((int)(pkt->cmd.Data[12])<<8)+(pkt->cmd.Data[13]));
   2999                        }
   3000                     if(pkt->cmd.Data[11]==0xBA) //反转//
   3001                        {a68=0xba;b68=5000;
   3002                       b68=(((int)(pkt->cmd.Data[12])<<8)+(pkt->cmd.Data[13]));
   3003                        }
   3004                      GenericApp_applicationbuf=1;
   3005                     Send_data[10]=0X00;
   3006                   GenericApp_SendTheMessage();
   3007                    }
   3008                   }
   3009          
   3010                }
   3011          #endif
   3012          #if(SENSOR_TYPE ==0X6A)
   3013          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3014                {
   3015          #if defined( ZigBee_C_R_E_IEEE )
   3016            char GetExtAddr=0;
   3017            byte * Send_d;
   3018            Send_d=NLME_GetExtAddr();
   3019            for(int i=0;i<8;i++)
   3020            {
   3021            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3022              GetExtAddr++;
   3023            }
   3024               if(GetExtAddr==8)
   3025          #else
   3026               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3027          #endif    
   3028                { T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3029                  GenericApp_switch=1;
   3030                  Send_data[7]=pkt->cmd.Data[9];
   3031                   GenericApp_SendTheMessage();
   3032                   }
   3033                }
   3034          #endif
   3035          #if(SENSOR_TYPE ==0X6B)
   3036          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3037                {
   3038          #if defined( ZigBee_C_R_E_IEEE )
   3039            char GetExtAddr=0;
   3040            byte * Send_d;
   3041            Send_d=NLME_GetExtAddr();
   3042            for(int i=0;i<8;i++)
   3043            {
   3044            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3045              GetExtAddr++;
   3046            }
   3047               if(GetExtAddr==8)
   3048          #else
   3049               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3050          #endif    
   3051                { T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3052                  if(pkt->cmd.Data[9]==0xDD) //led屏
   3053                   {  uint8  hrx[4]={0X02,0x33,0x01,0X00};
   3054                 hrx[2]=pkt->cmd.Data[10];
   3055                 HalUARTWrite(HAL_UART_PORT_0,hrx,4);
   3056                      GenericApp_applicationbuf=1;
   3057                      }
   3058                  if(pkt->cmd.Data[9]==0xDE) //DE:A8广告机
   3059                   {  
   3060                 HalUARTWrite(HAL_UART_PORT_0,&pkt->cmd.Data[9],3);
   3061                      GenericApp_applicationbuf=1;
   3062                      }
   3063                    if(pkt->cmd.Data[9]==0xDC) //DC:字库LED
   3064                   {  
   3065                 HalUARTWrite(HAL_UART_PORT_0,&pkt->cmd.Data[12],pkt->cmd.Data[13]+2);
   3066                      GenericApp_applicationbuf=1;
   3067                      }
   3068                  Send_data[7]=pkt->cmd.Data[9];
   3069                   GenericApp_SendTheMessage();
   3070                   }
   3071                }
   3072          #endif
   3073          #if(SENSOR_TYPE ==0X65)
   3074          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3075                {
   3076          #if defined( ZigBee_C_R_E_IEEE )
   3077            char GetExtAddr=0;
   3078            byte * Send_d;
   3079            Send_d=NLME_GetExtAddr();
   3080            for(int i=0;i<8;i++)
   3081            {
   3082            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3083              GetExtAddr++;
   3084            }
   3085               if(GetExtAddr==8)
   3086          #else
   3087               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3088          #endif    
   3089                { T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3090                  show_right_down(pkt->cmd.Data[10]);
   3091                  GenericApp_switch=1;
   3092                   GenericApp_SendTheMessage();
   3093                   }
   3094                }
   3095          #endif
   3096          #if(SENSOR_TYPE ==0X6C)
   3097          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3098                {
   3099          #if defined( ZigBee_C_R_E_IEEE )
   3100            char GetExtAddr=0;
   3101            byte * Send_d;
   3102            Send_d=NLME_GetExtAddr();
   3103            for(int i=0;i<8;i++)
   3104            {
   3105            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3106              GetExtAddr++;
   3107            }
   3108               if(GetExtAddr==8)
   3109          #else
   3110               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3111          #endif    
   3112                { T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3113                //  show_right_down(pkt->cmd.Data[10]);
   3114                  if(pkt->cmd.Data[10]==0x02)//
   3115               {switch(pkt->cmd.Data[11])
   3116                   {case 0x0B:P1_1=0; break;//11路
   3117                   case 0x16:P1_2=0; break;//22路
   3118                   case 0x37:P1_3=0; break;//55路
   3119                   case 0x58:P1_4=0; break;//88路
   3120                  default:break;
   3121                   }
   3122                }
   3123                lcd_txt_clr(); 
   3124                switch(pkt->cmd.Data[9])
   3125                   {case 0x01:txt_disp(str2,0x80,16); break;
   3126                   case 0x02:txt_disp(str3,0x80,16); break;
   3127                   case 0x03:txt_disp(str4,0x80,16); break;
   3128                   case 0x04:txt_disp(str5,0x80,16); break;
   3129                  default:break;
   3130                   }
   3131                    switch(pkt->cmd.Data[10])
   3132                   {case 0x01:hzkdis(1,tab1); break;
   3133                   case 0x02:hzkdis(1,tab2); break;
   3134                   case 0x03:hzkdis(1,tab3); break;
   3135                  default:break;
   3136                   }
   3137                 txt_disp(&str1[(pkt->cmd.Data[11]/10)*2],0x90,2);//80 90 88 98
   3138                 txt_disp(&str1[(pkt->cmd.Data[11]%10)*2],0x91,2);//80 90 88 98
   3139                  if(pkt->cmd.Data[10]==0x03)
   3140                  { txt_disp(&str1[(pkt->cmd.Data[12]/10)*2],0x8a,2);//80 90 88 98
   3141                 txt_disp(&str1[(pkt->cmd.Data[12]%10)*2],0x8b,2);//80 90 88 98
   3142                 txt_disp(&str1[((pkt->cmd.Data[12]*5)/10)*2],0x98,2);//80 90 88 98
   3143                 txt_disp(&str1[((pkt->cmd.Data[12]*5)%10)*2],0x99,2);//80 90 88 98
   3144                  }
   3145                   
   3146              P1|=0X1E;
   3147             
   3148                  GenericApp_switch=1;
   3149                   GenericApp_SendTheMessage();
   3150                }
   3151                }
   3152          #endif
   3153          #if(SENSOR_TYPE ==0X66)
   3154          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3155                {
   3156          #if defined( ZigBee_C_R_E_IEEE )
   3157            char GetExtAddr=0;
   3158            byte * Send_d;
   3159            Send_d=NLME_GetExtAddr();
   3160            for(int i=0;i<8;i++)
   3161            {
   3162            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3163              GetExtAddr++;
   3164            }
   3165               if(GetExtAddr==8)
   3166          #else
   3167               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3168          #endif    
   3169                { T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3170                  LedNumVal=pkt->cmd.Data[9];
   3171                  GenericApp_switch=1;
   3172                   GenericApp_SendTheMessage();
   3173                   }
   3174                }
   3175          #endif
   3176          #if(SENSOR_TYPE ==0X6E)
   3177          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3178                {
   3179          #if defined( ZigBee_C_R_E_IEEE )
   3180            char GetExtAddr=0;
   3181            byte * Send_d;
   3182            Send_d=NLME_GetExtAddr();
   3183            for(int i=0;i<8;i++)
   3184            {
   3185            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3186              GetExtAddr++;
   3187            }
   3188               if(GetExtAddr==8)
   3189          #else
   3190               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3191          #endif    
   3192                { T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3193                if(pkt->cmd.Data[9]==0X01)//16路继电器控制
   3194                {
   3195                  SendDataS(&(pkt->cmd.Data[11]),pkt->cmd.Data[10]);
   3196                  GenericApp_switch=1;
   3197                   GenericApp_SendTheMessage();
   3198                }
   3199                   }
   3200                }
   3201          #endif
   3202          #if(SENSOR_TYPE ==0XA3)
   3203          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3204                { 
   3205                #if defined( ZigBee_C_R_E_IEEE )
   3206                  char GetExtAddr=0;
   3207                  byte * Send_d;
   3208                  Send_d=NLME_GetExtAddr();
   3209                  for(int i=0;i<8;i++)
   3210                  {
   3211                  if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3212                    GetExtAddr++;
   3213                  }
   3214                     if(GetExtAddr==8)
   3215                #else
   3216                     if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3217                #endif    
   3218                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3219                  if(pkt->cmd.Data[9]==0xB5)//向红绿灯发送指令
   3220                  {
   3221                      HalUARTWrite(HAL_UART_PORT_0,&pkt->cmd.Data[10],5);
   3222                      GenericApp_applicationbuf=0;
   3223                  } 
   3224                  if(pkt->cmd.Data[9]==0xAD)//检测设备
   3225                  {
   3226                    GenericApp_applicationbuf=2;
   3227                  }
   3228                  GenericApp_SendTheMessage();
   3229                }
   3230                }  
   3231          #endif
   3232          #if(SENSOR_TYPE ==0X05)
   3233          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3234                {
   3235          #if defined( ZigBee_C_R_E_IEEE )
   3236                  char GetExtAddr=0;
   3237            byte * Send_d;
   3238            Send_d=NLME_GetExtAddr();
   3239            for(int i=0;i<8;i++)
   3240            {
   3241            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3242              GetExtAddr++;
   3243            }
   3244               if(GetExtAddr==8)
   3245          #else
   3246               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3247          #endif    
   3248                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3249                  if(pkt->cmd.Data[9]==0xDD)//控制220V继电器
   3250                   {uint8 uartkey=0;
   3251                     if(pkt->cmd.Data[10]==0xA3)  
   3252                      {  GenericApp_applicationbuf=1;
   3253                        if(0xAA==(pkt->cmd.Data[11]))
   3254                        { P1_7=0;//停止
   3255                        uartkey=0x02;
   3256                       // HalUARTWrite(HAL_UART_PORT_0,&uartkey,1);//发射停命令 02
   3257                         for(int i=0;i<30000;i++)
   3258                           for(int i=0;i<100;i++)
   3259                             asm("NOP");
   3260                          P1_6=1;//开
   3261                          uartkey=0x01;
   3262                           HalUARTWrite(HAL_UART_PORT_0,&uartkey,1);//发射开命令 01
   3263                    GenericApp_BX=200;
   3264                    GenericApp_ON_OFF=0XAA;
   3265                        }
   3266                        if(0xA1==(pkt->cmd.Data[11]))
   3267                        { if(GenericApp_ON_OFF==0XA2)
   3268                          {P1_6=0;//停止
   3269                         for(int i=0;i<30000;i++)
   3270                           for(int i=0;i<100;i++)
   3271                             asm("NOP");
   3272                          P1_7=1;//开
   3273                         GenericApp_BX=50;
   3274                         GenericApp_ON_OFF=0XA1;
   3275                        }
   3276                        if(GenericApp_ON_OFF==0XAA)
   3277                          {P1_6=0;//停止
   3278                         for(int i=0;i<30000;i++)
   3279                           for(int i=0;i<100;i++)
   3280                             asm("NOP");
   3281                          P1_7=1;//开
   3282                         GenericApp_BX=100;
   3283                         GenericApp_ON_OFF=0XA1;
   3284                        }
   3285                        if(GenericApp_ON_OFF==0XBB)
   3286                          {P1_7=0;//停止
   3287                         for(int i=0;i<30000;i++)
   3288                           for(int i=0;i<100;i++)
   3289                             asm("NOP");
   3290                          P1_6=1;//开
   3291                         GenericApp_BX=50;
   3292                         GenericApp_ON_OFF=0XA1;
   3293                        }
   3294                        }
   3295                         if(0xA2==(pkt->cmd.Data[11]))
   3296                        { if(GenericApp_ON_OFF==0XA1)
   3297                          {P1_7=0;//停止
   3298                         for(int i=0;i<30000;i++)
   3299                           for(int i=0;i<100;i++)
   3300                             asm("NOP");
   3301                          P1_6=1;//开
   3302                         GenericApp_BX=50;
   3303                         GenericApp_ON_OFF=0XA2;
   3304                        }
   3305                        if(GenericApp_ON_OFF==0XAA)
   3306                          {P1_6=0;//停止
   3307                         for(int i=0;i<30000;i++)
   3308                           for(int i=0;i<100;i++)
   3309                             asm("NOP");
   3310                          P1_7=1;//开
   3311                         GenericApp_BX=50;
   3312                         GenericApp_ON_OFF=0XA2;
   3313                        }
   3314                         if(GenericApp_ON_OFF==0XBB)
   3315                          {P1_7=0;//停止
   3316                         for(int i=0;i<30000;i++)
   3317                           for(int i=0;i<100;i++)
   3318                             asm("NOP");
   3319                          P1_6=1;//开
   3320                         GenericApp_BX=100;
   3321                         GenericApp_ON_OFF=0XA2;
   3322                        }
   3323                        }
   3324                        if((pkt->cmd.Data[11])==0xBB)
   3325                        { uartkey=0x02;
   3326                          // HalUARTWrite(HAL_UART_PORT_0,&uartkey,1);//发射停命令 02
   3327                          P1_6=0; //停止
   3328                            for(int i=0;i<30000;i++)
   3329                              for(int i=0;i<100;i++)
   3330                             asm("NOP");
   3331                          P1_7=1;   //关
   3332                          uartkey=0x03;
   3333                           HalUARTWrite(HAL_UART_PORT_0,&uartkey,1);//发射管命令 03
   3334                          GenericApp_BX=200;
   3335                       GenericApp_ON_OFF=0XBB;
   3336                        }
   3337                         if((pkt->cmd.Data[11])==0xCC)
   3338                         {uartkey=0x02;
   3339                           HalUARTWrite(HAL_UART_PORT_0,&uartkey,1);//发射停命令 02
   3340                           P1_7=0;   //停止
   3341                          P1_6=0;  //停止
   3342                         }
   3343                      }
   3344                   }
   3345                  GenericApp_SendTheMessage();
   3346                } 
   3347                }  
   3348          #endif
   3349          #if(SENSOR_TYPE ==0X06)
   3350              uint8 DD[3]={0x00,0X00,0x00};
   3351          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3352                {OSAL_SET_CPU_INTO_SLEEP=1;
   3353          #if defined( ZigBee_C_R_E_IEEE )
   3354                  char GetExtAddr=0;
   3355            byte * Send_d;
   3356            Send_d=NLME_GetExtAddr();
   3357            for(int i=0;i<8;i++)
   3358            {
   3359            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3360              GetExtAddr++;
   3361            }
   3362               if(GetExtAddr==8)
   3363          #else
   3364               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3365          #endif    
   3366                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3367                  if(pkt->cmd.Data[9]==0xDD)//智能小车
   3368                   {
   3369                     DD[0]=pkt->cmd.Data[10];
   3370                     if(!DD[0])DD[0]=0XBB;  //以前是发送 0x00 小车停止 现在强制改为 0xBB小车停止
   3371                     HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,1);
   3372                      GenericApp_applicationbuf=1;
   3373                       GenericApp_SendTheMessage();
   3374                   }
   3375                  if((pkt->cmd.Data[9]==0xEA)&&(pkt->cmd.Data[11]==0xEA))//采集温度命令
   3376                  {uint8 hr[15]={0};
   3377                   for(int i=0;i<(pkt->cmd.Data[10]+3);i++)
   3378                     hr[i]=pkt->cmd.Data[9+i];
   3379                     unsigned int  data;						    
   3380                     float Temperature;
   3381                     Temperature = ReadTemperature();             //返回16位二进制数
   3382                     Temperature *= CelsiurPerLSB;		//转换成浮点型温度值(摄氏度)
   3383                     data=(unsigned int)(100*Temperature);   
   3384                     hr[2]=(uint8)(data/ 100);
   3385                      if(hr[2]>0x30)
   3386                      { Temperature = ReadTemperature();             //返回16位二进制数
   3387                     Temperature *= CelsiurPerLSB;		//转换成浮点型温度值(摄氏度)
   3388                     data=(unsigned int)(100*Temperature);   
   3389                     hr[2]=(uint8)(data/ 100);
   3390                      }
   3391                      hr[1]=pkt->cmd.Data[10];
   3392                     if(hr[2]<0x30)
   3393                     {
   3394                     if((pkt->cmd.Data[10]))
   3395                     HalUARTWrite(HAL_UART_PORT_0, (uint8*)hr,(pkt->cmd.Data[10]+3));
   3396                     GenericApp_applicationbuf=2; 
   3397                     Send_data[8]=hr[2];
   3398                     GenericApp_SendTheMessage();
   3399                     }
   3400                   }
   3401                } 
   3402                   OSAL_SET_CPU_INTO_SLEEP=0;
   3403                }
   3404          #endif
   3405          #if(SENSOR_TYPE ==0X07)
   3406          
   3407          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3408                {OSAL_SET_CPU_INTO_SLEEP=1;
   3409          #if defined( ZigBee_C_R_E_IEEE )
   3410                  char GetExtAddr=0;
   3411            byte * Send_d;
   3412            Send_d=NLME_GetExtAddr();
   3413            for(int i=0;i<8;i++)
   3414            {
   3415            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3416              GetExtAddr++;
   3417            }
   3418               if(GetExtAddr==8)
   3419          #else
   3420               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3421          #endif    
   3422                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3423                  if(pkt->cmd.Data[9]==0xA1)
   3424                   { AB=0X0B;
   3425                     HalUARTWrite(HAL_UART_PORT_0, &pkt->cmd.Data[11],pkt->cmd.Data[10]);
   3426                   }
   3427                } 
   3428                }
   3429          #endif
   3430          #if(SENSOR_TYPE ==0X09)
   3431              char DD[3]={0x00,0X00,0x00};
   3432          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3433                {OSAL_SET_CPU_INTO_SLEEP=1;
   3434          #if defined( ZigBee_C_R_E_IEEE )
   3435                  char GetExtAddr=0;
   3436            byte * Send_d;
   3437            Send_d=NLME_GetExtAddr();
   3438            for(int i=0;i<8;i++)
   3439            {
   3440            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3441              GetExtAddr++;
   3442            }
   3443               if(GetExtAddr==8)
   3444          #else
   3445               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3446          #endif    
   3447                {  T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3448                  //开关量                  //数码管                  //步进电机
   3449                  if((pkt->cmd.Data[9]==0xDD)||(pkt->cmd.Data[9]==0xEA)||(pkt->cmd.Data[9]==0xEB))
   3450                   {
   3451                     DD[0]=pkt->cmd.Data[9];
   3452                     DD[1]=pkt->cmd.Data[10];
   3453                     DD[2]=pkt->cmd.Data[11];
   3454                     HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,3);
   3455                      GenericApp_applicationbuf=1;
   3456                       GenericApp_SendTheMessage();
   3457                   }
   3458                } 
   3459                   OSAL_SET_CPU_INTO_SLEEP=0;
   3460                }
   3461          #endif
   3462          #if(SENSOR_TYPE ==0X13)
   3463          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3464                { 
   3465          #if defined( ZigBee_C_R_E_IEEE )
   3466            char GetExtAddr=0;
   3467            byte * Send_d;
   3468            Send_d=NLME_GetExtAddr();
   3469            for(int i=0;i<8;i++)
   3470            {
   3471            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3472              GetExtAddr++;
   3473            }
   3474               if(GetExtAddr==8)
   3475          #else
   3476               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3477          #endif    
   3478                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3479                  if((pkt->cmd.Data[9]==0X43)&&(pkt->cmd.Data[10]==0XC3)&&(pkt->cmd.Data[11]==0X6F))//读有功电总量
   3480                   {
   3481                     GenericApp_applicationbuf=60001;
   3482                      GenericApp_time=0;
   3483                   }
   3484                }
   3485                }  
   3486          #endif  
   3487          
   3488          #if(SENSOR_TYPE ==0XF0)
   3489          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3490                { 
   3491          #if defined( ZigBee_C_R_E_IEEE )
   3492            char GetExtAddr=0;
   3493            byte * Send_d;
   3494            Send_d=NLME_GetExtAddr();
   3495            for(int i=0;i<8;i++)
   3496            {
   3497            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3498              GetExtAddr++;
   3499            }
   3500               if(GetExtAddr==8)
   3501          #else
   3502               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3503          #endif    
   3504                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3505                  HalUARTWrite(HAL_UART_PORT_0,&pkt->cmd.Data[9],1);
   3506                  GenericApp_applicationbuf=1;
   3507                  GenericApp_SendTheMessage();
   3508                }
   3509                }  
   3510          #endif  
   3511          #if(SENSOR_TYPE ==0X70)
   3512          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3513                { 
   3514          #if defined( ZigBee_C_R_E_IEEE )
   3515            char GetExtAddr=0;
   3516            byte * Send_d;
   3517            Send_d=NLME_GetExtAddr();
   3518            for(int i=0;i<8;i++)
   3519            {
   3520            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3521              GetExtAddr++;
   3522            }
   3523               if(GetExtAddr==8)
   3524          #else
   3525               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3526          #endif    
   3527                   {
   3528                  T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3529                  GenericApp_applicationdata=0;
   3530                  P1_0=1; 
   3531                  GenericApp_uart_485=0;
   3532                   if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0F))
   3533                {
   3534                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3535                  // Send_datalend=14;for(char i=0;i<11;i++)Send_data[8+i]=pkt->cmd.Data[10+i];
   3536                 //   Send_data[8]=0XF1; Send_data[12]=((Send_data[12]&0XF0)|0X0A);
   3537                   // GenericApp_SendTheMessage();
   3538                }
   3539                if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0E))
   3540                {
   3541                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3542                   // Send_datalend=14;for(char i=0;i<11;i++)Send_data[8+i]=pkt->cmd.Data[10+i];
   3543                   // Send_data[8]=0XF1; Send_data[12]=((Send_data[12]&0XF0)|0X0A);
   3544                  //  GenericApp_SendTheMessage();
   3545                }
   3546                } 
   3547                }  
   3548          #endif  
   3549          #if(SENSOR_TYPE ==0X74)
   3550          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3551                { 
   3552          #if defined( ZigBee_C_R_E_IEEE )
   3553            char GetExtAddr=0;
   3554            byte * Send_d;
   3555            Send_d=NLME_GetExtAddr();
   3556            for(int i=0;i<8;i++)
   3557            {
   3558             if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3559              GetExtAddr++;
   3560            }
   3561               if(GetExtAddr==8)
   3562          #else
   3563               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3564          #endif    
   3565                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3566                  if((pkt->cmd.Data[9]==0X01)&&(pkt->cmd.Data[11]<=0X10))
   3567                   {GenericApp_applicationbuf=60001;//应答
   3568                    HalUARTWrite(HAL_UART_PORT_0, &pkt->cmd.Data[12],pkt->cmd.Data[11]);
   3569                   }
   3570                }
   3571                }  
   3572          #endif  
   3573          #if(SENSOR_TYPE ==0X14)
   3574          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3575                { 
   3576          #if defined( ZigBee_C_R_E_IEEE )
   3577            char GetExtAddr=0;
   3578            byte * Send_d;
   3579            Send_d=NLME_GetExtAddr();
   3580            for(int i=0;i<8;i++)
   3581            {
   3582             if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3583              GetExtAddr++;
   3584            }
   3585               if(GetExtAddr==8)
   3586          #else
   3587               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3588          #endif    
   3589                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3590                  if((pkt->cmd.Data[9]==0X01)&&(pkt->cmd.Data[10]==0X03)&&(pkt->cmd.Data[11]==0X0C))//读有功电总量
   3591                   {     GenericApp_applicationbuf=60001;
   3592                          GenericApp_time=0;
   3593          
   3594                   //uint8  hr[8]={0x01,0x03,0x00,0x00,0x00,0x0C,0xA5,0xE2};
   3595                        //  HalUARTWrite(HAL_UART_PORT_0, hr,8);
   3596                   }
   3597                }
   3598                }  
   3599          #endif  
   3600          
   3601          #if(SENSOR_TYPE ==0X15)
   3602          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3603                { 
   3604          #if defined( ZigBee_C_R_E_IEEE )
   3605            char GetExtAddr=0;
   3606            byte * Send_d;
   3607            Send_d=NLME_GetExtAddr();
   3608            for(int i=0;i<8;i++)
   3609            {
   3610            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3611              GetExtAddr++;
   3612            }
   3613               if(GetExtAddr==8)
   3614          #else
   3615               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3616          #endif    
   3617                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3618                  if(pkt->cmd.Data[9]==0xDD)//
   3619                   {GenericApp_applicationbuf=1;
   3620                     if(pkt->cmd.Data[10]==0x01)  
   3621                      {
   3622                        P1_1=0;  
   3623                      }
   3624                     if(pkt->cmd.Data[10]==0x02)  
   3625                      {
   3626                        P1_2=0;  
   3627                      }
   3628                     if(pkt->cmd.Data[10]==0x03)  
   3629                      {
   3630                        P1_3=0;  
   3631                      }
   3632                      if(pkt->cmd.Data[10]==0x04)  
   3633                      {
   3634                        P1_4=0;  
   3635                      }
   3636                     GenericApp_SendTheMessage();
   3637                   }
   3638                  
   3639                }
   3640                }  
   3641          #endif  
   3642             
   3643          #if(SENSOR_TYPE =='H')
   3644          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3645                {
   3646          #if defined( ZigBee_C_R_E_IEEE )
   3647                  char GetExtAddr=0;
   3648            byte * Send_d;
   3649            Send_d=NLME_GetExtAddr();
   3650            for(int i=0;i<8;i++)
   3651            {
   3652            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3653              GetExtAddr++;
   3654            }
   3655               if(GetExtAddr==8)
   3656          #else
   3657               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3658          #endif    
   3659                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3660                  if(pkt->cmd.Data[9]==0xDD)//控制220V继电器
   3661                   {GenericApp_applicationbuf=1;
   3662                     if(pkt->cmd.Data[10]==0x01)  
   3663                      {
   3664                        if(0xAA==pkt->cmd.Data[11])
   3665                        { P1_0=0;   //开继电器
   3666                        }if(pkt->cmd.Data[11]==0xBB)
   3667                        P1_0=1;   //关继电器
   3668                      }
   3669                     if(pkt->cmd.Data[10]==0xC0)  
   3670                      {  
   3671                        if(0xAA==pkt->cmd.Data[11])
   3672                        { P1_7=1;   P1_6=0;}   //窗帘开
   3673                        if(pkt->cmd.Data[11]==0xBB)
   3674                        {  P1_6=1; P1_7=0;}   //窗帘关
   3675                      }
   3676                   }
   3677                 if(pkt->cmd.Data[9]==0xCC)//检测设备
   3678                   {
   3679                    GenericApp_applicationbuf=2;
   3680                   }
   3681                   GenericApp_SendTheMessage();
   3682                } 
   3683                }  
   3684          #endif
   3685          #if(SENSOR_TYPE ==0X7C)
   3686          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3687                { 
   3688          #if defined( ZigBee_C_R_E_IEEE )
   3689                  char GetExtAddr=0;
   3690            byte * Send_d;
   3691            Send_d=NLME_GetExtAddr();
   3692            for(int i=0;i<8;i++)
   3693            {
   3694            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3695              GetExtAddr++;
   3696            }
   3697               if(GetExtAddr==8)
   3698          #else
   3699               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3700          #endif    
   3701                { //uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   3702                  T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3703                  GenericApp_applicationdata=0;
   3704                   if((pkt->cmd.Data[11]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[12]==0X0F))
   3705                {
   3706                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[11]),pkt->cmd.Data[12]+2);
   3707                }
   3708                if((pkt->cmd.Data[11]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[12]==0X0E))
   3709                {
   3710                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[11]),pkt->cmd.Data[12]+2);
   3711                }
   3712                } 
   3713          }  
   3714          #endif
   3715          #if(SENSOR_TYPE ==0X25)
   3716          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3717                { 
   3718          #if defined( ZigBee_C_R_E_IEEE )
   3719                  char GetExtAddr=0;
   3720            byte * Send_d;
   3721            Send_d=NLME_GetExtAddr();
   3722            for(int i=0;i<8;i++)
   3723            {
   3724            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3725              GetExtAddr++;
   3726            }
   3727               if(GetExtAddr==8)
   3728          #else
   3729               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3730          #endif    
   3731                { //uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   3732                  T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3733                  GenericApp_applicationdata=0;
   3734                   if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0F))
   3735                {
   3736                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3737                }
   3738                if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0E))
   3739                {
   3740                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3741                }
   3742                } 
   3743          }  
   3744          #endif
   3745          
   3746          #if(SENSOR_TYPE ==0X7B)
   3747          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3748                { 
   3749          #if defined( ZigBee_C_R_E_IEEE )
   3750                  char GetExtAddr=0;
   3751            byte * Send_d;
   3752            Send_d=NLME_GetExtAddr();
   3753            for(int i=0;i<8;i++)
   3754            {
   3755            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3756              GetExtAddr++;
   3757            }
   3758               if(GetExtAddr==8)
   3759          #else
   3760               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3761          #endif    
   3762                { //uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   3763                  T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3764                  GenericApp_applicationdata=0;
   3765                   if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0F))
   3766                {
   3767                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3768                }
   3769                if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0E))
   3770                {
   3771                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3772                }
   3773                } 
   3774          }  
   3775          #endif
   3776          #if(SENSOR_TYPE ==0X71)
   3777          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3778                { 
   3779          #if defined( ZigBee_C_R_E_IEEE )
   3780                  char GetExtAddr=0;
   3781            byte * Send_d;
   3782            Send_d=NLME_GetExtAddr();
   3783            for(int i=0;i<8;i++)
   3784            {
   3785            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3786              GetExtAddr++;
   3787            }
   3788               if(GetExtAddr==8)
   3789          #else
   3790               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3791          #endif    
   3792                { //uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   3793                  T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3794                  GenericApp_applicationdata=0;
   3795                   if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0F))
   3796                { if((pkt->cmd.Data[12]==0xAA)||(pkt->cmd.Data[12]==0xBB))
   3797                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3798                  else
   3799                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[14]),1);
   3800                  //HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3801                }
   3802                if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0E))
   3803                {if((pkt->cmd.Data[12]==0xAA)||(pkt->cmd.Data[12]==0xBB))
   3804                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3805                  else
   3806                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[14]),1);
   3807                  //HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3808                }
   3809                } 
   3810          }  
   3811          #endif
   3812          
   3813          #if(SENSOR_TYPE ==0X0A)
   3814          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3815                { 
   3816          #if defined( ZigBee_C_R_E_IEEE )
   3817                  char GetExtAddr=0;
   3818            byte * Send_d;
   3819            Send_d=NLME_GetExtAddr();
   3820            for(int i=0;i<8;i++)
   3821            {
   3822            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3823              GetExtAddr++;
   3824            }
   3825               if(GetExtAddr==8)
   3826          #else
   3827               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3828          #endif    
   3829                { //uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   3830                 // T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3831                  GenericApp_applicationdata=0;
   3832                 if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0F))
   3833                {   HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3834                }
   3835                if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0E))
   3836                {   HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3837                }
   3838                } 
   3839          }  
   3840          #endif
   3841          #if(SENSOR_TYPE ==0X86)
   3842          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3843                { 
   3844          #if defined( ZigBee_C_R_E_IEEE )
   3845                  char GetExtAddr=0;
   3846            byte * Send_d;
   3847            Send_d=NLME_GetExtAddr();
   3848            for(int i=0;i<8;i++)
   3849            {
   3850            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3851              GetExtAddr++;
   3852            }
   3853               if(GetExtAddr==8)
   3854          #else
   3855               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3856          #endif    
   3857                { //uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   3858                  T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3859                  GenericApp_applicationdata=0;
   3860                 if((pkt->cmd.Data[11]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[10]==0X0D))
   3861                {
   3862                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[10]+1);
   3863                }
   3864                if((pkt->cmd.Data[11]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[10]==0X0E))
   3865                {
   3866                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[10]+1);
   3867                }
   3868                } 
   3869          }  
   3870          #endif
   3871          #if(SENSOR_TYPE ==0X87)
   3872          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3873                { 
   3874          #if defined( ZigBee_C_R_E_IEEE )
   3875                  char GetExtAddr=0;
   3876            byte * Send_d;
   3877            Send_d=NLME_GetExtAddr();
   3878            for(int i=0;i<8;i++)
   3879            {
   3880            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3881              GetExtAddr++;
   3882            }
   3883               if(GetExtAddr==8)
   3884          #else
   3885               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3886          #endif    
   3887                { //uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   3888                  T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3889                  GenericApp_applicationdata=0;
   3890                  if((pkt->cmd.Data[12]=='{')&&((pkt->cmd.Data[1]-pkt->cmd.Data[11])==0X0E))//07H {M1:00}
   3891                {
   3892                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[12]),pkt->cmd.Data[11]);
   3893                }
   3894                if((pkt->cmd.Data[12]=='{')&&((pkt->cmd.Data[1]-pkt->cmd.Data[11])==0X0F))
   3895                {
   3896                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[12]),pkt->cmd.Data[11]);
   3897                }
   3898                } 
   3899          }  
   3900          #endif
   3901          #if(SENSOR_TYPE ==0X26)
   3902          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3903                { 
   3904          #if defined( ZigBee_C_R_E_IEEE )
   3905                  char GetExtAddr=0;
   3906            byte * Send_d;
   3907            Send_d=NLME_GetExtAddr();
   3908            for(int i=0;i<8;i++)
   3909            {
   3910            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3911              GetExtAddr++;
   3912            }
   3913               if(GetExtAddr==8)
   3914          #else
   3915               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3916          #endif    
   3917                { //uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   3918                  T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3919                  GenericApp_applicationdata=0;
   3920                   if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0F))
   3921                {
   3922                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3923                }
   3924                if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0E))
   3925                {
   3926                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3927                }
   3928                } 
   3929          }  
   3930          #endif
   3931          #if(SENSOR_TYPE ==0X27)
   3932          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3933                { 
   3934          #if defined( ZigBee_C_R_E_IEEE )
   3935                  char GetExtAddr=0;
   3936            byte * Send_d;
   3937            Send_d=NLME_GetExtAddr();
   3938            for(int i=0;i<8;i++)
   3939            {
   3940            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3941              GetExtAddr++;
   3942            }
   3943               if(GetExtAddr==8)
   3944          #else
   3945               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3946          #endif    
   3947                { //uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   3948                  T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3949                  GenericApp_applicationdata=0;
   3950                  SYN_FrameInfo(0,pkt->cmd.Data[11],&pkt->cmd.Data[12],pkt->cmd.Data[1]-0X0E) ;
   3951                //  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3952                  
   3953                } 
   3954          }  
   3955          #endif
   3956          
   3957          #if(SENSOR_TYPE ==0X28)
   3958          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3959                { 
   3960          #if defined( ZigBee_C_R_E_IEEE )
   3961                  char GetExtAddr=0;
   3962            byte * Send_d;
   3963            Send_d=NLME_GetExtAddr();
   3964            for(int i=0;i<8;i++)
   3965            {
   3966            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3967              GetExtAddr++;
   3968            }
   3969               if(GetExtAddr==8)
   3970          #else
   3971               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3972          #endif    
   3973                { //uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   3974                  T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   3975          
   3976                   if((pkt->cmd.Data[9])==0XA1)
   3977                   {LCD_Init();   // LCD初始化
   3978                    LCD_Clear();  // LCD清屏
   3979                    /* 显示信息 */
   3980                    LCD_WriteStringL(0,pkt->cmd.Data[11],&pkt->cmd.Data[12],pkt->cmd.Data[1]-14);
   3981                   }
   3982                 
   3983                  GenericApp_switch=1;
   3984                  GenericApp_SendTheMessage();
   3985                } 
   3986          }  
   3987          #endif
   3988          #if(SENSOR_TYPE ==0X6F)
   3989          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3990                { 
   3991          #if defined( ZigBee_C_R_E_IEEE )
   3992                  char GetExtAddr=0;
   3993            byte * Send_d;
   3994            Send_d=NLME_GetExtAddr();
   3995            for(int i=0;i<8;i++)
   3996            {
   3997            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3998              GetExtAddr++;
   3999            }
   4000               if(GetExtAddr==8)
   4001          #else
   4002               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   4003          #endif    
   4004                { //uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   4005                  T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   4006                   if(((pkt->cmd.Data[10])&0x0F)==0X00)
   4007                   { lcd_txt_clr(); 
   4008                   hzkdis_b(0,&pkt->cmd.Data[12],(pkt->cmd.Data[1]-0X0E)<64? (pkt->cmd.Data[1]-0X0E):64);
   4009                   }
   4010                   if(((pkt->cmd.Data[10])&0x0F)==0X01)
   4011                   { hzkdis_b(1,"                                                2",48);
   4012                   hzkdis_b(1,&pkt->cmd.Data[12],(pkt->cmd.Data[1]-0X0E)<48? (pkt->cmd.Data[1]-0X0E):48);
   4013                   }
   4014                  if(((pkt->cmd.Data[10])&0x0F)==0X02)
   4015                  {hzkdis_b(1,"                                 2",32);
   4016                    hzkdis_b(2,&pkt->cmd.Data[12],(pkt->cmd.Data[1]-0X0E)<32? (pkt->cmd.Data[1]-0X0E):32);
   4017                  }
   4018                  if(((pkt->cmd.Data[10])&0x0F)==0X03)
   4019                  {hzkdis_b(1,"                  2",16);
   4020                    hzkdis_b(3,&pkt->cmd.Data[12],(pkt->cmd.Data[1]-0X0E)<16? (pkt->cmd.Data[1]-0X0E):16);
   4021                  }
   4022                  if(((pkt->cmd.Data[10])&0xF0)==0XA0)
   4023                  SYN_FrameInfo(0,pkt->cmd.Data[11],&pkt->cmd.Data[12],pkt->cmd.Data[1]-0X0E) ;
   4024                //  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   4025                  GenericApp_switch=1;
   4026                  GenericApp_SendTheMessage();
   4027                } 
   4028          }  
   4029          #endif
   4030          #if(SENSOR_TYPE =='P')
   4031              uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   4032          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   4033                { 
   4034          #if defined( ZigBee_C_R_E_IEEE )
   4035                  char GetExtAddr=0;
   4036            byte * Send_d;
   4037            Send_d=NLME_GetExtAddr();
   4038            for(int i=0;i<8;i++)
   4039            {
   4040            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   4041              GetExtAddr++;
   4042            }
   4043               if(GetExtAddr==8)
   4044          #else
   4045               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   4046          #endif    
   4047                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   4048                  GenericApp_applicationbuf=1;
   4049                   hr[3]=pkt->cmd.Data[9];
   4050                    hr[4]=pkt->cmd.Data[10];
   4051                    hr[5]=0x09+hr[3]+hr[4];
   4052                     HalUARTWrite(HAL_UART_PORT_0, hr,8);
   4053                     GenericApp_SendTheMessage();
   4054                } 
   4055                }  
   4056          #endif
   4057          #if(SENSOR_TYPE ==0X02)
   4058              uint8  hr[2]={0XFF,0x10};
   4059          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   4060                { 
   4061          #if defined( ZigBee_C_R_E_IEEE )
   4062                  char GetExtAddr=0;
   4063            byte * Send_d;
   4064            Send_d=NLME_GetExtAddr();
   4065            for(int i=0;i<8;i++)
   4066            {
   4067            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   4068              GetExtAddr++;
   4069            }
   4070               if(GetExtAddr==8)
   4071          #else
   4072               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   4073          #endif    
   4074                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   4075                  if(pkt->cmd.Data[9]==0XDC)
   4076                  { GenericApp_applicationbuf=1;
   4077                   //hr[0]=pkt->cmd.Data[9];
   4078                    hr[0]=pkt->cmd.Data[10];
   4079                    hr[1]=pkt->cmd.Data[11];
   4080                     HalUARTWrite(HAL_UART_PORT_0, hr,1);
   4081                   }
   4082                  GenericApp_SendTheMessage();
   4083                }  
   4084                }  
   4085          #endif
   4086          #if(SENSOR_TYPE =='K')
   4087          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   4088                { 
   4089          #if defined( ZigBee_C_R_E_IEEE )
   4090            char GetExtAddr=0;
   4091            byte * Send_d;
   4092            Send_d=NLME_GetExtAddr();
   4093            for(int i=0;i<8;i++)
   4094            {
   4095            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   4096              GetExtAddr++;
   4097            }
   4098               if(GetExtAddr==8)
   4099          #else
   4100               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   4101          #endif    
   4102                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   4103                  if(pkt->cmd.Data[9]==0xDD)//控制220V继电器
   4104                   {GenericApp_applicationbuf=1;
   4105                     if(pkt->cmd.Data[10]==0x01)  
   4106                      {if(pkt->cmd.Data[11]==0xAA)
   4107                      {P1_0=0;T_MG=0X01; }   //开继电器
   4108                       if(pkt->cmd.Data[11]==0xBB)
   4109                       {P1_0=1; T_MG=0X00; }  //关继电器
   4110                        if(pkt->cmd.Data[11]==0xCC)
   4111                       {P1_0=0; T_MG=0X75; }  //关继电器开 0X75  10秒关闭
   4112                      }
   4113                   }
   4114                  if(pkt->cmd.Data[9]==0xEF)//控制220V继电器
   4115                   {GenericApp_applicationbuf=1;
   4116                     if(pkt->cmd.Data[11]<=0x01)  
   4117                        T_MG=0x0A; //关继电器开  1秒关闭
   4118                     else T_MG=pkt->cmd.Data[11]; //关继电器开  T_MG*80ms关闭
   4119                   if(pkt->cmd.Data[10]==0x01)  
   4120                     P1_0=0; 
   4121                   }
   4122                 if(pkt->cmd.Data[9]==0xCC)//检测设备
   4123                   {
   4124                    GenericApp_applicationbuf=2;
   4125                   }
   4126                  GenericApp_SendTheMessage();
   4127                }
   4128                }  
   4129          #endif  
   4130          #if(SENSOR_TYPE ==0X79)
   4131          
   4132          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   4133                { 
   4134          #if defined( ZigBee_C_R_E_IEEE )
   4135            char GetExtAddr=0;
   4136            byte * Send_d;
   4137            Send_d=NLME_GetExtAddr();
   4138            for(int i=0;i<8;i++)
   4139            {
   4140            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   4141              GetExtAddr++;
   4142            }
   4143               if(GetExtAddr==8)
   4144          #else
   4145               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   4146          #endif    
   4147                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   4148                  if(pkt->cmd.Data[10]==0xDD)//控制
   4149                   {
   4150                     if(pkt->cmd.Data[11]>0)  
   4151                      {
   4152                        switch (pkt->cmd.Data[11]) 
   4153              { case 0X01:if((pkt->cmd.Data[12])&0X01)P1_0=0;else P1_0=1;
   4154                          break;
   4155                case 0X02:if((pkt->cmd.Data[12])&0X02)P1_5=0;else P1_5=1;
   4156                          break;
   4157                case 0X03:if((pkt->cmd.Data[12])&0X01)P1_0=0;else P1_0=1;if((pkt->cmd.Data[12])&0X02)P1_5=0;else P1_5=1;
   4158                          break;
   4159                 default: break;
   4160              }
   4161                      }
   4162                    Send_data[7]=0X02;
   4163                    Send_data[8]=0XDD;
   4164                    Send_data[9]=P1_5;
   4165                     Send_data[9]=~((((Send_data[9]<<1)+P1_0)&0X03)|0XFC);
   4166                    Send_datalend=0x04;
   4167                    GenericApp_SendTheMessage(); //应用函数
   4168                   }
   4169                   if(pkt->cmd.Data[10]==0xD1)//温湿度
   4170                   {PDI=0XD1;
   4171                   }
   4172                   if(pkt->cmd.Data[10]==0xD2)//AD采集
   4173                   {PDI=0XD2;
   4174                   }
   4175                 // GenericApp_SendTheMessage();
   4176                }
   4177                }  
   4178          #endif  
   4179          #if(SENSOR_TYPE ==0X83)
   4180          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   4181                { 
   4182          #if defined( ZigBee_C_R_E_IEEE )
   4183            char GetExtAddr=0;
   4184            byte * Send_d;
   4185            Send_d=NLME_GetExtAddr();
   4186            for(int i=0;i<8;i++)
   4187            {
   4188            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   4189              GetExtAddr++;
   4190            }
   4191               if(GetExtAddr==8)
   4192          #else
   4193               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   4194          #endif    
   4195                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   4196                  if(pkt->cmd.Data[10]==0xDD)//控制220V继电器
   4197                   {GenericApp_applicationbuf=1;
   4198                     if(pkt->cmd.Data[11]>0)  
   4199                      {
   4200                        PDI=((P1&(~(pkt->cmd.Data[11])))|((~((pkt->cmd.Data[11])&(pkt->cmd.Data[12]))))&(pkt->cmd.Data[11]));
   4201                        P1=PDI;
   4202                      }
   4203                   }
   4204                  GenericApp_SendTheMessage();
   4205                }
   4206                }  
   4207          #endif  
   4208          #if(SENSOR_TYPE ==0X40)
   4209          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   4210                { 
   4211          #if defined( ZigBee_C_R_E_IEEE )
   4212            char GetExtAddr=0;
   4213            byte * Send_d;
   4214            Send_d=NLME_GetExtAddr();
   4215            for(int i=0;i<8;i++)
   4216            { 
   4217            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   4218              GetExtAddr++;
   4219            }
   4220               if(GetExtAddr==8)
   4221          #else
   4222               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   4223          #endif    
   4224                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   4225                  if(pkt->cmd.Data[9]==0xDD)//
   4226                   {GenericApp_applicationbuf=1;
   4227                   if(pkt->cmd.Data[10]!=0XB1)T_MG=0X00;
   4228                switch (pkt->cmd.Data[10]) 
   4229              { case 0XA1:if(pkt->cmd.Data[11]==0xAA){ P1_3=0; P1_4=1;  }  //LED1 红色 点亮
   4230                          if(pkt->cmd.Data[11]==0xBB){P1_3=1;P1_4=0;  }  //LED1 红色 熄灭
   4231                          break;
   4232                case 0XA2:if(pkt->cmd.Data[11]==0xAA){P1_2=0; P1_7=1; }   //LED2 蓝色 点亮
   4233                          if(pkt->cmd.Data[11]==0xBB){P1_2=1;P1_7=0;}   //LED2 蓝色 熄灭
   4234                          break;
   4235                case 0XA3: if(pkt->cmd.Data[11]==0xAA){T_MG=0X01;P1_2=1;P1_7=0;}   //LED2熄灭 LED1闪烁功能
   4236                          if(pkt->cmd.Data[11]==0xBB){T_MG=0X00;P1_3=1;P1_4=0;}   //LED1停止闪烁熄灭
   4237                          break;
   4238                case 0XA4:if(pkt->cmd.Data[11]==0xAA){P1_2=1; P1_7=0; P1_3=0; P1_4=1; } //LED1打开，LED2关闭功能
   4239                          if(pkt->cmd.Data[11]==0xBB){P1_2=1; P1_7=0; P1_3=1; P1_4=0;}//LED1，LED2关闭   
   4240                          break;
   4241                case 0XA5:if(pkt->cmd.Data[11]==0xAA){P1_2=0; P1_7=1; P1_3=1; P1_4=0; } //LED2打开，LED1关闭功能
   4242                          if(pkt->cmd.Data[11]==0xBB){P1_2=1; P1_7=0; P1_3=1; P1_4=0;}//LED1，LED2关闭   
   4243                          break;
   4244                case 0XB1:if(pkt->cmd.Data[11]==0xAA){ P1_1=0; P1_0=1;  }   //开蜂鸣器
   4245                            if(pkt->cmd.Data[11]==0xBB){ P1_1=1;P1_0=0;}   //关蜂鸣器
   4246                          break;
   4247                 default: break;}GenericApp_SendTheMessage();
   4248                   } 
   4249                }
   4250          }  
   4251          #endif  
   4252          #if(SENSOR_TYPE ==0X23)
   4253          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   4254                {
   4255          #if defined( ZigBee_C_R_E_IEEE )
   4256                  char GetExtAddr=0;
   4257            byte * Send_d;
   4258            Send_d=NLME_GetExtAddr();
   4259            for(int i=0;i<8;i++)
   4260            {
   4261            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   4262              GetExtAddr++;
   4263            }
   4264               if(GetExtAddr==8)
   4265          #else
   4266               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   4267          #endif    
   4268                {  T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   4269                  if(pkt->cmd.Data[9]==0xAA)//录入
   4270                   { SFG_R30XA[0]=0X01;
   4271                     SFG_R30XA[1]=pkt->cmd.Data[10];  SFG_R30XA[2]=pkt->cmd.Data[11]; 
   4272                     SFG_R30X=1;
   4273                   }
   4274                   if(pkt->cmd.Data[9]==0xBB)//搜索
   4275                   {  SFG_R30XA[0]=0XA1;SFG_R30X=1;
   4276                    }
   4277                    if(pkt->cmd.Data[9]==0xCC)//删除
   4278                   {  SFG_R30XA[0]=0X21;
   4279                    SFG_R30XA[1]=pkt->cmd.Data[10];  SFG_R30XA[2]=pkt->cmd.Data[11]; 
   4280                   SFG_R30X=1;
   4281                   }
   4282                }
   4283                }
   4284          #endif
   4285          #if(SENSOR_TYPE ==0X12)
   4286          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   4287                { 
   4288          #if defined( ZigBee_C_R_E_IEEE )
   4289            char GetExtAddr=0;
   4290            byte * Send_d;
   4291            Send_d=NLME_GetExtAddr();
   4292            for(int i=0;i<8;i++)
   4293            {
   4294            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   4295              GetExtAddr++;
   4296            }
   4297               if(GetExtAddr==8)
   4298          #else
   4299               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   4300          #endif    
   4301                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   4302                  if(pkt->cmd.Data[9]==0xDD)//
   4303                   {GenericApp_applicationbuf=1;
   4304                     if(pkt->cmd.Data[10]==0x01)  
   4305                      {if(pkt->cmd.Data[11]==0xAA)
   4306                         P1_0=0;   //开继电器
   4307                       if(pkt->cmd.Data[11]==0xDD)
   4308                          GenericApp_applicationbuf=6001;
   4309                         
   4310                        P1_7=1;
   4311                        P1_6=0;   //窗帘开
   4312                         GenericApp_BX=0;
   4313                         GenericApp_ON_OFF=0;
   4314                      }
   4315                   }
   4316                  GenericApp_SendTheMessage();
   4317                }
   4318                }  
   4319          #endif  
   4320          #if(SENSOR_TYPE ==0X18)
   4321          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   4322                { 
   4323          #if defined( ZigBee_C_R_E_IEEE )
   4324            char GetExtAddr=0;
   4325            byte * Send_d;
   4326            Send_d=NLME_GetExtAddr();
   4327            for(int i=0;i<8;i++)
   4328            {
   4329            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   4330              GetExtAddr++;
   4331            }
   4332               if(GetExtAddr==8)
   4333          #else
   4334               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   4335          #endif    
   4336                {T_MGSbit|=0X20; //xx1x xxx0 应答 正常 状态位
   4337                  if(pkt->cmd.Data[9]==0xDD)//
   4338                   {GenericApp_applicationbuf=1;
   4339                     if(pkt->cmd.Data[10]==0x01)  
   4340                      {if(pkt->cmd.Data[11]==0xAA)
   4341                          GenericApp_applicationbuf=6001;
   4342                      }
   4343                   }
   4344                 // GenericApp_SendTheMessage();
   4345                }
   4346           
   4347                }  
   4348          #endif 
   4349          #endif  
   4350          }
   \                     ??GenericApp_MessageMSGCB_8:
   \   00018C   02....       LJMP    ?Subroutine2 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   75..00       MOV     ?V0 + 2,#0x0
   \   000003                ; Setup parameters for call to function NLME_GetExtAddr
   \   000003                ; Setup parameters for call to function NLME_GetExtAddr
   \   000003   12....       LCALL   ??NLME_GetExtAddr?relay
   \   000006   8A..         MOV     ?V0 + 0,R2
   \   000008   8B..         MOV     ?V0 + 1,R3
   \   00000A   A8..         MOV     R0,?V0 + 0
   \   00000C   A9..         MOV     R1,?V0 + 1
   \   00000E   75..00       MOV     ?V0 + 0,#0x0
   \   000011   75..00       MOV     ?V0 + 1,#0x0
   \   000014   8E82         MOV     DPL,R6
   \   000016   8F83         MOV     DPH,R7
   \   000018   E0           MOVX    A,@DPTR
   \   000019   FA           MOV     R2,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   FB           MOV     R3,A
   \   00001D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   64FD         XRL     A,#0xfd
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F8           MOV     R0,A
   \   000006   A3           INC     DPTR
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   8882         MOV     DPL,R0
   \   00000B   8983         MOV     DPH,R1
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   E5..         MOV     A,?V0 + 0
   \   000002   2401         ADD     A,#0x1
   \   000004   F5..         MOV     ?V0 + 0,A
   \   000006   E5..         MOV     A,?V0 + 1
   \   000008   3400         ADDC    A,#0x0
   \   00000A   F5..         MOV     ?V0 + 1,A
   \   00000C   C3           CLR     C
   \   00000D   E5..         MOV     A,?V0 + 0
   \   00000F   9408         SUBB    A,#0x8
   \   000011   E5..         MOV     A,?V0 + 1
   \   000013   9400         SUBB    A,#0x0
   \   000015   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000017   65D0         XRL     A,PSW
   \   000019   33           RLC     A
   \   00001A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   E8           MOV     A,R0
   \   000001   FC           MOV     R4,A
   \   000002   E9           MOV     A,R1
   \   000003   FD           MOV     R5,A
   \   000004   8C82         MOV     DPL,R4
   \   000006   8D83         MOV     DPH,R5
   \   000008   A3           INC     DPTR
   \   000009   A882         MOV     R0,DPL
   \   00000B   A983         MOV     R1,DPH
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   25..         ADD     A,?V0 + 0
   \   000015   F5..         MOV     ?V0 + 4,A
   \   000017   E4           CLR     A
   \   000018   35..         ADDC    A,?V0 + 1
   \   00001A   F5..         MOV     ?V0 + 5,A
   \   00001C   EA           MOV     A,R2
   \   00001D   25..         ADD     A,?V0 + 4
   \   00001F   F5..         MOV     ?V0 + 4,A
   \   000021   EB           MOV     A,R3
   \   000022   35..         ADDC    A,?V0 + 5
   \   000024   F5..         MOV     ?V0 + 5,A
   \   000026   74FE         MOV     A,#-0x2
   \   000028   25..         ADD     A,?V0 + 4
   \   00002A   F582         MOV     DPL,A
   \   00002C   74FF         MOV     A,#-0x1
   \   00002E   35..         ADDC    A,?V0 + 5
   \   000030   F583         MOV     DPH,A
   \   000032   E0           MOVX    A,@DPTR
   \   000033   F5..         MOV     ?V0 + 3,A
   \   000035   8C82         MOV     DPL,R4
   \   000037   8D83         MOV     DPH,R5
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   65..         XRL     A,?V0 + 3
   \   00003C   22           RET
   4351          /*********************************************************************
   4352           * @fn      GenericApp_SendTheMessage
   4353           *
   4354           * @brief   Send "the" message.
   4355           *
   4356           * @param   none
   4357           *
   4358           * @return  none
   4359           */
   4360          #if(ZDO_COORDINATOR==2)  //ZIGBEE  AT命令模式 透传模式
   4361          void GenericApp_SendFT( void ) 
   4362          {HalLedSet ( HAL_LED_1, HAL_LED_MODE_ON );
   4363          HalLedSet ( HAL_LED_2, HAL_LED_MODE_ON );
   4364          GenericApp_DstAddr.addr.shortAddr=0XFFFF;
   4365          
   4366            if ( AF_DataRequest( &GenericApp_DstAddr, &GenericApp_epDesc,
   4367                                 GENERICAPP_CLUSTERID,
   4368                                 Send_datalend,
   4369                                 Send_data, 
   4370                                 &GenericApp_TransID,
   4371                                 AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
   4372            {HalLedSet ( HAL_LED_1, HAL_LED_MODE_OFF );
   4373              HalLedSet ( HAL_LED_2, HAL_LED_MODE_OFF );
   4374            }
   4375            
   4376          }
   4377          
   4378          #endif
   4379          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4380          void GenericApp_SendTheMessage( void ) 
   \                     GenericApp_SendTheMessage:
   4381          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   4382            HalLedSet ( HAL_LED_1, HAL_LED_MODE_ON );
   \   000005                ; Setup parameters for call to function HalLedSet
   \   000005   7A01         MOV     R2,#0x1
   \   000007   7901         MOV     R1,#0x1
   \   000009   12....       LCALL   ??HalLedSet?relay
   4383          HalLedSet ( HAL_LED_2, HAL_LED_MODE_ON );
   \   00000C                ; Setup parameters for call to function HalLedSet
   \   00000C   7A01         MOV     R2,#0x1
   \   00000E   7902         MOV     R1,#0x2
   \   000010   12....       LCALL   ??HalLedSet?relay
   4384          #if defined( SENSOR_TYPE_Coord )
   4385          #if defined( ZigBee_C_R_E_Engineering )
   4386          Send_data[4]=NLME_GetShortAddr()/256;
   4387          Send_data[5]=NLME_GetShortAddr()%256;
   4388          #endif 
   4389          #if defined( ZigBee_C_R_E_Transparent )
   4390          GenericApp_DstAddr.addr.shortAddr=0XFFFF;
   4391          #else 
   4392          GenericApp_DstAddr.addrMode = (afAddrMode_t)Addr16Bit;
   4393          GenericApp_DstAddr.addr.shortAddr=(Send_data[2]<<8)+Send_data[3];
   4394          #endif
   4395          Send_data[1]=Send_datalend;
   4396          
   4397            if ( AF_DataRequest( &GenericApp_DstAddr, &GenericApp_epDesc,
   4398                                 GENERICAPP_CLUSTERID,
   4399                                 Send_data[1]+6,
   4400                                 Send_data, 
   4401                                 &GenericApp_TransID,
   4402                                 AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
   4403               { 
   4404               AF_OK=1;
   4405             }
   4406             else  //失败
   4407             { AF_OK=0;
   4408             }
   4409          
   4410            //HalUARTWrite(HAL_UART_PORT_0, Send_data,Send_data[1]+6);
   4411          #else
   4412          int datase = NLME_GetShortAddr();
   \   000013                ; Setup parameters for call to function NLME_GetShortAddr
   \   000013   12....       LCALL   ??NLME_GetShortAddr?relay
   4413           // char theMessageData[] = NLME_GetShortAddr();
   4414          
   4415          #if defined( ZigBee_C_R_E_Transparent )
   4416          GenericApp_DstAddr.addr.shortAddr=0XFFFC; //R C
   \   000016   90....       MOV     DPTR,#GenericApp_DstAddr
   \   000019   74FC         MOV     A,#-0x4
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   74FF         MOV     A,#-0x1
   \   00001F   F0           MOVX    @DPTR,A
   4417          #else 
   4418           GenericApp_DstAddr.addr.shortAddr =NWK_BROADCAST_SHORTADDR_AABB;
   4419          #endif
   4420           Send_data[2]=NLME_GetCoordShortAddr()/256; //父节点地址
   \   000020                ; Setup parameters for call to function NLME_GetCoordShortAddr
   \   000020   12....       LCALL   ??NLME_GetCoordShortAddr?relay
   \   000023   EB           MOV     A,R3
   \   000024   90....       MOV     DPTR,#(Send_data + 2)
   \   000027   F0           MOVX    @DPTR,A
   4421           Send_data[3]=NLME_GetCoordShortAddr()%256; //父节点地址
   \   000028                ; Setup parameters for call to function NLME_GetCoordShortAddr
   \   000028   12....       LCALL   ??NLME_GetCoordShortAddr?relay
   \   00002B   EA           MOV     A,R2
   \   00002C   90....       MOV     DPTR,#(Send_data + 3)
   \   00002F   F0           MOVX    @DPTR,A
   4422          //Send_data[4]= NLME_GetShortAddr()/256;
   4423          //Send_data[5]= NLME_GetShortAddr()%256;
   4424          #if(SENSOR_TYPE =='R')
   4425          Send_datalend=0x03;
   4426          Send_data[6]='R';
   4427          Send_data[7]=0X00;
   4428          Send_data[8]=(Send_data[6]+Send_data[7])%256;
   4429          GenericApp_DstAddr.addrMode = (afAddrMode_t)Addr16Bit;
   4430          GenericApp_DstAddr.addr.shortAddr=0X0000;
   4431          #endif  
   4432          #if((SENSOR_TYPE =='H')||(SENSOR_TYPE ==0X12)||(SENSOR_TYPE ==0X18)||(SENSOR_TYPE ==0X15))
   4433           Send_data[6]=SENSOR_TYPE;//传感器类型 
   4434           if(GenericApp_applicationbuf==0)
   4435           {Send_data[7]=Send_data[8]=Send_data[9]=0XAA;}
   4436            if(GenericApp_applicationbuf==1)
   4437           {Send_data[7]=Send_data[8]=Send_data[9]=0XBB;}
   4438           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4439            GenericApp_applicationbuf=0;
   4440               halMcuWaitMs(280);
   4441          #if(SENSOR_TYPE =='H') 
   4442            P1_6=1;P1_7=1;
   4443          #endif
   4444          #if(SENSOR_TYPE ==0X12) 
   4445            P1_6=1;P1_7=1;
   4446          #endif
   4447            #if(SENSOR_TYPE ==0X15) 
   4448            P1=0X1E;
   4449          #endif
   4450          #endif  
   4451          #if(SENSOR_TYPE ==0X23)
   4452           Send_data[6]=SENSOR_TYPE;//传感器类型 
   4453           if(GenericApp_applicationbuf==0)
   4454           {Send_data[7]=Send_data[8]=Send_data[9]=0XAA;}
   4455           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4456            GenericApp_applicationbuf=0;
   4457          #endif 
   4458            #if(SENSOR_TYPE ==0XA3)
   4459            Send_data[6]=SENSOR_TYPE;//传感器类型 
   4460            if(GenericApp_applicationbuf==0)
   4461            {Send_datalend=0x05;Send_data[7]=Send_data[8]=Send_data[9]=0XAA;
   4462            Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256; }
   4463            if(GenericApp_applicationbuf==1)
   4464            {Send_datalend=0x05;Send_data[7]=Send_data[8]=Send_data[9]=0XBB;
   4465            Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256; }
   4466            if(GenericApp_applicationbuf==2)
   4467            {Send_datalend=0x05;Send_data[7]=0XCC;Send_data[8]=0X03;Send_data[9]=GenericApp_ON_OFF;
   4468            Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256; }
   4469            if(GenericApp_applicationbuf==3)
   4470            {Send_datalend=0x06;
   4471            Send_data[11]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10])%256; }
   4472            GenericApp_applicationbuf=0;
   4473          #endif    
   4474          #if(SENSOR_TYPE ==0X79)
   4475            Send_data[6]=SENSOR_TYPE;//传感器类型 
   4476          #endif  
   4477          #if((SENSOR_TYPE =='K')||(SENSOR_TYPE ==0X83))
   4478           Send_datalend=0x06;  
   4479           Send_data[6]=SENSOR_TYPE;//传感器类型 
   4480           if(GenericApp_applicationbuf==0)
   4481           {Send_data[7]=Send_data[8]=Send_data[9]=0XAA;}
   4482            if(GenericApp_applicationbuf==1)
   4483           {Send_data[7]=Send_data[8]=Send_data[9]=0XBB;}
   4484              if(GenericApp_applicationbuf==2)
   4485            {Send_data[7]=0XCC;Send_data[8]=0X03;Send_data[9]=GenericApp_ON_OFF;}
   4486          #if(SENSOR_TYPE =='K')
   4487           Send_data[10]=T_MG;
   4488          #endif 
   4489          #if(SENSOR_TYPE ==0X83)
   4490           Send_data[10]=~P1;
   4491          #endif 
   4492           Send_data[11]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10])%256;
   4493            GenericApp_applicationbuf=0;
   4494          #endif  
   4495          #if(SENSOR_TYPE ==0X73)
   4496           Send_data[6]=SENSOR_TYPE;//传感器类型 
   4497            if(GenericApp_applicationbuf!=3)
   4498            {
   4499           Send_datalend=0x06;  
   4500           if(GenericApp_applicationbuf==0)
   4501           {Send_data[7]=Send_data[8]=Send_data[9]=0XAA;}
   4502            if(GenericApp_applicationbuf==1)
   4503           {Send_data[7]=Send_data[8]=Send_data[9]=0XBB;}
   4504           Send_data[11]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10])%256;
   4505            }
   4506             GenericApp_applicationbuf=0;
   4507          #endif 
   4508          #if((SENSOR_TYPE =='S')||(SENSOR_TYPE ==0X02)||(SENSOR_TYPE ==0X05)||(SENSOR_TYPE ==0X40)||\
   4509            (SENSOR_TYPE ==0X06)||(SENSOR_TYPE ==0X09)||(SENSOR_TYPE ==0X67)||(SENSOR_TYPE ==0X30)||(SENSOR_TYPE ==0X29))
   4510           Send_data[6]=SENSOR_TYPE;//传感器类型 
   4511           Send_datalend=0x05;  
   4512           if(GenericApp_applicationbuf==0)
   4513           {Send_data[7]=Send_data[8]=Send_data[9]=0XAA;}
   4514            if(GenericApp_applicationbuf==1)
   4515           {Send_data[7]=Send_data[8]=Send_data[9]=0XBB;}
   4516            if(GenericApp_applicationbuf==2)
   4517           {Send_data[7]=Send_data[9]=0XBB;}
   4518           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4519            GenericApp_applicationbuf=0;
   4520          #endif 
   4521          #if((SENSOR_TYPE ==0X65)||(SENSOR_TYPE ==0X66)||(SENSOR_TYPE ==0X6C)||(SENSOR_TYPE ==0X6E))
   4522            Send_data[6]=SENSOR_TYPE;//传感器类型 
   4523           if(GenericApp_switch==0)
   4524           {Send_data[7]=Send_data[8]=Send_data[9]=0XAA;}
   4525            if(GenericApp_switch==1)
   4526           {Send_data[7]=Send_data[8]=Send_data[9]=0XBB;}
   4527           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4528            GenericApp_switch=0;
   4529          #endif 
   4530            
   4531          #if(SENSOR_TYPE ==0X76)
   4532            Send_data[6]=SENSOR_TYPE;//传感器类型 
   4533            
   4534          Send_data[7]=0X00;
   4535           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4536          #endif 
   4537          #if((SENSOR_TYPE ==0X6F)||(SENSOR_TYPE ==0X28))
   4538            Send_data[6]=SENSOR_TYPE;//传感器类型 
   4539           if(GenericApp_switch==0)
   4540           {Send_data[7]=Send_data[8]=Send_data[9]=0XAA;}
   4541            if(GenericApp_switch==1)
   4542           {Send_data[7]=Send_data[8]=Send_data[9]=0XBB;}
   4543           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4544            GenericApp_switch=0;
   4545          #endif 
   4546          #if(SENSOR_TYPE ==0X6A)
   4547            Send_data[6]=SENSOR_TYPE;//传感器类型 
   4548           if(GenericApp_switch==0)
   4549           {Send_data[7]=Send_data[8]=Send_data[9]=0XAA;}
   4550           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4551            GenericApp_switch=0;
   4552          #endif 
   4553          #if((SENSOR_TYPE =='P')||(SENSOR_TYPE ==0X6D))
   4554          Send_data[6]=SENSOR_TYPE;//传感器类型
   4555          Send_datalend=0x05;
   4556           if(GenericApp_applicationbuf==0)
   4557           {Send_data[7]=Send_data[8]=Send_data[9]=0XAA;}
   4558            if(GenericApp_applicationbuf==1)
   4559           {Send_data[7]=Send_data[8]=Send_data[9]=0XBB;}
   4560          
   4561           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4562            GenericApp_applicationbuf=0;
   4563          #endif
   4564           #if((SENSOR_TYPE ==0XF0))
   4565          Send_data[6]=SENSOR_TYPE;//传感器类型
   4566          Send_datalend=0x05;
   4567           if(GenericApp_applicationbuf==0)
   4568           {Send_data[7]=Send_data[8]=Send_data[9]=0XAA;}
   4569            if(GenericApp_applicationbuf==1)
   4570           {Send_data[7]=Send_data[8]=Send_data[9]=0XBB;}
   4571          
   4572           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4573            GenericApp_applicationbuf=0;
   4574          #endif
   4575          #if(SENSOR_TYPE ==0X6B)
   4576          Send_data[6]=SENSOR_TYPE;//传感器类型
   4577          Send_datalend=0x05;
   4578           if(GenericApp_applicationbuf==0)
   4579           {Send_data[7]=Send_data[8]=Send_data[9]=0XAA;}
   4580            if(GenericApp_applicationbuf==1)
   4581           {Send_data[8]=Send_data[9]=0XBB;}
   4582          #if defined(LEDA8)
   4583               Send_data[7]=0XDE;
   4584          #endif
   4585           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4586            GenericApp_applicationbuf=0;
   4587          #endif
   4588          #if(SENSOR_TYPE ==0X25)
   4589          Send_data[6]=SENSOR_TYPE;//传感器类型
   4590           Send_data[7]=0X01;
   4591           Send_data[Send_datalend+6]=0X0F;//校验和
   4592           Send_datalend+=1;  //+校验和
   4593          #endif
   4594           #if(SENSOR_TYPE ==0X7C)
   4595          Send_data[6]=SENSOR_TYPE;//传感器类型
   4596          #endif
   4597          #if(SENSOR_TYPE ==0X7B)
   4598          Send_data[6]=SENSOR_TYPE;//传感器类型
   4599           //Send_data[7]=0X00;
   4600           Send_data[12]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11])%256;
   4601          #endif
   4602           #if(SENSOR_TYPE ==0X71)
   4603          Send_data[6]=SENSOR_TYPE;//传感器类型
   4604           Send_data[7]=0X01;
   4605           Send_data[Send_datalend+6]=0X0F;//校验和
   4606           Send_datalend+=1;  //+校验和
   4607          #endif
   4608           #if(SENSOR_TYPE ==0X70)
   4609          Send_data[6]=SENSOR_TYPE;//传感器类型
   4610           Send_data[7]=0X01;
   4611           Send_data[Send_datalend+6]=0X0F;//校验和
   4612           Send_datalend+=1;  //+校验和
   4613          #endif
   4614           #if(SENSOR_TYPE ==0X86)
   4615          Send_data[6]=SENSOR_TYPE;//传感器类型
   4616           Send_data[7]=0X01;
   4617           Send_data[Send_datalend+6]=0X0F;//校验和
   4618          #endif
   4619           #if(SENSOR_TYPE ==0X87)
   4620          Send_data[6]=SENSOR_TYPE;//传感器类型
   4621           Send_data[7]=0X01; Send_data[8]=0X01;
   4622           Send_data[Send_datalend+6]=0X0F;//校验和
   4623          #endif
   4624          #if(SENSOR_TYPE ==0X26)
   4625          Send_data[6]=SENSOR_TYPE;//传感器类型
   4626           Send_data[7]=0X01;
   4627           Send_data[Send_datalend+6]=0X0F;//校验和
   4628           Send_datalend+=1;
   4629          #endif
   4630           #if(SENSOR_TYPE ==0X27)
   4631          Send_data[6]=SENSOR_TYPE;//传感器类型
   4632           Send_data[8]=0X0F;//校验和
   4633          #endif
   4634          #if(SENSOR_TYPE ==0X07)  
   4635          Send_data[6]=SENSOR_TYPE;//传感器类型
   4636          #if defined(UHF)
   4637          Send_data[7]=0x01; //UHF-  01:命令读卡。B1:主动上传
   4638          if(AB==0X0B)
   4639          Send_data[7]=0xB1; //01:命令读卡。B1:主动上传
   4640          //AB=0X0A;
   4641          #endif
   4642          #if defined(RLM100)
   4643          Send_data[7]=0x02; //RLM100-  02:命令读卡。B2:主动上传
   4644          #if defined(AB)
   4645          Send_data[7]=0xB2; //02:命令读卡。B2:主动上传
   4646          #endif
   4647          #endif
   4648          //Send_data[13]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11]+Send_data[12])%256;
   4649          #endif
   4650          
   4651          #if(SENSOR_TYPE ==0X0E)  
   4652          Send_data[6]=SENSOR_TYPE;//传感器类型
   4653          
   4654          //Send_data[13]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11]+Send_data[12])%256;
   4655          #endif
   4656          #if(SENSOR_TYPE ==0X08)  
   4657          Send_data[6]=SENSOR_TYPE;//传感器类型
   4658          //Send_data[7]=0X01;
   4659          //Send_data[13]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11]+Send_data[12])%256;
   4660          #endif
   4661          #if(SENSOR_TYPE ==0X0D)  
   4662          Send_data[6]=SENSOR_TYPE;//传感器类型
   4663          #endif
   4664          #if((SENSOR_TYPE ==0X0A)||(SENSOR_TYPE ==0X0B)||(SENSOR_TYPE ==0X12)||(SENSOR_TYPE ==0X18)\
   4665            ||(SENSOR_TYPE ==0X14)||(SENSOR_TYPE ==0X74))
   4666          Send_data[6]=SENSOR_TYPE;//传感器类型
   4667          #endif
   4668          #if(SENSOR_TYPE ==0X13)
   4669          #if defined(HUABANG) 
   4670           // Send_data[15]=0;
   4671          float datieee754=0;
   4672          long dat=0;
   4673            datieee754=ieee754()*100;
   4674            dat= (long) datieee754;
   4675            Send_data[15]=dat>>24;Send_data[16]=dat>>16;Send_data[17]=dat>>8;Send_data[18]=dat;
   4676             Send_data[8]=Send_data[9]=Send_data[10]=Send_data[11]=Send_data[12]=0;
   4677             Send_data[13]=Send_data[7];
   4678             Send_data[7]=0XAA;Send_data[14]=0XBB;
   4679          #endif
   4680          Send_data[6]=SENSOR_TYPE;//传感器类型
   4681          #endif
   4682          
   4683          
   4684          #if(SENSOR_TYPE =='G')  
   4685          Send_data[6]=SENSOR_TYPE;//传感器类型
   4686          Send_data[13]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11]+Send_data[12])%256;
   4687          #endif
   4688          
   4689          #if((SENSOR_TYPE =='I')||(SENSOR_TYPE ==0X64)||(SENSOR_TYPE ==0X77))
   4690          Send_data[7]=GenericApp_appIO;
   4691           Send_data[6]=SENSOR_TYPE;//传感器类型
   4692           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4693          
   4694          #endif
   4695          #if((SENSOR_TYPE ==0X10)||(SENSOR_TYPE ==0X0F)||(SENSOR_TYPE ==0X17)||(SENSOR_TYPE ==0X21)||(SENSOR_TYPE ==0X16))
   4696           Send_data[6]=SENSOR_TYPE;//传感器类型
   4697           Send_data[8]=(Send_data[6]+Send_data[7])%256;
   4698          #endif
   4699           #if((SENSOR_TYPE ==0X11)||(SENSOR_TYPE ==0X1A))
   4700           Send_data[6]=SENSOR_TYPE;//传感器类型
   4701           Send_data[9]=(Send_data[6]+Send_data[7]+Send_data[8])%256;
   4702          #endif
   4703          #if(SENSOR_TYPE ==0X20)
   4704           Send_data[6]=SENSOR_TYPE;//传感器类型
   4705           Send_data[7]=Send_data[8];
   4706           Send_data[8]=(Send_data[10]*10+Send_data[11]);
   4707           Send_data[9]=Send_data[12];
   4708           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4709          #endif
   4710          #if(SENSOR_TYPE ==0X24)
   4711            Send_data[6]=SENSOR_TYPE;
   4712             Send_data[7]=0xa1;
   4713            Send_data[8]=CSB_Len_H;
   4714            Send_data[9]=CSB_Len_L;
   4715            Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4716          #endif
   4717            #if(SENSOR_TYPE ==0X80)
   4718            Send_data[6]=SENSOR_TYPE;
   4719             Send_data[7]=0xA1;
   4720            Send_data[8]=0xA2;
   4721            Send_data[9]=0xA3;
   4722             Send_data[10]=CSB_Len_H;
   4723            Send_data[11]=CSB_Len_L;
   4724            Send_data[12]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11])%256;
   4725          #endif
   4726          #if(SENSOR_TYPE ==0X31)
   4727            Send_data[6]=SENSOR_TYPE;//传感器类型 
   \   000030   7431         MOV     A,#0x31
   \   000032   90....       MOV     DPTR,#(Send_data + 6)
   \   000035   F0           MOVX    @DPTR,A
   4728            if(GenericApp_applicationbuf==0)
   \   000036   90....       MOV     DPTR,#GenericApp_applicationbuf
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   7002         JNZ     ??GenericApp_SendTheMessage_0
   \   00003C   A3           INC     DPTR
   \   00003D   E0           MOVX    A,@DPTR
   \                     ??GenericApp_SendTheMessage_0:
   \   00003E   7013         JNZ     ??GenericApp_SendTheMessage_1
   4729            {Send_datalend=0x05;Send_data[7]=Send_data[8]=Send_data[9]=0XAA;
   \   000040   7405         MOV     A,#0x5
   \   000042   90....       MOV     DPTR,#Send_datalend
   \   000045   F0           MOVX    @DPTR,A
   \   000046   74AA         MOV     A,#-0x56
   \   000048   12....       LCALL   ?Subroutine21 & 0xFFFF
   4730            Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256; }
   \                     ??CrossCallReturnLabel_30:
   \   00004B   742F         MOV     A,#0x2f
   \                     ??GenericApp_SendTheMessage_2:
   \   00004D   90....       MOV     DPTR,#(Send_data + 10)
   \   000050   02....       LJMP    ??GenericApp_SendTheMessage_3 & 0xFFFF
   4731            if(GenericApp_applicationbuf==1)
   \                     ??GenericApp_SendTheMessage_1:
   \   000053   90....       MOV     DPTR,#GenericApp_applicationbuf
   \   000056   E0           MOVX    A,@DPTR
   \   000057   6401         XRL     A,#0x1
   \   000059   7002         JNZ     ??GenericApp_SendTheMessage_4
   \   00005B   A3           INC     DPTR
   \   00005C   E0           MOVX    A,@DPTR
   \                     ??GenericApp_SendTheMessage_4:
   \   00005D   700F         JNZ     ??GenericApp_SendTheMessage_5
   4732            {Send_datalend=0x05;Send_data[7]=Send_data[8]=Send_data[9]=0XBB;
   \   00005F   7405         MOV     A,#0x5
   \   000061   90....       MOV     DPTR,#Send_datalend
   \   000064   F0           MOVX    @DPTR,A
   \   000065   74BB         MOV     A,#-0x45
   \   000067   12....       LCALL   ?Subroutine21 & 0xFFFF
   4733            Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256; }
   \                     ??CrossCallReturnLabel_31:
   \   00006A   7462         MOV     A,#0x62
   \   00006C   80DF         SJMP    ??GenericApp_SendTheMessage_2
   4734            if(GenericApp_applicationbuf==2)
   \                     ??GenericApp_SendTheMessage_5:
   \   00006E   90....       MOV     DPTR,#(Send_data + 7)
   \   000071   E0           MOVX    A,@DPTR
   \   000072   F8           MOV     R0,A
   \   000073   90....       MOV     DPTR,#GenericApp_applicationbuf
   \   000076   E0           MOVX    A,@DPTR
   \   000077   6402         XRL     A,#0x2
   \   000079   7002         JNZ     ??GenericApp_SendTheMessage_6
   \   00007B   A3           INC     DPTR
   \   00007C   E0           MOVX    A,@DPTR
   \                     ??GenericApp_SendTheMessage_6:
   \   00007D   7062         JNZ     ??GenericApp_SendTheMessage_7
   4735            {Send_datalend=0x09;Send_data[8]=Uart_Rev_Buff_1[0];Send_data[9]=Uart_Rev_Buff_1[1];Send_data[10]=Uart_Rev_Buff_1[2];
   \   00007F   7409         MOV     A,#0x9
   \   000081   90....       MOV     DPTR,#Send_datalend
   \   000084   F0           MOVX    @DPTR,A
   \   000085   90....       MOV     DPTR,#Uart_Rev_Buff_1
   \   000088   E0           MOVX    A,@DPTR
   \   000089   90....       MOV     DPTR,#(Send_data + 8)
   \   00008C   F0           MOVX    @DPTR,A
   \   00008D   90....       MOV     DPTR,#(Uart_Rev_Buff_1 + 1)
   \   000090   E0           MOVX    A,@DPTR
   \   000091   F5..         MOV     ?V0 + 8,A
   \   000093   90....       MOV     DPTR,#(Send_data + 9)
   \   000096   F0           MOVX    @DPTR,A
   \   000097   90....       MOV     DPTR,#(Uart_Rev_Buff_1 + 2)
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   F5..         MOV     ?V0 + 6,A
   \   00009D   90....       MOV     DPTR,#(Send_data + 10)
   \   0000A0   F0           MOVX    @DPTR,A
   4736           Send_data[11]=Uart_Rev_Buff_1[3];Send_data[12]=Uart_Rev_Buff_1[4];Send_data[13]=Uart_Rev_Buff_1[5];
   \   0000A1   90....       MOV     DPTR,#(Uart_Rev_Buff_1 + 3)
   \   0000A4   E0           MOVX    A,@DPTR
   \   0000A5   F5..         MOV     ?V0 + 4,A
   \   0000A7   90....       MOV     DPTR,#(Send_data + 11)
   \   0000AA   F0           MOVX    @DPTR,A
   \   0000AB   90....       MOV     DPTR,#(Uart_Rev_Buff_1 + 4)
   \   0000AE   E0           MOVX    A,@DPTR
   \   0000AF   F5..         MOV     ?V0 + 2,A
   \   0000B1   90....       MOV     DPTR,#(Send_data + 12)
   \   0000B4   F0           MOVX    @DPTR,A
   \   0000B5   90....       MOV     DPTR,#(Uart_Rev_Buff_1 + 5)
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   F5..         MOV     ?V0 + 0,A
   \   0000BB   90....       MOV     DPTR,#(Send_data + 13)
   \   0000BE   F0           MOVX    @DPTR,A
   4737            Send_data[14]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11]+Send_data[12]+Send_data[13])%256; }
   \   0000BF   90....       MOV     DPTR,#(Send_data + 8)
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   28           ADD     A,R0
   \   0000C4   F8           MOV     R0,A
   \   0000C5   E4           CLR     A
   \   0000C6   3400         ADDC    A,#0x0
   \   0000C8   F9           MOV     R1,A
   \   0000C9   E5..         MOV     A,?V0 + 8
   \   0000CB   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   0000CE   E5..         MOV     A,?V0 + 6
   \   0000D0   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   0000D3   E5..         MOV     A,?V0 + 4
   \   0000D5   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   0000D8   E5..         MOV     A,?V0 + 2
   \   0000DA   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   0000DD   E5..         MOV     A,?V0 + 0
   \   0000DF   8055         SJMP    ??GenericApp_SendTheMessage_8
   4738            if(GenericApp_applicationbuf==3)
   \                     ??GenericApp_SendTheMessage_7:
   \   0000E1   90....       MOV     DPTR,#(Send_data + 8)
   \   0000E4   E0           MOVX    A,@DPTR
   \   0000E5   28           ADD     A,R0
   \   0000E6   F8           MOV     R0,A
   \   0000E7   E4           CLR     A
   \   0000E8   3400         ADDC    A,#0x0
   \   0000EA   F9           MOV     R1,A
   \   0000EB   90....       MOV     DPTR,#(Send_data + 9)
   \   0000EE   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   0000F1   90....       MOV     DPTR,#GenericApp_applicationbuf
   \   0000F4   E0           MOVX    A,@DPTR
   \   0000F5   6403         XRL     A,#0x3
   \   0000F7   7002         JNZ     ??GenericApp_SendTheMessage_9
   \   0000F9   A3           INC     DPTR
   \   0000FA   E0           MOVX    A,@DPTR
   \                     ??GenericApp_SendTheMessage_9:
   \   0000FB   7011         JNZ     ??GenericApp_SendTheMessage_10
   4739            {Send_datalend=0x05;
   \   0000FD   7405         MOV     A,#0x5
   \   0000FF   90....       MOV     DPTR,#Send_datalend
   \   000102   F0           MOVX    @DPTR,A
   4740            Send_data[10]=(Send_data[7]+Send_data[8]+Send_data[9])%256; }
   \   000103   7A00         MOV     R2,#0x0
   \   000105   7B01         MOV     R3,#0x1
   \   000107   12....       LCALL   ?S_DIV_MOD
   \   00010A   EA           MOV     A,R2
   \   00010B   02....       LJMP    ??GenericApp_SendTheMessage_2 & 0xFFFF
   4741            if(GenericApp_applicationbuf==4)
   \                     ??GenericApp_SendTheMessage_10:
   \   00010E   90....       MOV     DPTR,#GenericApp_applicationbuf
   \   000111   E0           MOVX    A,@DPTR
   \   000112   6404         XRL     A,#0x4
   \   000114   7002         JNZ     ??GenericApp_SendTheMessage_11
   \   000116   A3           INC     DPTR
   \   000117   E0           MOVX    A,@DPTR
   \                     ??GenericApp_SendTheMessage_11:
   \   000118   7030         JNZ     ??GenericApp_SendTheMessage_12
   4742            {Send_datalend=0x09;
   \   00011A   7409         MOV     A,#0x9
   \   00011C   90....       MOV     DPTR,#Send_datalend
   \   00011F   F0           MOVX    @DPTR,A
   4743            Send_data[14]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11]+Send_data[12]+Send_data[13])%256; }
   \   000120   90....       MOV     DPTR,#(Send_data + 10)
   \   000123   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   000126   90....       MOV     DPTR,#(Send_data + 11)
   \   000129   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   00012C   90....       MOV     DPTR,#(Send_data + 12)
   \   00012F   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   000132   90....       MOV     DPTR,#(Send_data + 13)
   \   000135   E0           MOVX    A,@DPTR
   \                     ??GenericApp_SendTheMessage_8:
   \   000136   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000139   7431         MOV     A,#0x31
   \   00013B   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   00013E   7A00         MOV     R2,#0x0
   \   000140   7B01         MOV     R3,#0x1
   \   000142   12....       LCALL   ?S_DIV_MOD
   \   000145   EA           MOV     A,R2
   \   000146   90....       MOV     DPTR,#(Send_data + 14)
   \                     ??GenericApp_SendTheMessage_3:
   \   000149   F0           MOVX    @DPTR,A
   4744            GenericApp_applicationbuf=0;
   \                     ??GenericApp_SendTheMessage_12:
   \   00014A   90....       MOV     DPTR,#GenericApp_applicationbuf
   \   00014D   E4           CLR     A
   \   00014E   F0           MOVX    @DPTR,A
   \   00014F   A3           INC     DPTR
   \   000150   F0           MOVX    @DPTR,A
   4745          #endif  
   4746            
   4747           #if(SENSOR_TYPE ==0X03)
   4748           Send_data[6]=SENSOR_TYPE;//传感器类型
   4749           
   4750            Send_data[7]=GenericApp_appIO;
   4751           Send_data[7]=(Send_data[7]|0XA0);
   4752           Send_data[8]=(Send_data[6]+Send_data[7])%256;
   4753          #endif
   4754          #if(SENSOR_TYPE =='T')
   4755            Send_data[6]=SENSOR_TYPE;//传感器类型
   4756          //不要校验和 Send_data[14]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11]+Send_data[12]+Send_data[13])%256;
   4757          #endif
   4758          #if(SENSOR_TYPE =='O')
   4759           Send_data[6]=SENSOR_TYPE;//传感器类型
   4760           Send_data[14]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11]+Send_data[12]+Send_data[13])%256;
   4761          #endif
   4762          #if(SENSOR_TYPE =='D')
   4763                  float OUTRGB = 0.0;
   4764                  unsigned int RGBTEM;
   4765                          OUTRGB=TCS3200(1);
   4766          		//RGBTEM=(uint)(OUTR*OUTRGB);			//转换R	
   4767                          RGBTEM=(uint)(0.1795*OUTRGB);			//转换R	
   4768                          Send_data[7]=RGBTEM;
   4769          //-------------------------------------
   4770          		OUTRGB=TCS3200(2);
   4771          		//RGBTEM= (uint)(OUTG*OUTRGB);
   4772                         RGBTEM= (uint)(0.2614*OUTRGB);
   4773                          Send_data[8]=RGBTEM;
   4774          //--------------------------------
   4775          		OUTRGB=TCS3200(3);
   4776          		//RGBTEM= (uint)(OUTB*OUTRGB);
   4777                          RGBTEM= (uint)(0.1097*OUTRGB);
   4778                          Send_data[9]=RGBTEM;
   4779                          Send_data[6]=SENSOR_TYPE;//传感器类型
   4780                          Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4781                          P1_3=0;
   4782          #endif
   4783          #if(SENSOR_TYPE =='Q')
   4784            Send_data[6]=SENSOR_TYPE;//传感器类型
   4785          #endif
   4786          
   4787          #if(SENSOR_TYPE =='U')
   4788           unsigned int  data;						    
   4789              float Temperature;
   4790                  Temperature = ReadTemperature();        //返回16位二进制数
   4791                  Temperature *= CelsiurPerLSB;		//转换成浮点型温度值(摄氏度)
   4792          Send_data[6]=SENSOR_TYPE;//传感器类型
   4793           data=(unsigned int)(100*Temperature);   
   4794           Send_data[7]=(uint8)(data/ 100);
   4795           Send_data[8]=(uint8)(data % 100);
   4796           Send_data[9]=(Send_data[6]+Send_data[7]+Send_data[8])%256;
   4797          #endif
   4798           
   4799           #if(SENSOR_TYPE =='C')
   4800           Single_Write_(write_1710 ,power_on );
   4801           Single_Write_(write_1710 ,0x52 );
   4802           Single_Write_(write_1710 ,0x78 );
   4803           Single_Write_(write_1710 ,h_resolution_mod );
   4804           halMcuWaitMs(500); //延时
   4805           Send_data[6]=SENSOR_TYPE;//传感器类型
   4806           Send_data[7]=Single_Read_(read_1710);
   4807           //Send_data[8]=Single_Read_(read_1710+1);
   4808           Send_data[8]=(Send_data[6]+Send_data[7])%256;
   4809          halMcuWaitMs(50);//延时
   4810           //data1[0]*256+data1[1];
   4811           Single_Write_(write_1710 ,reset );
   4812           WrToROM(power_down,write_1710,1);
   4813          #endif
   4814          #if(SENSOR_TYPE ==0X33)
   4815           Send_data[6]=SENSOR_TYPE;//传感器类型
   4816            Send_data[7]=0xD1;
   4817           Send_datalend=0x07;
   4818          //B_LUX30_Multiple_read(0X00,&Send_data[8],4);
   4819          Send_data[12]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11])%256;
   4820          #endif
   4821           
   4822           #if(SENSOR_TYPE =='B')
   4823           for(char i=0;i<RawDataLength;i++)
   4824            {
   4825            MMA7660_XYZ_Read_and_Filter();
   4826            }
   4827          Send_data[7]=Xavg8;
   4828          Send_data[8]=Yavg8;
   4829          Send_data[9]=Zavg8;
   4830          mma_delay(30000);
   4831           for(char i=0;i<RawDataLength;i++)
   4832            {
   4833            MMA7660_XYZ_Read_and_Filter();
   4834            }
   4835            if((Send_data[7]-Xavg8>5)||(Send_data[7]-Xavg8<-5))
   4836               Send_data[7]=0;
   4837            if((Send_data[8]-Yavg8>5)||(Send_data[8]-Yavg8<-5))
   4838           Send_data[8]=0;
   4839            if((Send_data[9]-Zavg8>5)||(Send_data[9]-Zavg8<-5))
   4840           Send_data[9]=0;
   4841          
   4842          //Xavg8>0x1f (正负)     
   4843          //(Xavg8&0x1f) (大小)   
   4844          //3(Xavg8&0x1f)/62 (加速度) 
   4845          //6(Xavg8&0x1f)/62 (高度)  
   4846          //6(Xavg8&0x1f)/62 (角度sin)
   4847          Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4848           Send_data[6]=SENSOR_TYPE;//传感器类型
   4849          #endif
   4850          #if(SENSOR_TYPE =='F')
   4851           #if defined(BMP085) 
   4852                float temperature=0;
   4853          	float pressure=0;
   4854                  unsigned int data;
   4855          
   4856                XCLR=1; 
   4857                 mDelay(50); //延时
   4858                 BMP085_sample(0);
   4859                temperature=T;
   4860          	pressure=p;
   4861          	temperature=temperature/10;	//单位：摄氏度
   4862          	pressure=pressure/1000;		//单位：kPa    //30 ... 110KPa（海拔9000米...-500米）
   4863          	mDelay(50); //延时
   4864            Send_data[6]=SENSOR_TYPE;//传感器类型
   4865            data=(uint)(100*temperature);     
   4866            Send_data[7]=(uint8)(data/100);
   4867            Send_data[8]=(uint8)(data%100);
   4868            
   4869            data=(uint)(100*pressure);      
   4870          
   4871            Send_data[9]=(uint8)(data/ 100);
   4872            Send_data[10]=(uint8)(data % 100);
   4873            Send_data[11]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10])%256;
   4874          #endif
   4875            
   4876          #if defined(BMP180) 
   4877                  uint16_t data=0;
   4878            Multiple_Read_BMP180();
   4879             Send_data[6]=SENSOR_TYPE;//传感器类型  
   4880            Send_data[7]=(uint8)(temperature/0x0a);;
   4881            Send_data[8]=(uint8)(temperature%0x0a);
   4882            data=(pressure/0x0a);
   4883            Send_data[9]=(uint8)(data/0x64);
   4884            Send_data[10]=(uint8)(data%0x64);
   4885            Send_data[11]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10])%256;
   4886          #endif
   4887          #endif
   4888          #if(SENSOR_TYPE =='E')
   4889            Send_data[11]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10])%256;
   4890          #endif
   4891          #if(SENSOR_TYPE ==0X85)
   4892            Send_datalend=0x07;
   4893            Send_data[6]=SENSOR_TYPE;//传感器类型
   4894              Send_data[12]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11])%256;
   4895          #endif
   4896          #if(SENSOR_TYPE ==0X82)
   4897              Send_datalend=0x09;  
   4898             Send_data[6]=SENSOR_TYPE;//传感器类型
   4899            Send_data[14]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11]+Send_data[12]+Send_data[13])%256;
   4900          #endif
   4901          #if((SENSOR_TYPE =='A')||(SENSOR_TYPE =='J')||(SENSOR_TYPE =='L')||(SENSOR_TYPE =='M')\
   4902            ||(SENSOR_TYPE =='N')||(SENSOR_TYPE ==0X0C)||(SENSOR_TYPE ==0X19)\
   4903            ||(SENSOR_TYPE ==0X62)||(SENSOR_TYPE ==0X63) ||(SENSOR_TYPE ==0X34)||(SENSOR_TYPE ==0X35)\
   4904              ||(SENSOR_TYPE ==0X36)||(SENSOR_TYPE ==0X37)||(SENSOR_TYPE ==0X38)||(SENSOR_TYPE ==0X39)\
   4905                ||(SENSOR_TYPE ==0X3A)||(SENSOR_TYPE ==0X3E)||(SENSOR_TYPE ==0X3F)||(SENSOR_TYPE ==0X75))
   4906          
   4907           Send_data[6]=SENSOR_TYPE;//传感器类型
   4908           Send_data[9]=(Send_data[6]+Send_data[7]+Send_data[8])%256;
   4909          #endif
   4910           
   4911          #if((SENSOR_TYPE ==0X22)||(SENSOR_TYPE ==0X22))
   4912          Send_data[6]=SENSOR_TYPE;//传感器类型
   4913           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4914          #endif
   4915           
   4916           #if((SENSOR_TYPE ==0X61)||(SENSOR_TYPE ==0X3C))
   4917            Send_datalend=0x04;   
   4918           Send_data[6]=SENSOR_TYPE;//传感器类型
   4919           Send_data[9]=(Send_data[6]+Send_data[7]+Send_data[8])%256;
   4920          #endif
   4921          #if(SENSOR_TYPE ==0X84)
   4922            Send_datalend=0x05;   
   4923           Send_data[6]=SENSOR_TYPE;//传感器类型
   4924           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4925          #endif
   4926           #if(SENSOR_TYPE ==0X3B)
   4927             Send_datalend=0x05;   
   4928           Send_data[6]=SENSOR_TYPE;//传感器类型
   4929           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4930          #endif
   4931          #if(SENSOR_TYPE ==0X78)
   4932           Send_data[6]=SENSOR_TYPE;//传感器类型
   4933          #endif
   4934          #if((SENSOR_TYPE ==0X72)||(SENSOR_TYPE ==0X81)||(SENSOR_TYPE ==0X3D))
   4935           Send_data[6]=SENSOR_TYPE;//传感器类型
   4936          #if defined( SDS011 )
   4937           Send_data[13]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11]+Send_data[12])%256;
   4938          #else
   4939           Send_data[11]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10])%256;
   4940          #endif
   4941           
   4942          #endif
   4943          #if((SENSOR_TYPE ==0X04))
   4944           Send_data[6]=SENSOR_TYPE;//传感器类型
   4945           Send_data[8]=(Send_data[6]+Send_data[7])%256;
   4946           GenericApp_BX=0;
   4947          #endif
   4948          
   4949          #if defined( ZigBee_C_R_E_IEEE )
   4950          ZigBee_C_R_E_Engineering_H();
   \   000151                ; Setup parameters for call to function ZigBee_C_R_E_Engineering_H
   \   000151   12....       LCALL   ??ZigBee_C_R_E_Engineering_H?relay
   4951          #else
   4952          Send_data[1]=Send_datalend;
   4953          #endif
   4954          #if defined( CC2530_V30 )
   4955          for(char i=(Send_data[1]+7);i>5;i--)
   4956          Send_data[i+5]=Send_data[i];
   4957          Send_data[6]=Send_data[7]=Send_data[8]=Send_data[9]=0x0f;
   4958          Send_data[10]=T_MGSbit;
   4959          T_MGSbit&=~0X21; //xx0x xxx0 主动  正常 状态位
   4960             if ( AF_DataRequest( &GenericApp_DstAddr, &GenericApp_epDesc,
   4961                                 GENERICAPP_CLUSTERID,
   4962                                 (Send_data[1]+11),
   4963                                 Send_data,
   4964                                 &GenericApp_TransID,
   4965                                 AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
   4966               { 
   4967               AF_OK=1;
   4968             }
   4969             else  //失败
   4970             { AF_OK=0;
   4971             }
   4972          #else
   4973             if ( AF_DataRequest( &GenericApp_DstAddr, &GenericApp_epDesc,
   4974                                 GENERICAPP_CLUSTERID,
   4975                                 (Send_data[1]+6),
   4976                                 Send_data,
   4977                                 &GenericApp_TransID,
   4978                                 AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
   \   000154                ; Setup parameters for call to function AF_DataRequest
   \   000154   75..1E       MOV     ?V0 + 0,#0x1e
   \   000157   78..         MOV     R0,#?V0 + 0
   \   000159   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00015C   75....       MOV     ?V0 + 0,#(GenericApp_TransID & 0xff)
   \   00015F   75....       MOV     ?V0 + 1,#((GenericApp_TransID >> 8) & 0xff)
   \   000162   78..         MOV     R0,#?V0 + 0
   \   000164   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000167   75....       MOV     ?V0 + 0,#(Send_data & 0xff)
   \   00016A   75....       MOV     ?V0 + 1,#((Send_data >> 8) & 0xff)
   \   00016D   78..         MOV     R0,#?V0 + 0
   \   00016F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000172   90....       MOV     DPTR,#(Send_data + 1)
   \   000175   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   000178   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00017B   75..01       MOV     ?V0 + 0,#0x1
   \   00017E   75..00       MOV     ?V0 + 1,#0x0
   \   000181   78..         MOV     R0,#?V0 + 0
   \   000183   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000186   7920         MOV     R1,#0x20
   \   000188   7C..         MOV     R4,#(GenericApp_epDesc & 0xff)
   \   00018A   7D..         MOV     R5,#((GenericApp_epDesc >> 8) & 0xff)
   \   00018C   7A..         MOV     R2,#(GenericApp_DstAddr & 0xff)
   \   00018E   7B..         MOV     R3,#((GenericApp_DstAddr >> 8) & 0xff)
   \   000190   12....       LCALL   ??AF_DataRequest?relay
   \   000193   7409         MOV     A,#0x9
   \   000195   12....       LCALL   ?DEALLOC_XSTACK8
   \   000198   E9           MOV     A,R1
   \   000199   7004         JNZ     ??GenericApp_SendTheMessage_13
   4979             { 
   4980               AF_OK=1;
   \   00019B   7401         MOV     A,#0x1
   \   00019D   8001         SJMP    ??GenericApp_SendTheMessage_14
   4981             }
   4982             else  //失败
   4983             { AF_OK=0;
   \                     ??GenericApp_SendTheMessage_13:
   \   00019F   E4           CLR     A
   \                     ??GenericApp_SendTheMessage_14:
   \   0001A0   90....       MOV     DPTR,#AF_OK
   \   0001A3   F0           MOVX    @DPTR,A
   4984             }
   4985          
   4986          #endif
   4987          #if defined( CC2530_RF_433M )  
   4988             Send_data[(Send_data[1]+6)]=0x0D;  Send_data[(Send_data[1]+6+1)]=0x0A;
   4989              HalUARTWrite(HAL_UART_PORT_0, Send_data,(Send_data[1]+6+2));
   4990          #endif
   4991          #endif
   4992            HalLedSet ( HAL_LED_1, HAL_LED_MODE_OFF );
   \   0001A4                ; Setup parameters for call to function HalLedSet
   \   0001A4   7A00         MOV     R2,#0x0
   \   0001A6   7901         MOV     R1,#0x1
   \   0001A8   12....       LCALL   ??HalLedSet?relay
   4993            HalLedSet ( HAL_LED_2, HAL_LED_MODE_OFF );
   \   0001AB                ; Setup parameters for call to function HalLedSet
   \   0001AB   7A00         MOV     R2,#0x0
   \   0001AD   7902         MOV     R1,#0x2
   \   0001AF   12....       LCALL   ??HalLedSet?relay
   4994          }
   \   0001B2   7F0A         MOV     R7,#0xa
   \   0001B4   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   90....       MOV     DPTR,#(Send_data + 9)
   \   000003   F0           MOVX    @DPTR,A
   \   000004   90....       MOV     DPTR,#(Send_data + 8)
   \   000007   F0           MOVX    @DPTR,A
   \   000008   90....       MOV     DPTR,#(Send_data + 7)
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   28           ADD     A,R0
   \   000002   F8           MOV     R0,A
   \   000003   E4           CLR     A
   \   000004   39           ADDC    A,R1
   \   000005   F9           MOV     R1,A
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   28           ADD     A,R0
   \   000001   F8           MOV     R0,A
   \   000002   E4           CLR     A
   \   000003   39           ADDC    A,R1
   \   000004   F9           MOV     R1,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   7406         MOV     A,#0x6
   \   000004   28           ADD     A,R0
   \   000005   F5..         MOV     ?V0 + 0,A
   \   000007   E4           CLR     A
   \   000008   3400         ADDC    A,#0x0
   \   00000A   F5..         MOV     ?V0 + 1,A
   \   00000C   78..         MOV     R0,#?V0 + 0
   \   00000E   22           RET
   4995          /*********************************************************************
   4996          *********************************************************************/
   4997          #if defined( SENSOR_TYPE_Coord )
   4998          void GenericAppCoordEB(); //C 事件处理
   4999          void GenericAppCoordEB() //C 事件处理
   5000          {if(AF_RFn)
   5001          {  
   5002               if(GenericApp_ON_OFF>0)GenericApp_ON_OFF--;
   5003                   if(GenericApp_ON_OFF<1)
   5004                   {  
   5005                   GenericApp_DstAddr.addr.shortAddr=0XFFFF;
   5006                  if ( AF_DataRequest( &GenericApp_DstAddr, &GenericApp_epDesc,
   5007                                 GENERICAPP_CLUSTERID,
   5008                                 chnnd[AF_RFnd][2]+6,
   5009                                 &chnnd[AF_RFnd][1], 
   5010                                 &GenericApp_TransID,
   5011                                 AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
   5012                        {
   5013                          //AF_RFn+=16;              
   5014                         // HalUARTWrite(HAL_UART_PORT_0,  &chnnd[AF_RFnd][1],chnnd[AF_RFnd][2]+6);
   5015                          //HalUARTWrite(HAL_UART_PORT_0,  &AF_RFn,1);
   5016                          
   5017                          
   5018                         AF_RFn=0;
   5019                          chnnd[AF_RFnd][0]=0;
   5020                          
   5021                         // AF_RFn--; 
   5022                       //  if(AF_RFn==0){ chnnd[AF_RFnd][0]=0;}//10次全部失败
   5023                        //  HalUARTWrite(HAL_UART_PORT_0,  &chnnd[AF_RFnd][1],chnnd[AF_RFnd][2]+6);
   5024                        // GenericApp_ON_OFF=(4+(10-AF_RFn)*2);
   5025                         
   5026                         // if(AF_RFnds>0)AF_RFnds+1;
   5027                          }
   5028                     else//失败
   5029                     {AF_RFn--; 
   5030                     if(AF_RFn==0){ chnnd[AF_RFnd][0]=0;}//10次全部失败
   5031                      // HalUARTWrite(HAL_UART_PORT_0,  &AF_RFn,1);
   5032                    // halMcuWaitMs(1000+((10-AF_RF)*50));
   5033                       // HalUARTWrite(HAL_UART_PORT_0,  &chnnd[AF_RFnd][1],chnnd[AF_RFnd][2]+6);
   5034                      GenericApp_ON_OFF=(5+(10-AF_RFn)*2);
   5035                     }
   5036                   }
   5037          }
   5038          if( AF_RFn==0)
   5039          {
   5040                       AF_RFnds=0;
   5041                     if(chnnd[1][0]||chnnd[2][0]||chnnd[3][0]||chnnd[4][0])
   5042                       {  if(chnnd[4][0])
   5043                          {AF_RFnds=4;
   5044                           if(chnnd[3][0])
   5045                             {AF_RFnds=3;
   5046                              if(chnnd[2][0])
   5047                             {AF_RFnds=2;
   5048                               if(chnnd[1][0])
   5049                                {AF_RFnds=1;}
   5050                             }
   5051                             }
   5052                          }
   5053                       }
   5054          
   5055            
   5056           if(chnnd[0][0])
   5057           {  AF_RFnd=0;
   5058            if(AF_RFnds!=0)AF_RFnd=AF_RFnds;
   5059            AF_RFn=10;//发送10次
   5060           }
   5061           else
   5062           { if(chnnd[1][0])
   5063              {  AF_RFnd=1; AF_RFn=10;//发送5次
   5064              }
   5065              else
   5066              { if(chnnd[2][0])
   5067                  {  AF_RFnd=2; AF_RFn=10;//发送5次
   5068                  }
   5069                  else
   5070                  { if(chnnd[3][0])
   5071                    {  AF_RFnd=3; AF_RFn=10;//发送5次
   5072                    }
   5073                    else
   5074                    { if(chnnd[4][0])
   5075                      {  AF_RFnd=4; AF_RFn=10;//发送5次
   5076                      }
   5077                    }
   5078                  }
   5079              }
   5080           }
   5081          }
   5082             if(AF_RF==1)//失败标志存储失败数据
   5083             {AF_RF=0;//以开始存储，清0
   5084           
   5085                   if(!chnnd[0][0])
   5086                    {chnnd[0][0]=1;
   5087                     for(char i=0;i<(Send_data[1]+6);i++)
   5088                       {chnnd[0][1+i]=Send_data[i];
   5089                       } 
   5090                    }
   5091                   else
   5092                   {if(!chnnd[1][0])
   5093                     {chnnd[1][0]=1;
   5094                     for(char i=0;i<(Send_data[1]+6);i++)
   5095                       {chnnd[1][1+i]=Send_data[i];
   5096                       } 
   5097                    }
   5098                    else
   5099                    {if(!chnnd[2][0])
   5100                     {chnnd[2][0]=1;
   5101                     for(char i=0;i<(Send_data[1]+6);i++)
   5102                       {chnnd[2][1+i]=Send_data[i];
   5103                       } 
   5104                    }
   5105                     else
   5106                     {if(!chnnd[3][0])
   5107                       {chnnd[3][0]=1;
   5108                     for(char i=0;i<(Send_data[1]+6);i++)
   5109                       {chnnd[3][1+i]=Send_data[i];
   5110                       } 
   5111                    }
   5112                      else
   5113                      {if(!chnnd[4][0])
   5114                        {chnnd[4][0]=1;
   5115                     for(char i=0;i<(Send_data[1]+6);i++)
   5116                       {chnnd[4][1+i]=Send_data[i];
   5117                       } 
   5118                    }
   5119                       else
   5120                        {//不理会 
   5121                        }
   5122                      }
   5123                      
   5124                     }
   5125                    }
   5126                   }
   5127           }
   5128          }
   5129          
   5130          #endif
   5131          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   5132          void GenericAppEndDeviceEB(void) //100MS
   \                     GenericAppEndDeviceEB:
   5133          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV     A,#-0x3
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   5134            if(openoff==0xaa)
   \   00000A   90....       MOV     DPTR,#openoff
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   64AA         XRL     A,#0xaa
   \   000010   6003         JZ      $+5
   \   000012   02....       LJMP    ??GenericAppEndDeviceEB_0 & 0xFFFF
   5135            {
   5136          #if((SENSOR_TYPE =='E')||(SENSOR_TYPE =='B')||(SENSOR_TYPE =='C')||(SENSOR_TYPE =='D')||(SENSOR_TYPE =='F')\
   5137            ||(SENSOR_TYPE =='U')||(SENSOR_TYPE ==0X10)||(SENSOR_TYPE ==0X21)||(SENSOR_TYPE ==0X11)\
   5138              ||(SENSOR_TYPE ==0X0F)||(SENSOR_TYPE ==0X13)||(SENSOR_TYPE ==0X14)||(SENSOR_TYPE ==0X17)\
   5139                ||(SENSOR_TYPE ==0X24)||(SENSOR_TYPE ==0X5A)||(SENSOR_TYPE ==0X5B)||(SENSOR_TYPE ==0X6A)||(SENSOR_TYPE =='A')\
   5140                  ||(SENSOR_TYPE =='J')||(SENSOR_TYPE =='L')||(SENSOR_TYPE =='M')||(SENSOR_TYPE =='N')\
   5141            ||(SENSOR_TYPE ==0X04)||(SENSOR_TYPE ==0X22)||(SENSOR_TYPE ==0X0C)||(SENSOR_TYPE ==0X16)||(SENSOR_TYPE ==0X19)\
   5142              ||(SENSOR_TYPE ==0X61)||(SENSOR_TYPE ==0X62)||(SENSOR_TYPE ==0X63)||(SENSOR_TYPE ==0X1A)||(SENSOR_TYPE ==0X33)\
   5143                ||(SENSOR_TYPE ==0X72) ||(SENSOR_TYPE ==0X34)||(SENSOR_TYPE ==0X35)||(SENSOR_TYPE ==0X36)||(SENSOR_TYPE ==0X37)\
   5144                  ||(SENSOR_TYPE ==0X38)||(SENSOR_TYPE ==0X39)||(SENSOR_TYPE ==0X3A)||(SENSOR_TYPE ==0X80)||(SENSOR_TYPE ==0X3D)\
   5145                    ||(SENSOR_TYPE ==0X81)||(SENSOR_TYPE ==0X82)||(SENSOR_TYPE ==0X3B)||(SENSOR_TYPE ==0X3C)||(SENSOR_TYPE ==0X3E)\
   5146                      ||(SENSOR_TYPE ==0X3F)||(SENSOR_TYPE ==0X84)||(SENSOR_TYPE ==0X85)||(SENSOR_TYPE ==0X75)||(SENSOR_TYPE ==0X78))
   5147          
   5148          #if defined( POWER_SAVING ) //终端使用计数
   5149              GenericApp_applicationbuf+=GenericApp_time; 
   5150          #else
   5151                 if(GenericApp_time==1) //路由启动定时
   5152                  {/* 使能定时器3的溢出中断 */
   5153                  TIMER34_INIT(3);
   5154                   halSetTimer3Period(100);  //100MS
   5155                       T3_t1Val=(10*25);//25s //定时3
   5156                  IEN1 |= (0x01 << 3);             // 使能Timer3的中断T3IE
   5157                  TIMER3_RUN(TRUE); 
   5158                  GenericApp_time=0;
   5159                  }
   5160          #endif 
   5161          #endif   
   5162             
   5163                     
   5164          #if(SENSOR_TYPE ==0XA3)  
   5165                if(AF_RF)
   5166                 {AF_RF=0;Send_data[1]=Send_datalend+8; Send_data[6]=SENSOR_TYPE;//传感器类型 
   5167                  for(char i=0;i<(Send_data[1]+6);i++)
   5168                       {chnndr[i]=Send_data[i];
   5169                       } 
   5170                  AF_RFn=10;//发送10次
   5171                  
   5172                 }
   5173                 if(AF_RFn)
   5174                 { 
   5175                 if(GenericApp_ON_OFF>0)GenericApp_ON_OFF--;
   5176                   if(GenericApp_ON_OFF<1)
   5177                   {
   5178                    GenericApp_DstAddr.addr.shortAddr=0XFFFF;
   5179                if ( AF_DataRequest( &GenericApp_DstAddr, &GenericApp_epDesc,
   5180                                 GENERICAPP_CLUSTERID,
   5181                                 (chnndr[1]+6),
   5182                                 chnndr, 
   5183                                 &GenericApp_TransID,
   5184                                 AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
   5185                    { AF_RFn=0; 
   5186                     // HalUARTWrite(HAL_UART_PORT_0, "0K",2);
   5187                    }
   5188                    else
   5189                     {AF_RFn--; 
   5190                     //HalUARTWrite(HAL_UART_PORT_0, chnndr,chnndr[1]+6);
   5191                      GenericApp_ON_OFF=(6+(10-AF_RFn)*3);
   5192                     }
   5193                   }
   5194                 }   
   5195                 
   5196                 
   5197                 
   5198          #endif 
   5199                 
   5200          #if(SENSOR_TYPE ==0X31) 
   5201                  if(AF_RF)
   \   000015   90....       MOV     DPTR,#AF_RF
   \   000018   E0           MOVX    A,@DPTR
   \   000019   6051         JZ      ??GenericAppEndDeviceEB_1
   5202                 {AF_RF=0;Send_data[1]=Send_datalend+8; Send_data[6]=SENSOR_TYPE;//传感器类型 
   \   00001B   E4           CLR     A
   \   00001C   F0           MOVX    @DPTR,A
   \   00001D   90....       MOV     DPTR,#Send_datalend
   \   000020   E0           MOVX    A,@DPTR
   \   000021   2408         ADD     A,#0x8
   \   000023   FB           MOV     R3,A
   \   000024   90....       MOV     DPTR,#(Send_data + 1)
   \   000027   F0           MOVX    @DPTR,A
   \   000028   7431         MOV     A,#0x31
   \   00002A   90....       MOV     DPTR,#(Send_data + 6)
   \   00002D   F0           MOVX    @DPTR,A
   5203                  for(char i=0;i<(Send_data[1]+6);i++)
   \   00002E   7A00         MOV     R2,#0x0
   5204                       {chnndr[i]=Send_data[i];
   \                     ??GenericAppEndDeviceEB_2:
   \   000030   8A82         MOV     DPL,R2
   \   000032   A882         MOV     R0,DPL
   \   000034   E8           MOV     A,R0
   \   000035   24..         ADD     A,#(Send_data & 0xff)
   \   000037   F582         MOV     DPL,A
   \   000039   E4           CLR     A
   \   00003A   34..         ADDC    A,#((Send_data >> 8) & 0xff)
   \   00003C   F583         MOV     DPH,A
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   C0E0         PUSH    A
   \   000041   E8           MOV     A,R0
   \   000042   24..         ADD     A,#(chnndr & 0xff)
   \   000044   F582         MOV     DPL,A
   \   000046   E4           CLR     A
   \   000047   34..         ADDC    A,#((chnndr >> 8) & 0xff)
   \   000049   F583         MOV     DPH,A
   \   00004B   D0E0         POP     A
   \   00004D   F0           MOVX    @DPTR,A
   5205                       } 
   \   00004E   0A           INC     R2
   \   00004F   8B..         MOV     ?V0 + 2,R3
   \   000051   7406         MOV     A,#0x6
   \   000053   25..         ADD     A,?V0 + 2
   \   000055   F8           MOV     R0,A
   \   000056   E4           CLR     A
   \   000057   3400         ADDC    A,#0x0
   \   000059   F9           MOV     R1,A
   \   00005A   EA           MOV     A,R2
   \   00005B   98           SUBB    A,R0
   \   00005C   E4           CLR     A
   \   00005D   99           SUBB    A,R1
   \   00005E   C3           CLR     C
   \   00005F   65D0         XRL     A,PSW
   \   000061   33           RLC     A
   \   000062   40CC         JC      ??GenericAppEndDeviceEB_2
   5206                  AF_RFn=10;//发送10次
   \   000064   740A         MOV     A,#0xa
   \   000066   90....       MOV     DPTR,#AF_RFn
   \   000069   F0           MOVX    @DPTR,A
   \   00006A   8009         SJMP    ??GenericAppEndDeviceEB_3
   5207                  
   5208                 }
   5209                 if(AF_RFn)
   \                     ??GenericAppEndDeviceEB_1:
   \   00006C   90....       MOV     DPTR,#AF_RFn
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   7003         JNZ     $+5
   \   000072   02....       LJMP    ??GenericAppEndDeviceEB_4 & 0xFFFF
   5210                 { 
   5211                 if(GenericApp_ON_OFF>0)GenericApp_ON_OFF--;
   \                     ??GenericAppEndDeviceEB_3:
   \   000075   90....       MOV     DPTR,#GenericApp_ON_OFF
   \   000078   E0           MOVX    A,@DPTR
   \   000079   7002         JNZ     ??GenericAppEndDeviceEB_5
   \   00007B   A3           INC     DPTR
   \   00007C   E0           MOVX    A,@DPTR
   \                     ??GenericAppEndDeviceEB_5:
   \   00007D   6014         JZ      ??GenericAppEndDeviceEB_6
   5212                   if(GenericApp_ON_OFF<1)
   \   00007F   90....       MOV     DPTR,#GenericApp_ON_OFF
   \   000082   E0           MOVX    A,@DPTR
   \   000083   24FF         ADD     A,#-0x1
   \   000085   F0           MOVX    @DPTR,A
   \   000086   F8           MOV     R0,A
   \   000087   A3           INC     DPTR
   \   000088   E0           MOVX    A,@DPTR
   \   000089   34FF         ADDC    A,#-0x1
   \   00008B   F0           MOVX    @DPTR,A
   \   00008C   F9           MOV     R1,A
   \   00008D   E8           MOV     A,R0
   \   00008E   7001         JNZ     ??GenericAppEndDeviceEB_7
   \   000090   E9           MOV     A,R1
   \                     ??GenericAppEndDeviceEB_7:
   \   000091   7076         JNZ     ??GenericAppEndDeviceEB_4
   5213                   {
   5214                    GenericApp_DstAddr.addr.shortAddr=0XFFFF;
   \                     ??GenericAppEndDeviceEB_6:
   \   000093   90....       MOV     DPTR,#GenericApp_DstAddr
   \   000096   74FF         MOV     A,#-0x1
   \   000098   F0           MOVX    @DPTR,A
   \   000099   A3           INC     DPTR
   \   00009A   F0           MOVX    @DPTR,A
   5215                if ( AF_DataRequest( &GenericApp_DstAddr, &GenericApp_epDesc,
   5216                                 GENERICAPP_CLUSTERID,
   5217                                 (chnndr[1]+6),
   5218                                 chnndr, 
   5219                                 &GenericApp_TransID,
   5220                                 AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
   \   00009B                ; Setup parameters for call to function AF_DataRequest
   \   00009B   75..1E       MOV     ?V0 + 0,#0x1e
   \   00009E   78..         MOV     R0,#?V0 + 0
   \   0000A0   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A3   75....       MOV     ?V0 + 0,#(GenericApp_TransID & 0xff)
   \   0000A6   75....       MOV     ?V0 + 1,#((GenericApp_TransID >> 8) & 0xff)
   \   0000A9   78..         MOV     R0,#?V0 + 0
   \   0000AB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AE   75....       MOV     ?V0 + 0,#(chnndr & 0xff)
   \   0000B1   75....       MOV     ?V0 + 1,#((chnndr >> 8) & 0xff)
   \   0000B4   78..         MOV     R0,#?V0 + 0
   \   0000B6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B9   90....       MOV     DPTR,#(chnndr + 1)
   \   0000BC   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   0000BF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C2   75..01       MOV     ?V0 + 0,#0x1
   \   0000C5   75..00       MOV     ?V0 + 1,#0x0
   \   0000C8   78..         MOV     R0,#?V0 + 0
   \   0000CA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000CD   7920         MOV     R1,#0x20
   \   0000CF   7C..         MOV     R4,#(GenericApp_epDesc & 0xff)
   \   0000D1   7D..         MOV     R5,#((GenericApp_epDesc >> 8) & 0xff)
   \   0000D3   7A..         MOV     R2,#(GenericApp_DstAddr & 0xff)
   \   0000D5   7B..         MOV     R3,#((GenericApp_DstAddr >> 8) & 0xff)
   \   0000D7   12....       LCALL   ??AF_DataRequest?relay
   \   0000DA   7409         MOV     A,#0x9
   \   0000DC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000DF   E9           MOV     A,R1
   \   0000E0   7006         JNZ     ??GenericAppEndDeviceEB_8
   5221                    { AF_RFn=0; 
   \   0000E2   E4           CLR     A
   \   0000E3   90....       MOV     DPTR,#AF_RFn
   \   0000E6   8020         SJMP    ??GenericAppEndDeviceEB_9
   5222                     // HalUARTWrite(HAL_UART_PORT_0, chnndr,chnndr[1]+6);
   5223                    }
   5224                    else
   5225                     {AF_RFn--; 
   \                     ??GenericAppEndDeviceEB_8:
   \   0000E8   90....       MOV     DPTR,#AF_RFn
   \   0000EB   E0           MOVX    A,@DPTR
   \   0000EC   14           DEC     A
   \   0000ED   F0           MOVX    @DPTR,A
   5226                    // HalUARTWrite(HAL_UART_PORT_0, chnndr,chnndr[1]+6);
   5227                      GenericApp_ON_OFF=(6+(10-AF_RFn)*3);
   \   0000EE   F8           MOV     R0,A
   \   0000EF   75F0FD       MOV     B,#-0x3
   \   0000F2   A4           MUL     AB
   \   0000F3   C8           XCH     A,R0
   \   0000F4   AAF0         MOV     R2,B
   \   0000F6   75F0FF       MOV     B,#-0x1
   \   0000F9   A4           MUL     AB
   \   0000FA   2A           ADD     A,R2
   \   0000FB   F9           MOV     R1,A
   \   0000FC   7424         MOV     A,#0x24
   \   0000FE   12....       LCALL   ?Subroutine25 & 0xFFFF
   5228                     }
   5229                   }
   5230                 }
   \                     ??CrossCallReturnLabel_44:
   \   000101   90....       MOV     DPTR,#GenericApp_ON_OFF
   \   000104   E8           MOV     A,R0
   \   000105   F0           MOVX    @DPTR,A
   \   000106   A3           INC     DPTR
   \   000107   E9           MOV     A,R1
   \                     ??GenericAppEndDeviceEB_9:
   \   000108   F0           MOVX    @DPTR,A
   5231                
   5232          #endif 
   5233                 
   5234          #if(SENSOR_TYPE ==0X05)
   5235          if(GenericApp_BX>1)
   5236            GenericApp_BX--;
   5237             else
   5238             {P1_6=0;
   5239              P1_7=0;
   5240             }
   5241          #endif  
   5242          
   5243          #if(SENSOR_TYPE ==0X40)
   5244          if(T_MG==0X01)
   5245          {LED_START++;
   5246          if(LED_START==5){P1_3=0; P1_4=1; }//LED1 红色 点亮
   5247          if(LED_START>10){LED_START=0;P1_3=1; P1_4=0; } //LED1 红色 熄灭
   5248          }
   5249          #endif   
   5250          #if(SENSOR_TYPE ==0X12)
   5251          if(GenericApp_ON_OFF>20)
   5252             {GenericApp_BX++;
   5253             GenericApp_ON_OFF=0;
   5254             }
   5255             else GenericApp_ON_OFF++;
   5256             if(GenericApp_BX>5)
   5257             { P1_0=1;
   5258               P1_6=1;
   5259              P1_7=0;
   5260              halMcuWaitMs(280);
   5261              P1_6=1;
   5262              P1_7=1;
   5263             }
   5264          #endif 
   5265          #if(SENSOR_TYPE ==0X07)
   5266          if(AB==0x0A)
   5267          {
   5268          #if defined(UHF)
   5269          if(GenericApp_ON_OFF>2)
   5270            { //uint8  hr[6]={0XA5,0XFF,0X03,0X92,0X06,0XC0};
   5271              // uint8  hr[6]={0XA5,0XFF,0X03,0XC1,0X04,0X93};
   5272                uint8  hr[6]={0XA5,0XFF,0X03,0XC1,0X06,0X91};
   5273             GenericApp_ON_OFF=0;
   5274             GenericApp_applicationdata=0;
   5275               HalUARTWrite(HAL_UART_PORT_0, hr,6);
   5276             } 
   5277             else GenericApp_ON_OFF++;
   5278          #endif
   5279          #if defined(RLM100)
   5280          if(GenericApp_ON_OFF>0)
   5281            { uint8  hr[11]={0XAA,0X09,0X20,0X00,0X00,0X00,0X00,0X02,0x00,0x04,0x55};
   5282             GenericApp_ON_OFF=0;
   5283             GenericApp_applicationdata=0;
   5284               HalUARTWrite(HAL_UART_PORT_0, hr,11);
   5285             } 
   5286             else GenericApp_ON_OFF++;
   5287          #endif
   5288          }
   5289          #endif
   5290          #if(SENSOR_TYPE ==0X31)
   5291             if(car_op>1) ////可连续读3次时，开始累计计数
   \                     ??GenericAppEndDeviceEB_4:
   \   000109   90....       MOV     DPTR,#car_op
   \   00010C   E0           MOVX    A,@DPTR
   \   00010D   C3           CLR     C
   \   00010E   9402         SUBB    A,#0x2
   \   000110   400A         JC      ??GenericAppEndDeviceEB_10
   5292             {car_op++;
   \   000112   E0           MOVX    A,@DPTR
   \   000113   04           INC     A
   \   000114   F0           MOVX    @DPTR,A
   5293             if(car_op>50)//7秒后。清零，可继续读卡
   \   000115   C3           CLR     C
   \   000116   9433         SUBB    A,#0x33
   \   000118   4002         JC      ??GenericAppEndDeviceEB_10
   5294               car_op=0;
   \   00011A   E4           CLR     A
   \   00011B   F0           MOVX    @DPTR,A
   5295             } 
   5296             if((holzer==0)&&(P1_0==0))holzer=1; //做霍尔定位标志
   \                     ??GenericAppEndDeviceEB_10:
   \   00011C   90....       MOV     DPTR,#holzer
   \   00011F   E0           MOVX    A,@DPTR
   \   000120   7008         JNZ     ??GenericAppEndDeviceEB_11
   \   000122   A290         MOV     C,0x90.0
   \   000124   4045         JC      ??GenericAppEndDeviceEB_0
   \   000126   7401         MOV     A,#0x1
   \   000128   8040         SJMP    ??GenericAppEndDeviceEB_12
   5297             if((holzer==2)&&(P1_0==0))//第二次检测到定位标志
   \                     ??GenericAppEndDeviceEB_11:
   \   00012A   6402         XRL     A,#0x2
   \   00012C   702F         JNZ     ??GenericAppEndDeviceEB_13
   \   00012E   A290         MOV     C,0x90.0
   \   000130   4039         JC      ??GenericAppEndDeviceEB_0
   5298               {holzer=3; 
   \   000132   7403         MOV     A,#0x3
   \   000134   F0           MOVX    @DPTR,A
   5299                uint8 Car_Stop_Buff[3]={0xAA,0x2B,0xBB};
   \   000135   90....       MOV     DPTR,#`?<Constant {170, 43, 187}>`
   \   000138   C082         PUSH    DPL
   \   00013A   85..82       MOV     DPL,?XSP + 0
   \   00013D   85..83       MOV     DPH,?XSP + 1
   \   000140   AC82         MOV     R4,DPL
   \   000142   AD83         MOV     R5,DPH
   \   000144   7583..       MOV     DPH,#((`?<Constant {170, 43, 187}>` >> 8) & 0xff)
   \   000147   D082         POP     DPL
   \   000149   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   5300               HalUARTWrite(HAL_UART_PORT_0,Car_Stop_Buff,3);
   \   00014C                ; Setup parameters for call to function HalUARTWrite
   \   00014C   7C03         MOV     R4,#0x3
   \   00014E   FD           MOV     R5,A
   \   00014F   85..82       MOV     DPL,?XSP + 0
   \   000152   85..83       MOV     DPH,?XSP + 1
   \   000155   AA82         MOV     R2,DPL
   \   000157   AB83         MOV     R3,DPH
   \   000159   F9           MOV     R1,A
   \   00015A   12....       LCALL   ??HalUARTWrite?relay
   5301               }
   5302              if((holzer==3)&&(P1_0==1))//第二次检测到定位标志结束
   \                     ??GenericAppEndDeviceEB_13:
   \   00015D   90....       MOV     DPTR,#holzer
   \   000160   E0           MOVX    A,@DPTR
   \   000161   6403         XRL     A,#0x3
   \   000163   7006         JNZ     ??GenericAppEndDeviceEB_0
   \   000165   A290         MOV     C,0x90.0
   \   000167   5002         JNC     ??GenericAppEndDeviceEB_0
   5303              { holzer=0;}
   \   000169   E4           CLR     A
   \                     ??GenericAppEndDeviceEB_12:
   \   00016A   F0           MOVX    @DPTR,A
   5304          #endif
   5305          #if(SENSOR_TYPE ==0X16)
   5306            if(GenericApp_ON_OFF>50)
   5307             {  GenericApp_ON_OFF=0;
   5308             if((Send_data[7]-GenericApp_appIO>0)||(GenericApp_appIO-Send_data[7]>0)||((GenericApp_appIO==0)&&(Send_data[7])))
   5309             { Send_data[7]=GenericApp_appIO;
   5310              GenericApp_SendTheMessage(); //应用函数
   5311             }GenericApp_appIO=0;
   5312             } 
   5313             else GenericApp_ON_OFF++;
   5314          #endif
   5315          #if(SENSOR_TYPE ==0X08)
   5316             #if defined(TRF7970A) 
   5317              if(GenericApp_ON_OFF==20)
   5318              printf("010A0003041001210000\n"); 
   5319          #endif
   5320             if(GenericApp_ON_OFF==23)
   5321             printf("010C00030410002101060000\n"); //设置 15693卡
   5322             
   5323              if(GenericApp_ON_OFF>30)
   5324              { GenericApp_ON_OFF=25;
   5325             if(GenericApp_BX)
   5326                  printf("0109000304A0010000\n"); //读卡 14443A
   5327              else
   5328                printf("010B000304140701000000\n"); //读卡  15693 
   5329              GenericApp_applicationdata=0;
   5330               //printf("010C00030410002101090000\n"); //设置 14443A卡
   5331              // printf("0109000304A0010000\n"); //读卡
   5332              }
   5333           GenericApp_ON_OFF++;
   5334          #endif
   5335          #if(SENSOR_TYPE ==0X0D)
   5336          #if defined(TGRD15693) 
   5337           
   5338              if(GenericApp_ON_OFF>5)
   5339             {if(!GenericApp_appIO)
   5340             {GenericApp_appIO=1;
   5341             printf(":1601020027EE43\n"); //设置 15693卡
   5342             }
   5343             GenericApp_ON_OFF=0;
   5344             if(GenericApp_BX)
   5345                  printf(":1601020027EE43\n"); //读卡 14443A
   5346              else
   5347                printf(":1601020027EE43\n"); //读卡  15693 
   5348              GenericApp_applicationdata=0;
   5349             } 
   5350             else GenericApp_ON_OFF++;
   5351          #endif
   5352          #if defined(PN532) 
   5353          if(GenericApp_ON_OFF>5)
   5354             {uint8  hr[24]={0X55, 0X55,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0Xff,0X03,0Xfd,0Xd4,0X14,0X01,0X17,0}; 
   5355              uint8 hr1[11]={0,0,0XFF,0X04,0XFC,0XD4,0X4A,0X02,0,0XE0,0};
   5356               if(!GenericApp_appIO)
   5357               {
   5358               GenericApp_appIO=1;
   5359             HalUARTWrite(HAL_UART_PORT_0, hr,24);//初始化PN532到normal状态
   5360             HalUARTWrite(HAL_UART_PORT_0, hr,24);//初始化PN532到normal状态
   5361             }
   5362               GenericApp_ON_OFF=0;
   5363               //  HalUARTWrite(HAL_UART_PORT_0, hr,24);//初始化PN532到normal状态
   5364                HalUARTWrite(HAL_UART_PORT_0, hr1,11); //读卡  M1
   5365              GenericApp_applicationdata=0;
   5366             } 
   5367             else GenericApp_ON_OFF++;
   5368          #endif
   5369          #endif
   5370          #if(SENSOR_TYPE ==0X0B)
   5371             if(GenericApp_ON_OFF>5)
   5372             { uint8  hr[4]={0XF6,0XB9,0X16,0XFE};
   5373             GenericApp_ON_OFF=0;
   5374             GenericApp_applicationdata=0;
   5375               HalUARTWrite(HAL_UART_PORT_0, hr,4);
   5376             } 
   5377             else GenericApp_ON_OFF++;
   5378          #endif
   5379          #if(SENSOR_TYPE ==0X78)
   5380             
   5381          if(GenericApp_applicationbuf>6000)  
   5382           { GenericApp_applicationbuf=0;
   5383           GenericApp_SendTheMessage(); //应用函数
   5384          }
   5385          #endif
   5386          #if(SENSOR_TYPE ==0X72)
   5387           if(((Send_data[8]-T_MUMPT1)>0X05)||((T_MUMPT1-Send_data[8])>0X05)||((Send_data[8]==0)&&(T_MUMPT1!=0)))
   5388            {T_MUMPT1=Send_data[8];
   5389             GenericApp_SendTheMessage(); //应用函数
   5390            }
   5391          
   5392          if(GenericApp_applicationbuf>6000)  
   5393           { GenericApp_applicationbuf=0;
   5394           GenericApp_SendTheMessage(); //应用函数
   5395          }
   5396          #endif
   5397          
   5398          #if((SENSOR_TYPE =='A')||(SENSOR_TYPE =='J')||(SENSOR_TYPE =='L')||(SENSOR_TYPE =='M')||(SENSOR_TYPE =='N')\
   5399            ||(SENSOR_TYPE ==0X22)||(SENSOR_TYPE ==0X0C)||(SENSOR_TYPE ==0X19)\
   5400              ||(SENSOR_TYPE ==0X62)||(SENSOR_TYPE ==0X63) ||(SENSOR_TYPE ==0X34)||(SENSOR_TYPE ==0X35)||(SENSOR_TYPE ==0X36)\
   5401                ||(SENSOR_TYPE ==0X37)||(SENSOR_TYPE ==0X38)||(SENSOR_TYPE ==0X39)||(SENSOR_TYPE ==0X3A)||(SENSOR_TYPE ==0X3E)\
   5402                  ||(SENSOR_TYPE ==0X3F)||(SENSOR_TYPE ==0X75))//开关量定时反馈
   5403          if(GenericApp_ON_OFF>10)
   5404           { GenericApp_ON_OFF=0;
   5405           Send_data[8]=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5406           #if((SENSOR_TYPE =='J') ||(SENSOR_TYPE ==0X34)||(SENSOR_TYPE ==0X35)||(SENSOR_TYPE ==0X36)||(SENSOR_TYPE ==0X37)\
   5407             ||(SENSOR_TYPE ==0X38)||(SENSOR_TYPE ==0X39)||(SENSOR_TYPE ==0X3A)||(SENSOR_TYPE ==0X3E)||(SENSOR_TYPE ==0X75))
   5408            if(Send_data[8]<0X0F)
   5409              Send_data[8]=0;
   5410            else
   5411            if(Send_data[8]<0X15)
   5412              Send_data[8]-=0X0D;
   5413           #endif
   5414            
   5415          #if(SENSOR_TYPE ==0X22)
   5416            //  if(Send_data[8]> T_MUMPTZ1)
   5417             //   T_MUMPTZ1=Send_data[8];
   5418            // Send_data[8]= T_MUMPTZ1-Send_data[8];
   5419          #endif
   5420          #if(SENSOR_TYPE ==0X3F)
   5421           //if(((Send_data[8]-T_MUMPT1)>0X04)||((T_MUMPT1-Send_data[8])>0X04)||((Send_data[8]==0)&&(T_MUMPT1!=0)))
   5422          if((((Send_data[8]>T_MUMPT1)? Send_data[8]-T_MUMPT1:T_MUMPT1-Send_data[8])>0X04) ||((Send_data[8]==0)&&(T_MUMPT1!=0)))
   5423            {T_MUMPT1=Send_data[8];
   5424             GenericApp_SendTheMessage(); //应用函数
   5425            }
   5426          #endif
   5427          #if((SENSOR_TYPE =='J')||(SENSOR_TYPE ==0X62)||(SENSOR_TYPE ==0X63) ||(SENSOR_TYPE ==0X34)\
   5428            ||(SENSOR_TYPE ==0X35)||(SENSOR_TYPE ==0X36)||(SENSOR_TYPE ==0X37)||(SENSOR_TYPE ==0X38)||(SENSOR_TYPE ==0X39)\
   5429              ||(SENSOR_TYPE ==0X3A)||(SENSOR_TYPE ==0X3E)||(SENSOR_TYPE ==0X0C)||(SENSOR_TYPE ==0X75))//开关量定时反馈
   5430          //  if(((Send_data[8]>T_MUMPT1)? Send_data[8]-T_MUMPT1:T_MUMPT1-Send_data[8])>0X04) ||((Send_data[8]==0)&&(T_MUMPT1!=0)))
   5431            if((((Send_data[8]>T_MUMPT1)? Send_data[8]-T_MUMPT1:T_MUMPT1-Send_data[8])>0X0A)||((Send_data[8]==0)&&(T_MUMPT1!=0)))
   5432            {T_MUMPT1=Send_data[8];
   5433             GenericApp_SendTheMessage(); //应用函数
   5434            }
   5435          #endif
   5436          #if((SENSOR_TYPE ==0X22))//开关量定时反馈
   5437           if((((Send_data[8]>T_MUMPT1)? Send_data[8]-T_MUMPT1:T_MUMPT1-Send_data[8])>0X0A)||((Send_data[8]==0)&&(T_MUMPT1!=0)))
   5438            {T_MUMPT1=Send_data[8];
   5439            T_MUMPTS=T_MUMPT1;
   5440             T_MUMPTS=498+(T_MUMPTS*199);
   5441            Send_data[8]=(T_MUMPTS/256);
   5442            Send_data[9]=(T_MUMPTS%256);
   5443            
   5444             GenericApp_SendTheMessage(); //应用函数
   5445            }
   5446          #endif
   5447          
   5448          
   5449           if( GenericApp_sbum!=P2_0)
   5450            {
   5451              GenericApp_sbum=P2_0;
   5452              //Send_data[8]=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5453            if(GenericApp_sbum)Send_data[7]=1;
   5454            else Send_data[7]=0;
   5455             Send_data[8]=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5456            T_MUMPTS=Send_data[8];
   5457              T_MUMPTS=498+(T_MUMPTS*199);
   5458            Send_data[8]=(T_MUMPTS/256);
   5459            Send_data[9]=(T_MUMPTS%256);
   5460            GenericApp_SendTheMessage(); //应用函数
   5461           //  halMcuWaitMs(1000);  //延时 1000ms
   5462            }
   5463           }else GenericApp_ON_OFF++; 
   5464          if(GenericApp_applicationbuf>6000)  
   5465           { GenericApp_applicationbuf=0;
   5466              if(P2_0)
   5467                Send_data[7]=1;
   5468                else Send_data[7]=0;
   5469           Send_data[8]=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5470            T_MUMPTS=Send_data[8];
   5471               T_MUMPTS=498+(T_MUMPTS*199);
   5472            Send_data[8]=(T_MUMPTS/256);
   5473            Send_data[9]=(T_MUMPTS%256);
   5474           GenericApp_SendTheMessage(); //应用函数
   5475          }
   5476          
   5477          #endif
   5478          
   5479          #if((SENSOR_TYPE ==0X61))//开关量定时反馈
   5480          if(LMOUT)
   5481          { if(T_MUMPT1<2) GenericApp_applicationbuf=6001;
   5482          GenericApp_ON_OFF=2;
   5483           Send_data[7]=1; 
   5484          T_MUMPT1=2;
   5485          }
   5486          else 
   5487          if(GenericApp_ON_OFF!=2)
   5488            {GenericApp_ON_OFF=0;}
   5489          
   5490          if(GenericApp_sbum>200)
   5491           { GenericApp_sbum=0;
   5492           if((GenericApp_ON_OFF==0)&&(T_MUMPT1>0))
   5493           { GenericApp_applicationbuf=6001;
   5494             Send_data[7]=0; 
   5495             if(T_MUMPT1>0)T_MUMPT1--;
   5496           }
   5497           if(GenericApp_ON_OFF==2)
   5498           { GenericApp_applicationbuf=6001;
   5499             Send_data[7]=1; 
   5500             GenericApp_ON_OFF=0;
   5501           }
   5502           }else GenericApp_sbum++;
   5503          if(GenericApp_applicationbuf>6000)  
   5504           { GenericApp_applicationbuf=0;
   5505           GenericApp_SendTheMessage(); //应用函数
   5506          }
   5507          #endif
   5508          #if((SENSOR_TYPE ==0X04))
   5509            if( GenericApp_sbum!=P2_0)
   5510            {
   5511              GenericApp_sbum=P2_0; 
   5512              GenericApp_BX++;
   5513            } else
   5514                {
   5515                  if(GenericApp_applicationbuf>0)
   5516                  {GenericApp_applicationbuf+=100;
   5517                  }
   5518                }
   5519            if(GenericApp_BX>5)
   5520            { Send_data[7]=1; 
   5521             GenericApp_applicationbuf=1;
   5522            GenericApp_SendTheMessage(); //应用函数
   5523            }
   5524          if(GenericApp_applicationbuf>6000)  
   5525           { GenericApp_applicationbuf=0;
   5526             Send_data[7]=0; 
   5527           GenericApp_SendTheMessage(); //应用函数
   5528          }
   5529          #endif 
   5530          #if(SENSOR_TYPE ==0X77)
   5531          if(P1_0!=GenericApp_applicationdata)
   5532          {GenericApp_applicationdata=P1_0;
   5533              GenericApp_appIO=0X01;
   5534          }
   5535            if(GenericApp_appIO!=0)
   5536            {
   5537              GenericApp_SendTheMessage(); //应用函数
   5538              GenericApp_appIO=0;
   5539            }
   5540          #endif 
   5541          #if(SENSOR_TYPE =='I')
   5542          unsigned int key=0;
   5543          key=((key+P1)<<4);
   5544          key+=((P0>>1)&0X08);
   5545          key+=(P2&0X07);
   5546          if(key!=GenericApp_applicationdata)
   5547          {GenericApp_applicationdata=key;
   5548              if(P1_0==0)
   5549              GenericApp_appIO=0X03;
   5550              if(P1_1==0)
   5551              GenericApp_appIO=0X0a;
   5552              if(P1_2==0)
   5553              GenericApp_appIO=0X05;
   5554              if(P1_3==0)
   5555              GenericApp_appIO=0X06;
   5556              if(P1_4==0)
   5557              GenericApp_appIO=0X07;
   5558              if(P1_5==0)
   5559              GenericApp_appIO=0X08;
   5560              if(P1_6==0)
   5561              GenericApp_appIO=0X09;
   5562              if(P1_7==0)
   5563              GenericApp_appIO=0X04;
   5564              if(P2_0==0)
   5565              GenericApp_appIO=0X0b;
   5566              if(P2_1==0)
   5567              GenericApp_appIO=0X0c;
   5568              if(P2_2==0)
   5569              GenericApp_appIO=0X0d;
   5570              if(P0_4==0)
   5571              GenericApp_appIO=0X0e;
   5572            } 
   5573              Send_data[8]=0;
   5574              Send_data[8]+=(P1_0+P1_1+P1_2+P1_3+P1_4+P1_5);
   5575            if((GenericApp_appIO!=0)||( Send_data[8]!=Send_data[9]))
   5576            { //人流量统计数量
   5577              Send_data[9]= Send_data[8];
   5578              //人流量统计数量
   5579              GenericApp_SendTheMessage(); //应用函数
   5580              GenericApp_appIO=0;
   5581            }
   5582          #endif
   5583          #if(SENSOR_TYPE ==0X24)
   5584          if(GenericApp_applicationbuf>6000)
   5585          {GenericApp_applicationbuf=0;
   5586            uint8 h=0,l=0,cs,flag=0; //定义变量
   5587            float timer=0,len=0;
   5588            for(cs=0;cs<5;cs++) //连续测五次
   5589            {timer=0;h=0;l=0;len=0;flag=0;       //初始化变量
   5590              P1_2=1;           //拉高触发位
   5591              halMcuWaitUs(20);  //延时 20us
   5592              P1_2=0;           //拉低触发位此时已经发出测试波
   5593              IRCON=0;         //初始化T1定时器
   5594              T1CNTH=0;
   5595              T1CNTL=0;          //写入任意值  H L 清零 0x0000
   5596              while(P1_1==0);  //等待回响信号
   5597              while(P1_1==1)  //收到回响信号时开启定时器
   5598              { if(flag==0)
   5599                {  flag=1;
   5600                  T1CTL = 0x0D;    //设置定时器计数  1/128分频   0X0000-0XFFFF循环计数
   5601                  T1CNTH=0;
   5602                  T1CNTL=0;
   5603                 // T1STAT = 0x21;
   5604                }}
   5605              h=T1CNTH; //回响信号结束时取出定时器的值
   5606              l=T1CNTL; //读取 H 之前必须读取 L ; 
   5607              timer+=(h*256); 
   5608              timer+=l;
   5609              len=(timer*128/(58*2*16))*10; //毫米为单位  计算距离
   5610              halMcuWaitMs(60); //每次测量需要间隔60ms
   5611            } 
   5612            CSB_Len_H=(uint8)(len/256);
   5613            CSB_Len_L=(uint8)((uint16)len%256); 
   5614              GenericApp_SendTheMessage(); //应用函数
   5615            }
   5616          #endif 
   5617          #if(SENSOR_TYPE ==0X80)
   5618          if(P2_0==0)
   5619          {      int pVc=0;
   5620                 pVc=0;
   5621                  IRCON=0;         //初始化T1定时器
   5622                  T1CTL = 0x05;    //设置定时器计数  1/8   0X0000-0XFFFF   一个循环 16ms   1/128=262ms
   5623                  T1CNTL=0;
   5624                  CSB_Len_L=0;  
   5625              while((pVc<400)&&(CSB_Len_L==0))  //测速结束   测试时间超过6s 退出
   5626             {  if(T1IF)
   5627                {pVc++;T1IF=0;}
   5628                 if(P2_0==1)CSB_Len_L=0X01;
   5629             };
   5630             if(pVc<400)  //测试时间超过6s 退出
   5631             {
   5632             pVc=16*pVc;  //单位 ms
   5633              CSB_Len_H=(uint8)(pVc/256);
   5634              CSB_Len_L=(uint8)((uint16)pVc%256); 
   5635              ////////////////////////////////////////////////////////////////////////////////////////////
   5636          //OLED屏显示内容
   5637          //OLED_Init(); //OLED初始化 
   5638          char *s=0;
   5639          sprintf(s, "%05d", pVc); 
   5640          OLED_P8x16Str(0,6,s);//第四行 -- 8x16的显示单元显示ASCII码
   5641          OLED_P8x16Str(40,6,"mS");//第四行 -- 8x16的显示单元显示ASCII码
   5642              GenericApp_SendTheMessage(); //应用函数
   5643             }
   5644          }
   5645          if(GenericApp_applicationbuf>6000)
   5646          {GenericApp_applicationbuf=0;
   5647          GenericApp_SendTheMessage(); //应用函数
   5648          }
   5649          #endif 
   5650          #if(SENSOR_TYPE ==0X64) 
   5651          P1_0=0;P1_2=1;P1_4=1;P1_6=1;
   5652          if(P1_1==0){while(P1_1==0);GenericApp_applicationdata=0X01;}
   5653          if(P1_3==0){while(P1_3==0);GenericApp_applicationdata=0X02;}
   5654          if(P1_5==0){while(P1_5==0);GenericApp_applicationdata=0X03;}
   5655          if(P1_7==0){while(P1_7==0);GenericApp_applicationdata=0X04;}
   5656          P1_0=1;P1_2=0;P1_4=1;P1_6=1;
   5657          if(P1_1==0){while(P1_1==0);GenericApp_applicationdata=0X05;}
   5658          if(P1_3==0){while(P1_3==0);GenericApp_applicationdata=0X06;}
   5659          if(P1_5==0){while(P1_5==0);GenericApp_applicationdata=0X07;}
   5660          if(P1_7==0){while(P1_7==0);GenericApp_applicationdata=0X08;}
   5661          P1_0=1;P1_2=1;P1_4=0;P1_6=1;
   5662          if(P1_1==0){while(P1_1==0);GenericApp_applicationdata=0X09;}
   5663          if(P1_3==0){while(P1_3==0);GenericApp_applicationdata=0X0A;}
   5664          if(P1_5==0){while(P1_5==0);GenericApp_applicationdata=0X0B;}
   5665          if(P1_7==0){while(P1_7==0);GenericApp_applicationdata=0X0C;}
   5666          P1_0=1;P1_2=1;P1_4=1;P1_6=0;
   5667          P1_1=1;
   5668          if(P1_1==0){while(P1_1==0);GenericApp_applicationdata=0X0D;}
   5669          if(P1_3==0){while(P1_3==0);GenericApp_applicationdata=0X0E;}
   5670          if(P1_5==0){while(P1_5==0);GenericApp_applicationdata=0X0F;}
   5671          if(P1_7==0){while(P1_7==0);GenericApp_applicationdata=0X10;}
   5672            if(GenericApp_applicationdata!=0)
   5673            {GenericApp_SendTheMessage(); //应用函数   
   5674              GenericApp_applicationdata=0;
   5675            }
   5676          #endif
   5677          
   5678          /*#if(SENSOR_TYPE =='K')
   5679           if(((~P1)&0X06)!=GenericApp_appIO)
   5680            {
   5681             GenericApp_appIO=((~P1)&0X06);
   5682             GenericApp_ON_OFF=(GenericApp_appIO>>0X01);
   5683             GenericApp_applicationbuf=2;
   5684             GenericApp_SendTheMessage(); //应用函数
   5685            }
   5686          #endif
   5687          */
   5688          
   5689          #if(SENSOR_TYPE =='K')
   5690           if(T_MG>0X01)
   5691            {T_MG--;
   5692            if(T_MG==0X01){P1_0=1; T_MG=0X00;}
   5693            }
   5694          #endif
   5695          #if(SENSOR_TYPE ==0X79)
   5696          if((PDI==0XD1)||(PDI==0XD2))GenericApp_ON_OFF=11;
   5697          if(GenericApp_ON_OFF>10)
   5698           { GenericApp_ON_OFF=0;
   5699           if(ERR_TEMP<5)
   5700           {
   5701           uint  data;
   5702            valuen humi_val,temp_val;							    
   5703            unsigned char error,checksum; 
   5704           error=0;  
   5705                     error+=s_measure( &Send_data[7],&checksum,HUMI);  //measure humidity 
   5706                     error+=s_measure( &Send_data[9],&checksum,TEMP);  //measure temperature 
   5707                     if(error!=0){ s_connectionreset(); ERR_TEMP++;}                 //in case of an error: connection  
   5708                    else 
   5709                    { humi_val.i=Send_data[7]*256+Send_data[8];
   5710                      temp_val.i=Send_data[9]*256+Send_data[10];
   5711                      humi_val.f=(float)humi_val.i;                   //converts integer to float
   5712                      temp_val.f=(float)temp_val.i;                   //converts integer to float
   5713                      calc_dht90(&humi_val.f,&temp_val.f);            //calculate humidity, temperature
   5714            data=(uint)(100*humi_val.f);   
   5715           Send_data[10]=(uint8)(data/ 100);
   5716            data=(uint)(100*temp_val.f);              
   5717            Send_data[9]=(uint8)(data / 100);
   5718                    }
   5719           
   5720          if((((Send_data[9]>T_TEMP)? Send_data[9]-T_TEMP:T_TEMP-Send_data[9])>0X01)||(PDI==0XD1)) //温度值 
   5721            {T_TEMP=Send_data[9];
   5722            Send_data[7]=0X03;
   5723             Send_data[8]=0XD1;
   5724          Send_datalend=0x05;
   5725          GenericApp_SendTheMessage(); //应用函数
   5726            }
   5727            }
   5728            Send_data[9]=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5729          if((((Send_data[9]>T_ADC)? Send_data[9]-T_ADC:T_ADC-Send_data[9])>0X0A)||(PDI==0XD2)) //AD采集数值
   5730            {T_ADC=Send_data[9];
   5731            Send_data[9]=(uint8)(((float)(Send_data[9]*11))/17);
   5732              Send_data[7]=0X03;
   5733             Send_data[8]=0XD2;
   5734             Send_data[10]=(165-Send_data[9]);
   5735          Send_datalend=0x05;
   5736          GenericApp_SendTheMessage(); //应用函数
   5737            }
   5738            PDI=0;
   5739           }else GenericApp_ON_OFF++;
   5740          
   5741          #endif  
   5742          #if(SENSOR_TYPE ==0X83)
   5743          if(GenericApp_ON_OFF>0)
   5744          {GenericApp_ON_OFF=0;
   5745           if(!P0_5)
   5746            {P1_0=~P1_0;//P1_2=~P1_2; 
   5747            while(!P0_5);
   5748            }
   5749          }GenericApp_ON_OFF++;
   5750          #endif
   5751          #if(SENSOR_TYPE ==0X03)
   5752             if(P1_4)
   5753             {
   5754             // if((P1&0X0F)!=GenericApp_appIO)
   5755              {
   5756              GenericApp_appIO=(P1&0X0F);
   5757              GenericApp_SendTheMessage();
   5758               halMcuWaitMs(1000); 
   5759               }
   5760             }
   5761           else 
   5762             if(!(P1&0X0F))
   5763             GenericApp_appIO=0XFF;
   5764          #endif 
   5765          #if(SENSOR_TYPE ==0X10)
   5766          if(GenericApp_applicationbuf>6000)
   5767          {GenericApp_applicationbuf=0;
   5768          GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5769          GenericApp_sbum=(3233/(GenericApp_sbum+3))-11;//GP2Y0A02YKOF (20-150)cm
   5770          Send_data[7]=GenericApp_sbum;
   5771          GenericApp_SendTheMessage();
   5772          } 
   5773          #endif 
   5774          #if(SENSOR_TYPE ==0X0F)
   5775          if(GenericApp_applicationbuf>6000)
   5776          {GenericApp_applicationbuf=0;
   5777          GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5778          
   5779          GenericApp_sbum=((200*GenericApp_sbum)/255);//(0-200)(0-200CM)
   5780          
   5781          Send_data[7]=GenericApp_sbum;
   5782          GenericApp_SendTheMessage();
   5783          } 
   5784          #endif 
   5785          #if(SENSOR_TYPE ==0X17)
   5786          if(GenericApp_ON_OFF>5)
   5787          {GenericApp_ON_OFF=0;
   5788          GenericApp_switch=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);//-0x68;
   5789          if(GenericApp_switch>0x44)
   5790          Send_data[7]=3;
   5791          if(GenericApp_switch<0x45)
   5792          Send_data[7]=2;
   5793          if(GenericApp_switch<0x35)
   5794          Send_data[7]=1;
   5795          if(GenericApp_switch<0x32)
   5796          Send_data[7]=0;
   5797          if(Send_data[7]!=GenericApp_appIO)
   5798          {GenericApp_appIO=Send_data[7];
   5799          GenericApp_switchk2=0;
   5800          }
   5801          else GenericApp_switchk2++;
   5802          if(Send_data[7]==0)
   5803          {
   5804            if(GenericApp_switchk2==10)
   5805          GenericApp_SendTheMessage();
   5806          }
   5807          else
   5808          {
   5809          if(GenericApp_switchk2==2)
   5810          GenericApp_SendTheMessage();
   5811          }
   5812          //Send_data[7]=GenericApp_switch;
   5813          //GenericApp_SendTheMessage();
   5814          
   5815          
   5816          } 
   5817          else GenericApp_ON_OFF++;
   5818          #endif
   5819          #if(SENSOR_TYPE ==0X11) 
   5820          if(GenericApp_applicationbuf>6000)
   5821          {GenericApp_applicationbuf=0;
   5822          GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5823          GenericApp_sbum=((0X15*GenericApp_sbum)/0X17);
   5824          Send_data[7]=GenericApp_sbum;
   5825          Send_data[8]=0XAA;
   5826          GenericApp_SendTheMessage();
   5827          }
   5828          #endif 
   5829          #if((SENSOR_TYPE ==0X1A)) 
   5830          if(GenericApp_ON_OFF>10)
   5831           { GenericApp_ON_OFF=0;
   5832           GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5833            if(((GenericApp_sbum-T_MUMPT1)>0X0A)||((T_MUMPT1-GenericApp_sbum)>0X0A)||((GenericApp_sbum==0)&&(T_MUMPT1!=0)))
   5834            {T_MUMPT1=GenericApp_sbum;
   5835             GenericApp_applicationbuf=6001;
   5836            }
   5837           }else GenericApp_ON_OFF++;
   5838          if(GenericApp_applicationbuf>6000)
   5839          {GenericApp_applicationbuf=0;
   5840          #if(SENSOR_TYPE ==0X1A) 
   5841          GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5842          //GenericApp_sbum=((0X15*GenericApp_sbum)/0X17);
   5843          Send_data[7]=GenericApp_sbum;
   5844          Send_data[8]=0XAA;
   5845          #endif 
   5846          GenericApp_SendTheMessage();
   5847          }
   5848          #endif 
   5849          #if((SENSOR_TYPE ==0X3D)||(SENSOR_TYPE ==0X3B)||(SENSOR_TYPE ==0X3C))
   5850          if(GenericApp_ON_OFF>10)
   5851           { GenericApp_ON_OFF=0;
   5852           GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5853          if(((GenericApp_sbum>T_MUMPT1)? GenericApp_sbum-T_MUMPT1:T_MUMPT1-GenericApp_sbum)>0X0A) 
   5854            {
   5855              T_MUMPT1=GenericApp_sbum;
   5856             GenericApp_applicationbuf=6001;
   5857            }
   5858           }else GenericApp_ON_OFF++;
   5859          if(GenericApp_applicationbuf>6000)
   5860          {GenericApp_applicationbuf=0;
   5861          GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5862          #if(SENSOR_TYPE ==0X3B)            // 不分压直连  UVM-30紫外线 0-1V 
   5863          Send_data[9]=(GenericApp_sbum/4); //单位 UV index
   5864          #endif 
   5865          #if(SENSOR_TYPE ==0X3C)   //SCA60C:N1000060 0-180  0.5-4.5  10K 10K分压  0-180  0.25-2.25V  对应08H-68H 中间平衡34H
   5866          if(GenericApp_sbum>0X5E) Send_data[8]=180; //最大角度180度
   5867          else if(GenericApp_sbum<0X0A) Send_data[8]=0; //最小角度0度
   5868          else if(((GenericApp_sbum>0X34)? GenericApp_sbum-0X34:0X34-GenericApp_sbum)<3) Send_data[8]=90; //平衡点 90度
   5869          else Send_data[8]=((int)(((float)GenericApp_sbum-0x08)*2.1));
   5870          if(Send_data[8]>180)Send_data[8]=180;
   5871          #endif 
   5872          #if(SENSOR_TYPE ==0X3D)
   5873          if(GenericApp_sbum>0x34){Send_data[8]=0X01;GenericApp_sbum=130*(GenericApp_sbum-0X34);}  //正向电流   5V输出 10k 10K分压到2.5V   0X34相当于 0A 1250mV   1=130ma=24mV  185mv=1A
   5874          else {Send_data[8]=0;GenericApp_sbum=130*(0X34-GenericApp_sbum);}
   5875          Send_data[9]=GenericApp_sbum>>8;
   5876          Send_data[10]=GenericApp_sbum;
   5877          #endif 
   5878          GenericApp_SendTheMessage();
   5879          }
   5880          #endif 
   5881          #if(SENSOR_TYPE ==0X84)
   5882          if(GenericApp_ON_OFF>10)
   5883           { GenericApp_ON_OFF=0;
   5884            GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5885             //SCA100T:-D01 0-60度  -D02 0-180度   0.5-4.5  10K 10K分压  0-180  0.25-2.25V  对应00H-63H 中间平衡31H
   5886          if(GenericApp_sbum>0X60) Send_data[8]=60; //最大角度180度
   5887          else if(GenericApp_sbum<0X02) Send_data[8]=0; //最小角度0度
   5888          else if(((GenericApp_sbum>0X31)? GenericApp_sbum-0X31:0X31-GenericApp_sbum)<3) Send_data[8]=30; //平衡点 30度
   5889          else Send_data[8]=((int)((((float)GenericApp_sbum)*60)/0X60));
   5890          if(Send_data[8]>60)Send_data[8]=60;
   5891          //Send_data[8]=GenericApp_sbum;
   5892          
   5893          GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN5, HAL_ADC_RESOLUTION_8);
   5894              //SCA100T:-D01 0-60度  -D02 0-180度   0.5-4.5  10K 10K分压  0-180  0.25-2.25V  对应00H-63H 中间平衡31H
   5895          if(GenericApp_sbum>0X60) Send_data[9]=60; //最大角度180度
   5896          else if(GenericApp_sbum<0X02) Send_data[9]=0; //最小角度0度
   5897          else if(((GenericApp_sbum>0X31)? GenericApp_sbum-0X31:0X31-GenericApp_sbum)<3) Send_data[9]=30; //平衡点 30度
   5898          else Send_data[9]=((int)((((float)GenericApp_sbum)*60)/0X60));
   5899          if(Send_data[9]>60)Send_data[9]=60;
   5900          //Send_data[9]=GenericApp_sbum;
   5901          
   5902          if((Send_data[8]==30)&&(Send_data[9]==30)){P1_1=1; P1_2=1;P1_3=1; P1_4=1;}
   5903          if((Send_data[8]==30)&&(Send_data[9]<30)){P1_1=0; P1_2=0;P1_3=1; P1_4=1;}
   5904          if((Send_data[8]==30)&&(Send_data[9]>30)){P1_1=1; P1_2=1;P1_3=0; P1_4=0;}
   5905          if((Send_data[8]<30)&&(Send_data[9]==30)){P1_1=0; P1_2=1;P1_3=1; P1_4=0;}
   5906          if((Send_data[8]<30)&&(Send_data[9]<30)){P1_1=0; P1_2=0;P1_3=1; P1_4=0;}
   5907          if((Send_data[8]<30)&&(Send_data[9]>30)){P1_1=0; P1_2=1;P1_3=0; P1_4=0;}
   5908          if((Send_data[8]>30)&&(Send_data[9]==30)){P1_1=1; P1_2=0;P1_3=0; P1_4=1;}
   5909          if((Send_data[8]>30)&&(Send_data[9]<30)){P1_1=0; P1_2=0;P1_3=0; P1_4=1;}
   5910          if((Send_data[8]>30)&&(Send_data[9]>30)){P1_1=1; P1_2=0;P1_3=0; P1_4=0;}
   5911          
   5912          GenericApp_sbum=Send_data[8]+Send_data[9];
   5913          if(((GenericApp_sbum>T_MUMPT1)? GenericApp_sbum-T_MUMPT1:T_MUMPT1-GenericApp_sbum)>0X0A) 
   5914            {
   5915              T_MUMPT1=GenericApp_sbum;
   5916             GenericApp_applicationbuf=6001;
   5917            }
   5918           }else GenericApp_ON_OFF++;
   5919          
   5920          if(GenericApp_applicationbuf>6000)
   5921          {GenericApp_applicationbuf=0;
   5922          GenericApp_SendTheMessage();
   5923          }
   5924          #endif 
   5925          #if(SENSOR_TYPE ==0X18)
   5926           if(GenericApp_uart_485==1)
   5927             P1_0=0; 
   5928            if(GenericApp_uart_485==0)
   5929             GenericApp_uart_485=1; 
   5930           if(GenericApp_applicationbuf>6000)
   5931          { P1_0=1; 
   5932           GenericApp_uart_485=0; 
   5933            GenericApp_applicationbuf=0;
   5934           uint8  hr[8]={0xA1,0X04,0X01,0X74,0XD0,0X16,0X0A,0X0D};
   5935           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5936           hr[2]=0x02;hr[4]=0xD3;hr[5]=0x12;
   5937           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5938           hr[2]=0x03;hr[4]=0xd2;hr[5]=0x12;
   5939           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5940            hr[2]=0x04;hr[4]=0xd5;hr[5]=0x0e;
   5941           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5942            hr[2]=0x05;hr[4]=0xD4;hr[5]=0x0E;
   5943           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5944            hr[2]=0x06;hr[4]=0xd7;hr[5]=0x0a;
   5945           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5946            hr[2]=0x07;hr[4]=0xd6;hr[5]=0x0a;
   5947           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5948           hr[2]=0x08;hr[4]=0xd9;hr[5]=0x06;
   5949           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5950            hr[2]=0x09;hr[4]=0xd8;hr[5]=0x06;
   5951           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5952             hr[2]=0x0A;hr[4]=0xdB;hr[5]=0x02;
   5953           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5954            hr[2]=0x0B;hr[4]=0xdA;hr[5]=0x02;
   5955           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5956             hr[2]=0x0C;hr[4]=0xdD;hr[5]=0xFE;
   5957           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5958             hr[2]=0x0D;hr[4]=0xdC;hr[5]=0xFE;
   5959           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5960             hr[2]=0x0E;hr[4]=0xdF;hr[5]=0xFA;
   5961           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5962             hr[2]=0x0F;hr[4]=0xdE;hr[5]=0xFA;
   5963           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5964             GenericApp_SendTheMessage();
   5965          } 
   5966          #endif
   5967          #if((SENSOR_TYPE ==0X5A)||(SENSOR_TYPE ==0X5B))
   5968           if(GenericApp_applicationbuf>6000)
   5969          {
   5970            GenericApp_applicationbuf=0;
   5971             GenericApp_SendTheMessage();
   5972          } 
   5973          if(GenericApp_ON_OFF>10)
   5974           { GenericApp_ON_OFF=0; 
   5975            GenericApp_applicationbuf=0;
   5976           uint8  hr[8]={0x02,0X03,0X00,0X2A,0X00,0X01,0XA5,0XF1};//DMA模式 RS485发送
   5977           HalUARTWrite(HAL_UART_PORT_0, hr,8);//DMA模式 RS485发送最后两字节会丢掉。所以多添加两字节
   5978          }else GenericApp_ON_OFF++;
   5979          #endif
   5980          #if(SENSOR_TYPE ==0X70)
   5981           if(GenericApp_uart_485==1)
   5982             P1_0=0; 
   5983            if(GenericApp_uart_485==0)
   5984             GenericApp_uart_485=1; 
   5985          #endif
   5986          #if(SENSOR_TYPE ==0X13)
   5987          if(GenericApp_applicationbuf>6000)
   5988          {
   5989            GenericApp_applicationbuf=0;
   5990          #if defined(HUABANG) 
   5991           uint8  hr[8]={0xFF,0X03,0X00,0X00,0X00,0X02,0XD1,0XD5};
   5992           HalUARTWrite(HAL_UART_PORT_0, hr,8); 
   5993          #endif
   5994          #if defined(ammeter) 
   5995            uint8  hr[15]={0xFE,0X68,0X99,0X99,0X99,0X99,0X99,0X99,0X68,0X01,0X02,0X43,0XC3,0X6F,0X16};
   5996           HalUARTWrite(HAL_UART_PORT_0, hr,15);    
   5997          #endif
   5998          } 
   5999          #endif
   6000          #if(SENSOR_TYPE ==0X74)
   6001          if(GenericApp_applicationbuf>6000)
   6002          {GenericApp_applicationbuf=0;
   6003           {Send_data[7]=Send_data[8]=Send_data[9]=0XBB;}
   6004           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   6005          GenericApp_SendTheMessage();
   6006          } 
   6007          #endif
   6008          #if(SENSOR_TYPE ==0X14)
   6009          if(GenericApp_applicationbuf>6000)
   6010          {
   6011            GenericApp_applicationbuf=0;
   6012          #if defined(PH_A)
   6013           //uint8  hr[8]={0x01,0x03,0x00,0x00,0x00,0x0C,0xA5,0xE2}; 旧的
   6014           uint8  hr[8]={0x01,0x03,0x00,0x00,0x00,0x0C,0x45,0xCF};// 新的
   6015           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   6016          #endif
   6017          #if defined(PH_ORP)
   6018          uint8  hr[8]={0x00,0x03,0x00,0x00,0x00,0x02,0xC5,0xDA};
   6019          HalUARTWrite(HAL_UART_PORT_0, hr,8);
   6020          #endif
   6021          #if defined(PH_E201C)
   6022            float PH_A2;
   6023          unsigned int  PH;	
   6024          GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN5, HAL_ADC_RESOLUTION_8); //环境温度采集
   6025          Send_data[10]=((GenericApp_sbum*345)/4)>>8;   //LM35 输出0-150mv 硬件放大，软件还原
   6026          Send_data[11]=((GenericApp_sbum*345)/4);
   6027          GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8); //PH采集
   6028          /***********************液体温度18B20采集**************************/
   6029           unsigned int  data;						    
   6030              float Temperature;
   6031                  Temperature = ReadTemperature();        //返回16位二进制数
   6032                  Temperature *= CelsiurPerLSB;		//转换成浮点型温度值(摄氏度)
   6033                   
   6034                  // data=(unsigned int)(100*Temperature);   
   6035                   data=(unsigned int)(Temperature);  
   6036           /***********************液体温度18B20采集**************************/
   6037           /***********************PH温度数据处理**************************/
   6038           PH_A2=((float)(GenericApp_sbum*330)/127.0);  //实际采集数值对应电压值  需实际调整
   6039           PH_A2=PH_A2-87.90;              //采集电压值减去87.90  需实际调整
   6040           PH_A2=1400.0-PH_A2/0.089;              //计算PH值
   6041           PH=(unsigned int)(PH_A2);      //PH值
   6042           if(data<100){if(data>25)PH=PH+(data-25); else PH=PH-(25-data);}//  PH值进行温度补偿
   6043           Send_data[8]=(uint8)(PH>>8);
   6044           Send_data[9]=(uint8)(PH);
   6045           Send_data[7]=0XCC;
   6046           Send_data[12]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11])%256;
   6047          Send_datalend=0X07;
   6048          GenericApp_SendTheMessage();
   6049           /***********************液PH温度数据处理*************************/
   6050           
   6051          #endif 
   6052          } 
   6053          #endif
   6054          #if(SENSOR_TYPE ==0X21)
   6055          if(GenericApp_ON_OFF>10)
   6056           { GenericApp_ON_OFF=0;
   6057           Send_data[7]=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   6058            if(((Send_data[7]-T_MUMPT1)>0X1A)||((T_MUMPT1-Send_data[7])>0X1A)||((Send_data[7]==0)&&(T_MUMPT1!=0)))
   6059            {T_MUMPT1=Send_data[7];
   6060             GenericApp_applicationbuf=6001;
   6061            }
   6062           }else GenericApp_ON_OFF++;
   6063          if(GenericApp_applicationbuf>6000)
   6064          {GenericApp_applicationbuf=0;
   6065          //GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   6066          Send_data[7]=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   6067          GenericApp_SendTheMessage();
   6068          }
   6069          #endif 
   6070          #if(SENSOR_TYPE ==0X66)
   6071          LEDtime++;
   6072          if(LEDtime>0)
   6073          {LEDtime=0;
   6074           switch(LED_HL)					  
   6075            {case 0:LED_HL=1;break; 
   6076            case 1:LED_HL=0;break;
   6077            default:LED_HL=0;break;
   6078            }
   6079           display();      //数码管扫描程序
   6080          }
   6081          #endif 
   6082          #if(SENSOR_TYPE ==0X76)
   6083          if(GenericApp_applicationbuf>300)
   6084          {
   6085          if((!P2_0)&&(0==p))
   6086          {p=1;lens++;
   6087          GenericApp_applicationbuf=0; 
   6088          GenericApp_SendTheMessage();
   6089          }
   6090          halMcuWaitMs(50); 
   6091          if(P2_0){p=0;}
   6092          Send_data[8]=lens/256;
   6093          Send_data[9]=lens%256;
   6094          }
   6095          
   6096          
   6097          if(GenericApp_applicationbuf>10000)
   6098          {GenericApp_applicationbuf=0;
   6099          lens=0;
   6100          }else GenericApp_applicationbuf++;
   6101          #endif 
   6102          
   6103          #if(SENSOR_TYPE =='G')
   6104          if(GenericApp_ON_OFF>90)
   6105           { GenericApp_ON_OFF=0;
   6106           switch(Coil_AB)
   6107            { 
   6108              case 1:Coil_A1;Coil_AB++;break;//通电次序：+A,+B,-A,-B
   6109              case 2:Coil_A2;Coil_AB++;break;
   6110              case 3:Coil_B1;Coil_AB++;break;
   6111              case 4:Coil_B2;Coil_AB=1;break;
   6112              
   6113              case 10:Coil_B2;Coil_AB++;break;//通电次序：+A,+B,-A,-B
   6114              case 11:Coil_B1;Coil_AB++;break;
   6115              case 12:Coil_A2;Coil_AB++;break;
   6116              case 13:Coil_A1;Coil_AB=10;break;
   6117               default:break;
   6118            }		
   6119           }else GenericApp_ON_OFF++;
   6120          #endif 
   6121          #if(SENSOR_TYPE ==0X30)
   6122          if(c68>1)c68--;
   6123          if(c68==1)
   6124          {c68=0;a68=0xab;b68=B01;}
   6125          static unsigned char i;	
   6126          if(P2_0)
   6127          while(b68)
   6128          {
   6129            if(P2_0==0)
   6130            {b68=0;
   6131             switch(a68)
   6132            { 
   6133            case 0XAB:for(int t=0;t<10;t++){Coil_B2;halMcuWaitMs(10);Coil_A2;halMcuWaitMs(10);Coil_B1;halMcuWaitMs(10);Coil_A1;halMcuWaitMs(10);}break;
   6134            case 0XBA:for(int t=0;t<10;t++){Coil_A1;halMcuWaitMs(10);Coil_B1;halMcuWaitMs(10);Coil_A2;halMcuWaitMs(10);Coil_B2;halMcuWaitMs(10);}break;
   6135               default:break;
   6136            }			
   6137            }
   6138            
   6139          halMcuWaitMs(20);
   6140          if((a68==0XAB)&&b68)	//正转标志
   6141          {
   6142            switch(i)
   6143            { 
   6144              case 0:Coil_A1;i++;break;//通电次序：+A,+B,-A,-B
   6145              case 1:Coil_B1;i++;break;
   6146              case 2:Coil_A2;i++;break;
   6147              case 3:Coil_B2;i=0;b68--;break;
   6148               default:break;
   6149            }			
   6150          }  
   6151          else    
   6152            if((a68==0XBA)&&b68)	//反转
   6153            { 
   6154              switch(i)
   6155              {						
   6156              case 0:Coil_B2;i++;break;
   6157              case 1:Coil_A2;i++;break;
   6158              case 2:Coil_B1;i++;break;
   6159              case 3:Coil_A1;i=0;b68--;break;
   6160              default:break;
   6161              }			
   6162            }		
   6163          }
   6164          if(b68==0)Coil_OFF ;
   6165          #endif
   6166          #if(SENSOR_TYPE ==0X73)
   6167          if(P2_0)
   6168          {if(b68)C68=1;
   6169          if((a68==0XAB)&&b68)	//正转标志
   6170          {
   6171           DIR=0;b68-=CP;{CP=~CP; halMcuWaitUs(800);}
   6172          }  
   6173          else    
   6174          if((a68==0XBA)&&b68)	//反转
   6175            { 
   6176           DIR=1;b68-=CP;{CP=~CP; halMcuWaitUs(800);}
   6177            }		
   6178          }
   6179          //else{b68=0;}
   6180           if(P2_0==0)
   6181            {b68=0;
   6182             if(C68)
   6183            {
   6184              halMcuWaitMs(5);
   6185             switch(a68)
   6186            { 
   6187            case 0XAB: DIR=1; for(int i=300;i>0;i--){CP=~CP; halMcuWaitUs(1500);}Send_data[10]=0XAB; GenericApp_applicationbuf=1; GenericApp_SendTheMessage(); break;
   6188            case 0XBA: DIR=0; for(int i=300;i>0;i--){CP=~CP; halMcuWaitUs(1500);}Send_data[10]=0XBA;  GenericApp_applicationbuf=1;GenericApp_SendTheMessage(); break;
   6189               default:break;
   6190            }C68=0;		
   6191            }
   6192            }
   6193          if(b68==0) 
   6194          {DIR=1;CP=1;}
   6195          #endif
   6196          #if(SENSOR_TYPE ==0X6A)
   6197          #if defined(HX711P) 
   6198          if(GenericApp_ON_OFF>10)
   6199           { GenericApp_ON_OFF=0;
   6200           AD_filter();//AD和滤波
   6201           if((AD_Compar&0x800000)!=0x800000)
   6202           {
   6203                   AD_Compar=  AD_Compar/2;//求体重//壳体测试
   6204                   AD_Compar=  AD_Compar-Send_data[7];
   6205                  
   6206           }
   6207           else AD_Compar=0;
   6208           
   6209            Send_data[8]=AD_Compar/256;
   6210            Send_data[9]=AD_Compar%256;
   6211          
   6212          if(((Send_data[9]-T_MUMPT1)>0X50)||((T_MUMPT1-Send_data[9])>0X50)||((Send_data[9]==0)&&(T_MUMPT1!=0)))//
   6213            {T_MUMPT1=Send_data[9];
   6214             GenericApp_applicationbuf=6001;
   6215            }
   6216           }else GenericApp_ON_OFF++;
   6217          #endif 
   6218          if(GenericApp_applicationbuf>6000)
   6219          {GenericApp_applicationbuf=1;
   6220          GenericApp_switch=2;
   6221          #if defined(ADCP) 
   6222          Send_data[8]=0;
   6223          //GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   6224          Send_data[9]=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8)-Send_data[7];
   6225          #endif 
   6226          GenericApp_SendTheMessage();
   6227          }
   6228          #endif 
   6229          #if(SENSOR_TYPE ==0X23)
   6230             if(GenericApp_ON_OFF>1)
   6231             {GenericApp_ON_OFF=0;
   6232               if(SFG_R30X)
   6233             { char DD[17]={0xEF,0x01,0xFF,0xFF,0xFF,0xFF,0x01,0x00,0x08,0x04,0x01,0x00,0x00,0x00,0xFF,0x01,0x0D}; 
   6234                 SFG_R30X=0;
   6235               if(SFG_R30XA[0]==0x01)
   6236                 { 
   6237                     DD[8]=0x03;DD[9]=0X01;DD[10]=0X00 ;DD[11]=0X05;       //录入图像
   6238                     HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,12);
   6239                  }
   6240                    if(SFG_R30XA[0]==0x02)
   6241                 { 
   6242                     DD[8]=0x04;DD[9]=0X02;DD[10]=0X01 ;DD[11]=0X00;DD[12]=0X08; //生成特征1
   6243                   HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,13);
   6244                 }
   6245                 if(SFG_R30XA[0]==0x03)
   6246                 {  
   6247                     DD[8]=0x03;DD[9]=0X01;DD[10]=0X00 ;DD[11]=0X05;       //录入图像
   6248                     HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,12);
   6249                  }
   6250                  if(SFG_R30XA[0]==0x04)
   6251                 { 
   6252                     DD[8]=0x04;DD[9]=0X02;DD[10]=0X02 ;DD[11]=0X00; DD[12]=0X09; //生成特征2
   6253                     HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,13);
   6254                 }
   6255                  if(SFG_R30XA[0]==0x05)
   6256                 {
   6257                     DD[8]=0x03;DD[9]=0X05;DD[10]=0X00 ;DD[11]=0X09;  //合并特征
   6258                      HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,12);
   6259                 }
   6260                  if(SFG_R30XA[0]==0x06)
   6261                 { 
   6262                     DD[8]=0x06;DD[9]=0X06;DD[10]=0X02 ;DD[11]=SFG_R30XA[1]; DD[12]=SFG_R30XA[2]; //DD[13]=0X00;DD[14]=0X10;//存储特征
   6263                     DD[13]=(1+DD[8]+DD[9]+DD[10]+DD[11]+DD[12])/256;  DD[14]=(1+DD[8]+DD[9]+DD[10]+DD[11]+DD[12])%256;
   6264                     HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,15);
   6265                   }
   6266                   if(SFG_R30XA[0]==0xA1)//搜索
   6267                   { DD[8]=0x03;DD[9]=0X01;DD[10]=0X00 ;DD[11]=0X05;       //录入图像
   6268                     HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,12);
   6269                   }
   6270                    if(SFG_R30XA[0]==0xA2)
   6271                    { DD[8]=0x04;DD[9]=0X02;DD[10]=0X01 ;DD[11]=0X00;DD[12]=0X08; //生成特征1
   6272                     HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,13);
   6273                    }
   6274                     if(SFG_R30XA[0]==0xA3)
   6275                     {
   6276                     DD[8]=0x08;DD[9]=0X04;DD[10]=0X01 ;DD[11]=0X00; DD[12]=0X00; DD[13]=0X00;DD[14]=0XFF;DD[15]=0X01;DD[16]=0X0D;//对比图像
   6277                     HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,17);
   6278                     }
   6279                  if(SFG_R30XA[0]==0x21)
   6280                  {
   6281                    if((SFG_R30XA[1]==0xFF)&&(SFG_R30XA[2]==0xFF))//清空指纹库
   6282                    {
   6283                    DD[8]=0x03;DD[9]=0X0D;DD[10]=0X00 ;DD[11]=0X11;       
   6284                     HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,12);
   6285                     }
   6286                    else
   6287                    {DD[8]=0x07;DD[9]=0X0c;DD[10]=SFG_R30XA[1] ;DD[11]=SFG_R30XA[2]; DD[12]=0x00;DD[13]=0x01; //清空指纹库
   6288                    DD[14]=(2+DD[8]+DD[9]+DD[10]+DD[11]+DD[12])/256;  DD[15]=(2+DD[8]+DD[9]+DD[10]+DD[11]+DD[12])%256;
   6289                    HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,16);
   6290                    }
   6291                  }
   6292                  if(SFG_R30XA[0]==0xBB)
   6293                 {GenericApp_applicationbuf=1;
   6294                  Send_data[7]=0XAA;
   6295                 Send_data[8]=SFG_R30XA[1];Send_data[9]=SFG_R30XA[2];
   6296                   GenericApp_SendTheMessage();
   6297                   }
   6298                if(SFG_R30XA[0]==0xDD)
   6299                 {GenericApp_applicationbuf=1;
   6300                  Send_data[7]=0XCC;
   6301                 Send_data[8]=SFG_R30XA[1];Send_data[9]=SFG_R30XA[2];
   6302                   GenericApp_SendTheMessage();
   6303                   }
   6304                    if(SFG_R30XA[0]==0xCC)
   6305                 {  GenericApp_applicationbuf=1;
   6306                  Send_data[7]=0XBB;
   6307                   GenericApp_SendTheMessage();
   6308                   SFG_R30XA[0]=0xA1;SFG_R30X=1;
   6309                   }
   6310                   }
   6311             }
   6312             else GenericApp_ON_OFF++;
   6313          #endif
   6314          #if(SENSOR_TYPE =='Q')
   6315           if(GenericApp_ON_OFF>2)
   6316           { GenericApp_ON_OFF=0;
   6317           if( HXS>0X00)//屏幕固定数值闪烁
   6318           {        // for(char p=0;p<3;p++)
   6319              HXtime++;
   6320                     if(HXS>0X02)
   6321                      {
   6322                       if(HXtime==1)
   6323                        Ht1621WrAllData(0,Ht1621Tab,9);//清除1621寄存器数据，暨清屏 //SEG0～SEG17 COM0-3=0X00 0000 全灭
   6324                       if(HXtime>2)
   6325                       { {HXtime=0;HXS--;}
   6326                        P1_0=0;
   6327          #if defined(SHINING75MIL) 
   6328                        Ht1621WrOneData(9,0X01); //KG
   6329                      if(((AD_Compar/100)%10)!=0)
   6330                      { if(AD_Compar/1000)
   6331                         Ht1621WrOneData(1,(table2[(AD_Compar/100)%10])|0x01);//SEG2 COM0-3=table2[9]=0X0D 1101 数字9  |百位1
   6332                         else
   6333                         Ht1621WrOneData(1,table2[(AD_Compar/100)%10]);//SEG2 COM0-3=table2[9]=0X0D 1101 数字9
   6334                         
   6335                         Ht1621WrOneData(0,table1[(AD_Compar/100)%10]);//SEG1 COM0-3=table1[9]=0X0E 1110 数字9
   6336                      }
   6337                        Ht1621WrOneData(2,table1[(AD_Compar/10)%10]);//SEG1 COM0-3=table1[9]=0X0E 1110 数字9
   6338                        Ht1621WrOneData(3,table2[(AD_Compar/10)%10]|0X01);//SEG2 COM0-3=table2[9]=0X0D 1101 数字9
   6339                        Ht1621WrOneData(4,table1[(AD_Compar%10)]);//SEG1 COM0-3=table1[9]=0X0E 1110 数字9
   6340                        if(PAN_ID_Success==2)
   6341                        Ht1621WrOneData(5,(table2[(AD_Compar%10)])|0X01);//SEG2 COM0-3=table2[9]=0X0D 1101 数字9 | M 添加网络显示M
   6342                        else
   6343                        Ht1621WrOneData(5,table2[(AD_Compar%10)]);//SEG2 COM0-3=table2[9]=0X0D 1101 数字9
   6344                        
   6345                        Ht1621WrOneData(6,table1[0]);//SEG1 COM0-3=table1[9]=0X0E 1110 数字9
   6346                        Ht1621WrOneData(7,table2[0]);//SEG2 COM0-3=table2[9]=0X0D 1101 数字9
   6347          #endif
   6348          #if defined(SHINING100MIL)  
   6349          Ht1621WrOneData(8,0X0C); //公斤
   6350           if(PAN_ID_Success==2)
   6351                        {
   6352                        Ht1621WrOneData(0,table1[AD_Compar/1000]);//SEG1 COM0-3=table1[9]=0X0E 1110 数字9
   6353                        Ht1621WrOneData(1,table2[AD_Compar/1000]);//SEG2 COM0-3=table2[9]=0X0D 1101 数字9
   6354                        }
   6355                        Ht1621WrOneData(2,table1[(AD_Compar/100)%10]);//SEG1 COM0-3=table1[9]=0X0E 1110 数字9
   6356                        Ht1621WrOneData(3,table2[(AD_Compar/100)%10]);//SEG2 COM0-3=table2[9]=0X0D 1101 数字9
   6357                        Ht1621WrOneData(4,table1[(AD_Compar/10)%10]);//SEG1 COM0-3=table1[9]=0X0E 1110 数字9
   6358                        Ht1621WrOneData(5,table2[(AD_Compar/10)%10]|0X01);//SEG2 COM0-3=table2[9]=0X0D 1101 数字9
   6359                        Ht1621WrOneData(6,table1[(AD_Compar%10)]);//SEG1 COM0-3=table1[9]=0X0E 1110 数字9
   6360                        Ht1621WrOneData(7,table2[(AD_Compar%10)]);//SEG2 COM0-3=table2[9]=0X0D 1101 数字9
   6361          #endif
   6362                    }
   6363                     
   6364           }
   6365           else
   6366           {
   6367                     if(HXtime>8)
   6368                     {HXtime=0;HXS=0;
   6369                      Send_datalend=0x03;  
   6370                      Send_data[7]=RS;
   6371                      Send_data[8]=(Send_data[6]+Send_data[7])%256;
   6372                      GenericApp_SendTheMessage(); //应用函数
   6373                      Ht1621WrAllData(0,Ht1621Tab,9);//清除1621寄存器数据，暨清屏 //SEG0～SEG17 COM0-3=0X00 0000 全灭
   6374                       P1_0=1;
   6375                       RSn=0;
   6376                       T_MUMPT1=21;
   6377                     }
   6378           }
   6379           }
   6380           else 
   6381           {          AD_filter();//AD和滤波
   6382                    // AD_Compar=  AD_Compar/80;//求体重 //参照
   6383                      AD_Compar=  10*AD_Compar;//求体重//壳体测试
   6384                      AD_Compar=  AD_Compar/AD_SHINING;//求体重//壳体测试
   6385                     if((AD_Compar<10)&&(AD_Compar>(-5)))AD_Compar=0;
   6386                     RS=AD_Compar/10;
   6387                     if(T_MUMPT1<20)
   6388                      {
   6389                        P1_0=0;
   6390          #if defined(SHINING75MIL) 
   6391                        Ht1621WrOneData(9,0X01); //KG
   6392                      if(((AD_Compar/100)%10)!=0)
   6393                      { if(AD_Compar/1000)
   6394                         Ht1621WrOneData(1,(table2[(AD_Compar/100)%10])|0x01);//SEG2 COM0-3=table2[9]=0X0D 1101 数字9  |百位1
   6395                         else
   6396                         Ht1621WrOneData(1,table2[(AD_Compar/100)%10]);//SEG2 COM0-3=table2[9]=0X0D 1101 数字9
   6397                         
   6398                         Ht1621WrOneData(0,table1[(AD_Compar/100)%10]);//SEG1 COM0-3=table1[9]=0X0E 1110 数字9
   6399                      }
   6400                        Ht1621WrOneData(2,table1[(AD_Compar/10)%10]);//SEG1 COM0-3=table1[9]=0X0E 1110 数字9
   6401                        Ht1621WrOneData(3,table2[(AD_Compar/10)%10]|0X01);//SEG2 COM0-3=table2[9]=0X0D 1101 数字9
   6402                        Ht1621WrOneData(4,table1[(AD_Compar%10)]);//SEG1 COM0-3=table1[9]=0X0E 1110 数字9
   6403                        if(PAN_ID_Success==2)
   6404                        Ht1621WrOneData(5,(table2[(AD_Compar%10)])|0X01);//SEG2 COM0-3=table2[9]=0X0D 1101 数字9 | M 添加网络显示M
   6405                        else
   6406                        Ht1621WrOneData(5,table2[(AD_Compar%10)]);//SEG2 COM0-3=table2[9]=0X0D 1101 数字9
   6407                        
   6408                        Ht1621WrOneData(6,table1[0]);//SEG1 COM0-3=table1[9]=0X0E 1110 数字9
   6409                        Ht1621WrOneData(7,table2[0]);//SEG2 COM0-3=table2[9]=0X0D 1101 数字9
   6410          #endif
   6411          #if defined(SHINING100MIL)  
   6412          Ht1621WrOneData(8,0X0C); //公斤
   6413           if(PAN_ID_Success==2)
   6414                        {
   6415                        Ht1621WrOneData(0,table1[AD_Compar/1000]);//SEG1 COM0-3=table1[9]=0X0E 1110 数字9
   6416                        Ht1621WrOneData(1,table2[AD_Compar/1000]);//SEG2 COM0-3=table2[9]=0X0D 1101 数字9
   6417                        }
   6418                        Ht1621WrOneData(2,table1[(AD_Compar/100)%10]);//SEG1 COM0-3=table1[9]=0X0E 1110 数字9
   6419                        Ht1621WrOneData(3,table2[(AD_Compar/100)%10]);//SEG2 COM0-3=table2[9]=0X0D 1101 数字9
   6420                        Ht1621WrOneData(4,table1[(AD_Compar/10)%10]);//SEG1 COM0-3=table1[9]=0X0E 1110 数字9
   6421                        Ht1621WrOneData(5,table2[(AD_Compar/10)%10]|0X01);//SEG2 COM0-3=table2[9]=0X0D 1101 数字9
   6422                        Ht1621WrOneData(6,table1[(AD_Compar%10)]);//SEG1 COM0-3=table1[9]=0X0E 1110 数字9
   6423                        Ht1621WrOneData(7,table2[(AD_Compar%10)]);//SEG2 COM0-3=table2[9]=0X0D 1101 数字9
   6424                    
   6425          #endif
   6426                   }  
   6427                     if(((RSn>RS)?(RSn-RS):(RS-RSn))>1)
   6428                        {T_MUMPT1=0;
   6429                        RSn=RS;
   6430                        }
   6431                    else   
   6432                  {
   6433                    RSn=RS;
   6434                    if(T_MUMPT1<8)T_MUMPT1++;
   6435                    else
   6436                    { 
   6437                     if(AD_Compar<50)
   6438                     { 
   6439                      if(AD_Compar==0)
   6440                      {
   6441                       Ht1621WrAllData(0,Ht1621Tab,9);//清除1621寄存器数据，暨清屏 //SEG0～SEG17 COM0-3=0X00 0000 全灭
   6442                       P1_0=1;
   6443                       T_MUMPT1=21;
   6444                      }
   6445                      else 
   6446                       {T_MUMPT1=0;
   6447                       Tozero();//自动归零
   6448                      }
   6449                     }
   6450                     else 
   6451                     {HXS=0X05;
   6452                     Send_datalend=0x03;  
   6453                      Send_data[7]=RS;
   6454                      Send_data[8]=(Send_data[6]+Send_data[7])%256;
   6455                      GenericApp_SendTheMessage(); //应用函数
   6456                     }
   6457                     
   6458                    }
   6459                  }
   6460            }
   6461          }else GenericApp_ON_OFF++;
   6462          #endif
   6463          #if(SENSOR_TYPE =='D')
   6464           if(GenericApp_applicationbuf>6000)
   6465            { P1_3=1;
   6466              GenericApp_applicationbuf=0;
   6467              for(unsigned int i=0;i<50000;i++);
   6468              GenericApp_SendTheMessage(); //应用函数
   6469            }
   6470          #endif
   6471          #if(SENSOR_TYPE ==0X33)
   6472           if(GenericApp_ON_OFF>10)
   6473           { GenericApp_ON_OFF=0;
   6474          B_LUX30_Multiple_read(0X00,&Send_data[8],4);
   6475          
   6476          if(((Send_data[9]-T_MUMPT1)>0X04)||((T_MUMPT1-Send_data[9])>0X04)||((Send_data[9]==0)&&(T_MUMPT1!=0)))//327 Lux
   6477            {T_MUMPT1=Send_data[9];
   6478             GenericApp_SendTheMessage(); //应用函数
   6479            }
   6480           }else GenericApp_ON_OFF++;
   6481           
   6482          if(GenericApp_applicationbuf>6000)
   6483            {GenericApp_applicationbuf=0;
   6484              GenericApp_SendTheMessage(); //应用函数
   6485            }
   6486          #endif
   6487          #if(SENSOR_TYPE ==0X85)
   6488          if(GenericApp_ON_OFF>10)
   6489           { GenericApp_ON_OFF=0;
   6490               unsigned char     slaveaddress;	 			  
   6491               unsigned long int    DATA;  
   6492               unsigned char tempbat[2];
   6493               
   6494              slaveaddress=MEM_READ(0x00,0x10);
   6495                   //读取存于MLX90615 EEPROM "00h"地址中的SMBus地址
   6496                   DATA=MEM_READ(slaveaddress,0x27);
   6497                   //基于上述地址由MLX90615的内存07h中读取物体温度
   6498                    CALTEMP(DATA,tempbat);	
   6499                   //基于所得的十六进制温度格式计算实际温度
   6500                   // UartTX_Send_String(tempbat,5);	
   6501                     int temp;
   6502                    temp=(tempbat[0]*100+tempbat[0]);
   6503                      data[4]=temp>>8;
   6504                      data[5]=temp;
   6505                      data[8]= data[0]+data[1]+data[2]+data[3]+data[4]+data[5]+data[6]+data[7];
   6506          
   6507                      Send_data[7]=0xAA;
   6508                      Send_data[8]=tempbat[0];//整数部分
   6509                      Send_data[9]=tempbat[1];//小数部分
   6510                      Send_data[10]=0xAA;    //保留
   6511                      Send_data[11]=0xAA;    //保留
   6512                   if(((Send_data[8]>T_MUMPT1)?( Send_data[8]-T_MUMPT1):(T_MUMPT1-Send_data[8]))>0X01) //大于1
   6513                   {T_MUMPT1=Send_data[8];
   6514                   GenericApp_applicationbuf=6001;
   6515                   }
   6516          
   6517           }else GenericApp_ON_OFF++;
   6518           if(GenericApp_applicationbuf>6000)
   6519            {GenericApp_applicationbuf=0;
   6520            HalUARTWrite(HAL_UART_PORT_0,data,9);
   6521              GenericApp_SendTheMessage(); //应用函数
   6522            }
   6523          #endif
   6524          #if defined (NB_IOT_S10)
   6525           
   6526           if(NBjishu>5)
   6527           { 
   6528           //{"Nbiot-up":{"IMEI":"0123456789ABCDEF","HUMITURE":"25-36"}}
   6529           //{"Nbiot-up" //"7b224e62696f742d757022"
   6530           //:{"IMEI"// "3a7b22494d454922"
   6531           //:"0123456789ABCDEF"//"3a223031323334353637383941424344454622"
   6532           //,"HUMITURE" //"2c2248554d495455524522"
   6533           //:"25-36"}}//"3a2232352d3336227d7d"
   6534            uint8 tmp[32]={0};
   6535             NBjishu=0;
   6536           switch(NBliucheng)
   6537           {case 0: HalUARTWrite(HAL_UART_PORT_0,"AT+NRB\r\n",8);
   6538                    HalUARTWrite(HAL_UART_PORT_0,"AT+NCONFIG=AUTOCONNECT,TRUE\r\n",29);break;
   6539            case 1: HalUARTWrite(HAL_UART_PORT_0,"AT+NBAND=5\r\n",12);break;
   6540            case 2: HalUARTWrite(HAL_UART_PORT_0,"AT+CFUN=1\r\n",11);break;
   6541            case 3: HalUARTWrite(HAL_UART_PORT_0,"AT+CIMI\r\n",9);break;
   6542            case 4: HalUARTWrite(HAL_UART_PORT_0,"AT+CGDCONT=1,\"IP\",\"CTNB\"\r\n",26);break;
   6543            case 5: HalUARTWrite(HAL_UART_PORT_0,"AT+CGATT=1\r\n",12);break;
   6544            case 6: HalUARTWrite(HAL_UART_PORT_0,"AT+COPS=1,2,\"46011\"\r\n",21);break;
   6545            case 7: HalUARTWrite(HAL_UART_PORT_0,"AT+CGSN=1\r\n",11);break; //读取IMEI号
   6546            case 15: HalUARTWrite(HAL_UART_PORT_0,"AT+CGATT?\r\n",11);break; //入网成功
   6547            case 16: HalUARTWrite(HAL_UART_PORT_0,"AT+NSOCR=DGRAM,17,5050,1\r\n",26);break;//创建Socket 5050
   6548            case 17: //strcat((char*)tmp, (char const*)tmp1);
   6549               for(int i=0;i<16;i++)
   6550              {  tmp[2*i]='3';tmp[2*i+1]=NB_IMEI[i];}
   6551              tmp[31]='0';
   6552              
   6553              HalUARTWrite(HAL_UART_PORT_0,"AT+NSOST=0,139.196.218.156,5050,56,",35);//发送数据
   6554              HalUARTWrite(HAL_UART_PORT_0,"7b224e622d757022",16);//发送数据  //{"Nb-up" //"7b224e622d757022"
   6555              HalUARTWrite(HAL_UART_PORT_0,"3a7b22494d4549223a22",20);//发送数据  //:{"IMEI":"// "3a7b22494d4549223a22"
   6556              //HalUARTWrite(HAL_UART_PORT_0,"30313233343536373839414243444546",32);//发送数据  //0123456789ABCDEF//"30313233343536373839414243444546"
   6557              HalUARTWrite(HAL_UART_PORT_0,tmp,32);//发送数据  //0123456789ABCDEF//"30313233343536373839414243444546"
   6558              NBjishu=4;NBliucheng=18;break;
   6559           case 18: //Send_data[7]=34; Send_data[9]=60;
   6560               tmp[0]='3';
   6561               if((Send_data[9])<100){tmp[1]=(Send_data[9]/10)+0X30;}else tmp[1]='0'; //整数位
   6562               tmp[2]='3';
   6563               if((Send_data[9])<100){tmp[3]=(Send_data[9]%10)+0X30;}else tmp[3]='0';
   6564               tmp[4]='2';
   6565               tmp[5]='d';
   6566               tmp[6]='3';
   6567               if((Send_data[7])<100){tmp[7]=(Send_data[7]/10)+0X30;}else tmp[7]='0'; //整数位
   6568               tmp[8]='3';
   6569               if((Send_data[7])<100){tmp[9]=(Send_data[7]%10)+0X30;}else tmp[9]='0';
   6570               HalUARTWrite(HAL_UART_PORT_0,"222c2248554d4954555245223a22",28);//发送数据   //:,"HUMITURE":" //"222c2248554d4954555245223a22"
   6571             // HalUARTWrite(HAL_UART_PORT_0,"32352d3336",10);//发送数据  //25-36//"32352d3336"
   6572               HalUARTWrite(HAL_UART_PORT_0,tmp,10);//发送数据  //25-36//"32352d3336"
   6573              HalUARTWrite(HAL_UART_PORT_0,"227d7d\r\n",8);NBliucheng=100;break;//发送数据  //}} //227d7d//结束符
   6574              
   6575            case 19: HalUARTWrite(HAL_UART_PORT_0,"AT+NSORF=0,100\r\n",16);break;//读取数据
   6576            case 30: HalUARTWrite(HAL_UART_PORT_0,"AT+NSORF=0,100\r\n",16);break;//读取数据
   6577            case 40: HalUARTWrite(HAL_UART_PORT_0,"AT+NSORF=0,100\r\n",16);break;//读取数据
   6578            case 100:break;//退出
   6579            default:break;//退出
   6580          
   6581           }
   6582           //NBliucheng++;
   6583           
   6584            if(NBliucheng>50)NBliucheng--;
   6585            if(NBliucheng==55)NBliucheng=17;
   6586           }
   6587           else NBjishu++;
   6588          
   6589          #endif
   6590           
   6591          #if(SENSOR_TYPE =='E')
   6592          if(GenericApp_ON_OFF>10)
   6593           { GenericApp_ON_OFF=0;
   6594           uint  data;
   6595            valuen humi_val,temp_val;							    
   6596            unsigned char error,checksum; 
   6597           error=0;  
   6598                     error+=s_measure( &Send_data[7],&checksum,HUMI);  //measure humidity 
   6599                     error+=s_measure( &Send_data[9],&checksum,TEMP);  //measure temperature 
   6600                    if(error!=0) s_connectionreset();                  //in case of an error: connection  
   6601                    else 
   6602                    { humi_val.i=Send_data[7]*256+Send_data[8];
   6603                      temp_val.i=Send_data[9]*256+Send_data[10];
   6604                      humi_val.f=(float)humi_val.i;                   //converts integer to float
   6605                      temp_val.f=(float)temp_val.i;                   //converts integer to float
   6606                      calc_dht90(&humi_val.f,&temp_val.f);            //calculate humidity, temperature
   6607           Send_data[6]=SENSOR_TYPE;//传感器类型
   6608            data=(uint)(100*humi_val.f);   
   6609           Send_data[7]=(uint8)(data/ 100);
   6610            Send_data[8]=(uint8)(data % 100);
   6611            data=(uint)(100*temp_val.f);              
   6612            Send_data[9]=(uint8)(data / 100);
   6613            Send_data[10]=(uint8)(data % 100);
   6614                    }
   6615          if(((Send_data[9]-T_MUMPT1)>0X01)||((T_MUMPT1-Send_data[9])>0X01))//温度值
   6616            {T_MUMPT1=Send_data[9];
   6617            GenericApp_applicationbuf=6001;
   6618            }
   6619           }else GenericApp_ON_OFF++;
   6620          
   6621          
   6622            if(GenericApp_applicationbuf>6000)
   6623            {GenericApp_applicationbuf=0;
   6624          
   6625          #if defined (NB_IOT_S10)
   6626             if(NBliucheng>50)NBliucheng=17;
   6627           //  P0_4=~P0_4;
   6628          #endif
   6629              GenericApp_SendTheMessage(); //应用函数
   6630            }
   6631          
   6632          #endif
   6633          #if(SENSOR_TYPE ==0X82)
   6634          if(GenericApp_ON_OFF>10)
   6635           { GenericApp_ON_OFF=0;
   6636            Multiple_Read_HMC5883();      //连续读出数据，存储在BUF中
   6637              //---------显示X轴
   6638             // HMC5883_x=(BUF[0] << 8 | BUF[1]); //Combine MSB and LSB of X Data output register
   6639             // HMC5883_z=(BUF[2] << 8 | BUF[3]); //Combine MSB and LSB of Z Data output register
   6640             // HMC5883_y=(BUF[4] << 8 | BUF[5]); //Combine MSB and LSB of Y Data output register
   6641          
   6642            //HMC5883_x = atan2((float)(0.92* (BUF[4] << 8 | BUF[5])),(float)(0.92* (BUF[0] << 8 | BUF[1])));
   6643            //HMC5883_y = atan2((float)(0.92* (BUF[2] << 8 | BUF[3])),(float)(0.92* (BUF[0] << 8 | BUF[1])));
   6644            //HMC5883_z= atan2((float)(0.92* (BUF[2] << 8 | BUF[3])),(float)(0.92* (BUF[4] << 8 | BUF[5])));
   6645            //HMC5883_x =((HMC5883_x < 0)?(HMC5883_x += 2*PI):(HMC5883_x -= 2*PI)) * 180/M_PI;
   6646            //HMC5883_y =((HMC5883_y < 0)?(HMC5883_y += 2*PI):(HMC5883_y -= 2*PI)) * 180/M_PI;
   6647           // HMC5883_z =((HMC5883_z < 0)?(HMC5883_z += 2*PI):(HMC5883_z -= 2*PI)) * 180/M_PI;
   6648            
   6649              HMC5883_x= atan2((float)(BUF[4] << 8 | BUF[5]),(float)(BUF[0] << 8 | BUF[1])) * (180 / 3.14159265) + 180; // angle in degrees
   6650              HMC5883_y= atan2((float)(BUF[2] << 8 | BUF[3]),(float)(BUF[0] << 8 | BUF[1])) * (180 / 3.14159265) + 180; // angle in degrees
   6651              HMC5883_z= atan2((float)(BUF[2] << 8 | BUF[3]),(float)(BUF[4] << 8 | BUF[5])) * (180 / 3.14159265) + 180; // angle in degrees
   6652             
   6653             Send_data[8]=(int)HMC5883_x>>8;
   6654             Send_data[9]=(int)HMC5883_x;
   6655             Send_data[10]=(int)HMC5883_y>>8;
   6656             Send_data[11]=(int)HMC5883_y;
   6657             Send_data[12]=(int)HMC5883_z>>8;
   6658             Send_data[13]=(int)HMC5883_z;
   6659          if(((Send_data[9]>T_MUMPT1)?( Send_data[9]-T_MUMPT1):(T_MUMPT1-Send_data[9]))>0X05) //x角度大于5
   6660            {T_MUMPT1=Send_data[9];
   6661            GenericApp_applicationbuf=6001;
   6662            }
   6663          if(((Send_data[11]>T_MUMPT_y)?( Send_data[11]-T_MUMPT_y):(T_MUMPT_y-Send_data[11]))>0X05) //y角度大于5
   6664            {T_MUMPT_y=Send_data[11];
   6665            GenericApp_applicationbuf=6001;
   6666            }
   6667          if(((Send_data[13]>T_MUMPT_z)?( Send_data[13]-T_MUMPT_z):(T_MUMPT_z-Send_data[13]))>0X05) //z角度大于5
   6668            {T_MUMPT_z=Send_data[13];
   6669            GenericApp_applicationbuf=6001;
   6670            }
   6671           }else GenericApp_ON_OFF++;
   6672          
   6673            if(GenericApp_applicationbuf>6000)
   6674            {GenericApp_applicationbuf=0;
   6675              GenericApp_SendTheMessage(); //应用函数
   6676            }
   6677          #endif
   6678            #if(SENSOR_TYPE ==0X81)
   6679          if(GenericApp_ON_OFF>10)
   6680           { GenericApp_ON_OFF=0;
   6681             GenericApp_sbum=read_max6675();
   6682             if(GenericApp_sbum==0X8001){Send_data[8]=1;Send_data[9]=0;Send_data[10]=0;}//1 开路
   6683             else  { GenericApp_sbum=(GenericApp_sbum/4);
   6684             Send_data[8]=0;//正常
   6685             Send_data[9]=(GenericApp_sbum>>8);
   6686             Send_data[10]=(GenericApp_sbum);
   6687          if(((Send_data[10]>T_MUMPT1)?( Send_data[10]-T_MUMPT1):(T_MUMPT1-Send_data[10]))>0X20) //温度变化超过 32度
   6688            {T_MUMPT1=Send_data[10];
   6689            GenericApp_applicationbuf=6001;
   6690            }
   6691          }
   6692           }else GenericApp_ON_OFF++;
   6693            if(GenericApp_applicationbuf>6000)
   6694            {GenericApp_applicationbuf=0;
   6695              GenericApp_SendTheMessage(); //应用函数
   6696            }
   6697          #endif
   6698          #if((SENSOR_TYPE =='B')||(SENSOR_TYPE =='C')||(SENSOR_TYPE =='F')||(SENSOR_TYPE =='U'))
   6699            if(GenericApp_applicationbuf>6000)
   6700            {GenericApp_applicationbuf=0;
   6701              GenericApp_SendTheMessage(); //应用函数
   6702            }
   6703          #endif
   6704          #if(SENSOR_TYPE =='S')
   6705            if((P1&0XE0)!=GenericApp_appIO)
   6706            {
   6707               GenericApp_appIO=(P1&0XE0);
   6708             if(P1_5)
   6709              {
   6710                if(GenericApp_ON_OFF<0x71)
   6711                {
   6712                 if(GenericApp_ON_OFF>0x1F)
   6713                 GenericApp_ON_OFF+=0x05;
   6714               else
   6715                 GenericApp_ON_OFF=0x20;
   6716                }
   6717                else
   6718                  GenericApp_ON_OFF=0x75;
   6719               DimmingAppControl(GenericApp_ON_OFF,0X01);
   6720                 GenericApp_applicationbuf=1;
   6721                   GenericApp_SendTheMessage();
   6722              }
   6723                if(P1_7)
   6724              {
   6725                 if(GenericApp_ON_OFF>0x20)
   6726                 GenericApp_ON_OFF-=0x05;
   6727               else
   6728                 GenericApp_ON_OFF=0x00;
   6729               DimmingAppControl(GenericApp_ON_OFF,0X01);
   6730               GenericApp_applicationbuf=1;
   6731                   GenericApp_SendTheMessage();
   6732              }
   6733             if(P1_6)
   6734             { DimmingAppControl(0x00,0X01);
   6735               halMcuWaitMs(3000);
   6736                  if(P1_6)
   6737                  {  uint16 nv_data=0X0000;
   6738                      osal_nv_item_init( ZCD_NV_APP_R_E_KEY_P07,sizeof(nv_data), &nv_data );
   6739                      osal_nv_write( ZCD_NV_APP_R_E_KEY_P07, 0,sizeof(nv_data),&nv_data);  
   6740                     WDCTL = 0x00;WDCTL |= 0x09;  //0B  1.9MS  09  0.25秒
   6741          	}
   6742             }
   6743            } 
   6744          #endif
   6745          /*
   6746          #if(SENSOR_TYPE =='S')
   6747            if((P1&0XE0)!=GenericApp_appIO)
   6748            {
   6749               GenericApp_appIO=(P1&0XE0);
   6750             if(P1_6)
   6751              {
   6752                if(GenericApp_ON_OFF<0x71)
   6753                 GenericApp_ON_OFF+=0x05;
   6754               else
   6755                 GenericApp_ON_OFF=0x75;
   6756               DimmingAppControl(GenericApp_ON_OFF,0X01);
   6757                    GenericApp_KSH_H=1;
   6758                if(GenericApp_KSH>2)
   6759                   { 
   6760                      uint16 nv_data=0X0000;
   6761                      osal_nv_item_init( ZCD_NV_APP_R_E_KEY_P07,sizeof(nv_data), &nv_data );
   6762                      osal_nv_write( ZCD_NV_APP_R_E_KEY_P07, 0,sizeof(nv_data),&nv_data);
   6763                      WDCTL = 0x00;
   6764          	    WDCTL |= 0x0B;
   6765                   }
   6766              }
   6767                if(P1_7)
   6768              {  
   6769                 if(GenericApp_ON_OFF>0x07)
   6770                 GenericApp_ON_OFF-=0x05;
   6771               else
   6772                 GenericApp_ON_OFF=0x00;
   6773               DimmingAppControl(GenericApp_ON_OFF,0X01);
   6774               if(GenericApp_KSH_H)
   6775               {GenericApp_KSH86=0;
   6776                 GenericApp_KSH++;
   6777                GenericApp_KSH_H=0;
   6778               }
   6779               }
   6780            } 
   6781          #endif 
   6782          */
   6783            }
   6784          #if !defined (SENSOR_TYPE_Coord)
   6785          #if((SENSOR_TYPE ==0X66)||(SENSOR_TYPE ==0X73)||(SENSOR_TYPE ==0X76)||(SENSOR_TYPE =='G'))
   6786          if(GenericApp_ON_OFF>100)
   6787          {GenericApp_ON_OFF=0;
   6788            ZigBee_C_R_E_Engineering_I();
   6789          }
   6790          else GenericApp_ON_OFF++;
   6791          #else
   6792            ZigBee_C_R_E_Engineering_I();
   \                     ??GenericAppEndDeviceEB_0:
   \   00016B                ; Setup parameters for call to function ZigBee_C_R_E_Engineering_I
   \   00016B   12....       LCALL   ??ZigBee_C_R_E_Engineering_I?relay
   6793          #endif
   6794          #endif
   6795          }
   \   00016E   7403         MOV     A,#0x3
   \   000170   12....       LCALL   ?DEALLOC_XSTACK8
   \   000173   7F04         MOV     R7,#0x4
   \   000175   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000178                REQUIRE _A_P1

   \                                 In  segment INTVEC, offset 0x5b, root
   \                     `??T3_IRQ??INTVEC 91`:
   \   00005B   02....       LJMP       (T3_IRQ)

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for Send_data>`:
   \   000000   FA0A0000     DB 250, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00000000
   \            00000000
   \   000010   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00000000
   \            00000000
   \   000020   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00000000
   \            00000000
   \   000030   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00000000
   \            00000000
   \   000040   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00000000
   \            00000000
   \   000050   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00000000
   \            00000000
   \   000060   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00000000
   \            00000000
   \   000070   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00000000
   \            00000000

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for T3_t1Val>`:
   \   000000   64000000     DD 100

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??OLED_delay?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OLED_delay

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??OLED_IIC_Start?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OLED_IIC_Start

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??OLED_IIC_Stop?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OLED_IIC_Stop

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??Write_IIC_Byte?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    Write_IIC_Byte

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??OLED_WrDat?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OLED_WrDat

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??OLED_WrCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OLED_WrCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??OLED_Set_Pos?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OLED_Set_Pos

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??OLED_Fill?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OLED_Fill

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??OLED_CLS?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OLED_CLS

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??OLED_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OLED_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??OLED_P8x16Str?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OLED_P8x16Str

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halSetTimer3Period?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halSetTimer3Period

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GenericApp_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GenericApp_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GenericApp_ProcessEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GenericApp_ProcessEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GenericApp_HandleKeys?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GenericApp_HandleKeys

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GenericApp_MessageMSGCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GenericApp_MessageMSGCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GenericApp_SendTheMessage?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GenericApp_SendTheMessage

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GenericAppEndDeviceEB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GenericAppEndDeviceEB

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "%04X">`:
   \   000000   25303458     DB "%04X"
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "R       ID:">`:
   \   000000   52202020     DB "R       ID:"
   \            20202020
   \            49443A00

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "%02d">`:
   \   000000   25303264     DB "%02d"
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "%02X">`:
   \   000000   25303258     DB "%02X"
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "V2.45">`:
   \   000000   56322E34     DB "V2.45"
   \            3500    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "%02X%02X%02X%02X%02X%...">`:
   \   000000   25303258     DB "%02X%02X%02X%02X%02X%02X%02X%02X"
   \            25303258
   \            25303258
   \            25303258
   \            25303258
   \            25303258
   \            25303258
   \            25303258
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {170, 43, 187}>`:
   \   000000   AA2BBB       DB 170, 43, 187

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_7d:
   \   000000   7D000000     DD 125

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     GenericAppEndDeviceEB              2      0     24
       -> AF_DataRequest                0      0     48
       -> HalUARTWrite                  0      0     30
       -> ZigBee_C_R_E_Engineering_I
                                        0      0     30
     GenericApp_HandleKeys              0      0     56
       -> GenericApp_SendTheMessage     0      0     48
       -> OLED_Init                     0      0     48
       -> OLED_P8x16Str                 0      0     48
       -> osal_nv_read                  0      0     56
       -> sprintf                       0      0     52
       -> OLED_P8x16Str                 0      0     48
       -> sprintf                       0      0     52
       -> OLED_P8x16Str                 0      0     48
       -> osal_nv_read                  0      0     56
       -> sprintf                       0      0     52
       -> OLED_P8x16Str                 0      0     48
       -> OLED_P8x16Str                 0      0     48
       -> NLME_GetCoordShortAddr        0      0     48
       -> sprintf                       0      0     52
       -> OLED_P8x16Str                 0      0     48
       -> NLME_GetShortAddr             0      0     48
       -> sprintf                       0      0     52
       -> OLED_P8x16Str                 0      0     48
       -> NLME_GetExtAddr               0      0     48
       -> sprintf                       0      0     80
       -> OLED_P8x16Str                 0      0     48
       -> GenericApp_SendTheMessage     0      0     48
       -> OLED_Init                     0      0     48
       -> OLED_P8x16Str                 0      0     48
       -> osal_nv_read                  0      0     56
       -> sprintf                       0      0     52
       -> OLED_P8x16Str                 0      0     48
       -> sprintf                       0      0     52
       -> OLED_P8x16Str                 0      0     48
       -> osal_nv_read                  0      0     56
       -> sprintf                       0      0     52
       -> OLED_P8x16Str                 0      0     48
       -> OLED_P8x16Str                 0      0     48
       -> NLME_GetCoordShortAddr        0      0     48
       -> sprintf                       0      0     52
       -> OLED_P8x16Str                 0      0     48
       -> NLME_GetShortAddr             0      0     48
       -> sprintf                       0      0     52
       -> OLED_P8x16Str                 0      0     48
       -> NLME_GetExtAddr               0      0     48
       -> sprintf                       0      0     80
       -> OLED_P8x16Str                 0      0     48
       -> ZigBee_C_R_E_Engineering_F
                                        0      0     48
     GenericApp_Init                    0      0      9
       -> afRegister                    0      0     18
       -> RegisterForKeys               0      0     18
     GenericApp_MessageMSGCB            0      0     30
       -> NLME_GetExtAddr               0      0     28
       -> GenericApp_SendTheMessage     0      0     28
       -> NLME_GetExtAddr               0      0     28
       -> HalUARTWrite                  0      0     28
       -> GenericApp_SendTheMessage     0      0     28
       -> HalUARTWrite                  0      0     28
     GenericApp_ProcessEvent            0      0     20
       -> osal_msg_receive              0      0     32
       -> GenericApp_HandleKeys         0      0     32
       -> osal_msg_deallocate           0      0     32
       -> osal_msg_receive              0      0     32
       -> GenericApp_MessageMSGCB       0      0     32
       -> osal_start_timerEx            0      0     32
       -> osal_nv_read                  0      0     40
       -> sprintf                       0      0     36
       -> OLED_P8x16Str                 0      0     32
       -> NLME_GetCoordShortAddr        0      0     32
       -> sprintf                       0      0     36
       -> OLED_P8x16Str                 0      0     32
       -> NLME_GetShortAddr             0      0     32
       -> sprintf                       0      0     36
       -> OLED_P8x16Str                 0      0     32
       -> osal_start_timerEx            0      0     32
     GenericApp_SendTheMessage          0      0     51
       -> HalLedSet                     0      0     36
       -> HalLedSet                     0      0     36
       -> NLME_GetShortAddr             0      0     36
       -> NLME_GetCoordShortAddr        0      0     36
       -> NLME_GetCoordShortAddr        0      0     36
       -> ZigBee_C_R_E_Engineering_H
                                        0      0     36
       -> AF_DataRequest                0      0     54
       -> HalLedSet                     0      0     36
       -> HalLedSet                     0      0     36
     OLED_CLS                           0      0      9
       -> OLED_WrCmd                    0      0     18
       -> OLED_WrCmd                    0      0     18
       -> OLED_WrCmd                    0      0     18
       -> OLED_WrDat                    0      0     18
     OLED_Fill                          0      0      9
       -> OLED_WrCmd                    0      0     18
       -> OLED_WrCmd                    0      0     18
       -> OLED_WrCmd                    0      0     18
       -> OLED_WrDat                    0      0     18
     OLED_IIC_Start                     0      0      9
     OLED_IIC_Stop                      0      0      9
     OLED_Init                          2      0     24
       -> OLED_delay                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_WrCmd                    4      0      0
       -> OLED_Fill                     4      0      0
       -> OLED_Set_Pos                  4      0      0
     OLED_P8x16Str                      0      0     40
       -> OLED_Set_Pos                  0      0     32
       -> OLED_WrDat                    0      0     32
       -> OLED_Set_Pos                  0      0     32
       -> OLED_WrDat                    0      0     32
     OLED_Set_Pos                       0      0     25
       -> OLED_WrCmd                    0      0     18
       -> OLED_WrCmd                    0      0     18
       -> OLED_WrCmd                    0      0     18
     OLED_WrCmd                         0      0     18
       -> OLED_IIC_Start                0      0     18
       -> Write_IIC_Byte                0      0     18
       -> Write_IIC_Byte                0      0     18
       -> Write_IIC_Byte                0      0     18
       -> OLED_IIC_Stop                 0      0     18
     OLED_WrDat                         0      0     25
       -> OLED_IIC_Start                0      0     18
       -> Write_IIC_Byte                0      0     18
       -> Write_IIC_Byte                0      0     18
       -> Write_IIC_Byte                0      0     18
       -> OLED_IIC_Stop                 0      0     18
     OLED_delay                         0      0      0
     T3_IRQ                             2      0     22
     Write_IIC_Byte                     0      0      9
     halSetTimer3Period                 0      0      0


   Segment part sizes:

     Function/Label                         Bytes
     --------------                         -----
     _A_P1                                     1
     _A_P2                                     1
     _A_IEN0                                   1
     T3CC0                                     1
     _A_TIMIF                                  1
     P1SEL                                     1
     P1DIR                                     1
     P2DIR                                     1
     F8X16                                  1520
     OLED_delay                               22
     ??Subroutine31_0                          6
     OLED_IIC_Start                           13
     ?Subroutine0                              2
     ??Subroutine30_0                          2
     OLED_IIC_Stop                            15
     Write_IIC_Byte                           45
     OLED_WrDat                               12
     ?Subroutine7                             11
     ?Subroutine1                             11
     ??Subroutine32_0                          5
     OLED_WrCmd                               12
     OLED_Set_Pos                             37
     OLED_Fill                                39
     ?Subroutine5                             15
     OLED_CLS                                 33
     OLED_Init                               145
     ?Subroutine10                             9
     ?Subroutine9                              9
     ?Subroutine8                              9
     OLED_P8x16Str                           142
     ?Subroutine11                            14
     ?Subroutine6                             16
     Send_data                               128
     Send_datalend                             1
     AF_OK                                     1
     AF_RF                                     1
     AF_RFn                                    1
     AF_RFnd                                   1
     AF_RFnds                                  1
     chnndr                                  120
     GenericApp_applicationdata                2
     GenericApp_time                           1
     GenericApp_applicationbuf                 2
     GenericApp_uart_data                      2
     GenericApp_CR                             1
     openoff                                   1
     PWRMGR_ALWAYS_ON_OFF                      1
     OSAL_SET_CPU_INTO_SLEEP                   1
     GenericApp_sbum                           2
     GenericApp_KSH_H                          2
     GenericApp_KSH                            2
     GenericApp_KSH86                          2
     T3_t1Val                                  4
     t1Val                                     4
     T_MG                                      1
     T_MGSbit                                  1
     GenericApp_appIO                          1
     GenericApp_BX                             1
     GenericApp_ON_OFF                         2
     GenericApp_switch                         2
     GenericApp_switchk2                       2
     T_MUMPT1                                  1
     T_MUMPTS                                  2
     Uart_Rev_Buff_1                           6
     Uart_Rev_Buff_2                           6
     car_stata                                 1
     car_op                                    1
     car_sum                                   1
     holzer                                    1
     GenericApp_ClusterList                    2
     GenericApp_SimpleDesc                    12
     GenericApp_epDesc                         6
     GenericApp_TaskID                         1
     GenericApp_NwkState                       1
     GenericApp_TransID                        1
     GenericApp_DstAddr                       12
     halSetTimer3Period                        6
     T3_IRQ                                  109
     GenericApp_Init                         127
     GenericApp_ProcessEvent                 305
     ?Subroutine2                              5
     ?Subroutine20                             6
     ??Subroutine33_0                          8
     ?Subroutine18                             4
     ??Subroutine34_0                         10
     ?Subroutine26                            15
     GenericApp_HandleKeys                   604
     ?Subroutine27                            12
     ?Subroutine24                            27
     ?Subroutine23                            26
     ?Subroutine19                            25
     ?Subroutine29                            10
     ?Subroutine13                             1
     ??Subroutine35_0                          1
     ??Subroutine36_0                          1
     ??Subroutine37_0                          1
     ??Subroutine38_0                          1
     ??Subroutine39_0                          6
     ?Subroutine12                             1
     ??Subroutine40_0                          1
     ??Subroutine41_0                          1
     ??Subroutine42_0                          1
     ??Subroutine43_0                          1
     ??Subroutine44_0                          6
     GenericApp_MessageMSGCB                 399
     ?Subroutine22                            30
     ?Subroutine16                             7
     ?Subroutine14                            10
     ?Subroutine28                            14
     ?Subroutine4                             27
     ?Subroutine3                             61
     GenericApp_SendTheMessage               439
     ?Subroutine21                            13
     ?Subroutine17                             7
     ?Subroutine25                             6
     ?Subroutine15                            15
     GenericAppEndDeviceEB                   376
     ??T3_IRQ??INTVEC 91                       3
     ?<Initializer for Send_data>            128
     ?<Initializer for T3_t1Val>               4
     ??OLED_delay?relay                        6
     ??OLED_IIC_Start?relay                    6
     ??OLED_IIC_Stop?relay                     6
     ??Write_IIC_Byte?relay                    6
     ??OLED_WrDat?relay                        6
     ??OLED_WrCmd?relay                        6
     ??OLED_Set_Pos?relay                      6
     ??OLED_Fill?relay                         6
     ??OLED_CLS?relay                          6
     ??OLED_Init?relay                         6
     ??OLED_P8x16Str?relay                     6
     ??halSetTimer3Period?relay                6
     ??GenericApp_Init?relay                   6
     ??GenericApp_ProcessEvent?relay           6
     ??GenericApp_HandleKeys?relay             6
     ??GenericApp_MessageMSGCB?relay           6
     ??GenericApp_SendTheMessage?relay         6
     ??GenericAppEndDeviceEB?relay             6
     ?<Constant "%04X">                        5
     ?<Constant "R       ID:">                12
     ?<Constant "%02d">                        5
     ?<Constant "%02X">                        5
     ?<Constant "V2.45">                       6
     ?<Constant "%02X%02X%02X%02X%02X%...">   33
     ?<Constant {170, 43, 187}>                3
     __Constant_1                              4
     __Constant_7d                             4
     __Constant_0                              4

 
 3 240 bytes in segment BANKED_CODE
   108 bytes in segment BANK_RELAYS
 1 520 bytes in segment CODE_C
     3 bytes in segment INTVEC
   109 bytes in segment NEAR_CODE
     8 bytes in segment SFR_AN
   132 bytes in segment XDATA_I
   132 bytes in segment XDATA_ID
    95 bytes in segment XDATA_ROM_C
   199 bytes in segment XDATA_Z
 
 5 109 bytes of CODE  memory (+  3 bytes shared)
    83 bytes of CONST memory (+ 12 bytes shared)
     0 bytes of DATA  memory (+  8 bytes shared)
   331 bytes of XDATA memory

Errors: none
Warnings: 1
