###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.60.1.40026 for 8051             08/Jun/2018  08:42:03 #
# Copyright (C) 2004-2010 IAR Systems AB.                                     #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV2 #
#                          .45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\Source #
#                          \GenericApp.c                                      #
#    Command line       =  -f "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³Ì #
#                          ÐòV2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC #
#                          2530DB\..\..\..\COMPONENTS\Tools\CC2530DB\f8wCoord #
#                          .cfg" (-DCPU32MHZ -DROOT=__near_func               #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                   #
#                          -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8         #
#                          -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f                   #
#                          "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV #
#                          2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\Tools\CC2530DB\f8wConfig.c #
#                          fg" (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR  #
#                          -DNWK_START_DELAY=1000 -DEXTENDED_JOINING_RANDOM_M #
#                          ASK=0x007F -DBEACON_REQUEST_DELAY=1000             #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Users\win7\Desktop\ZSta #
#                          ck´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV2.45-13(´ø»ØÂë2018-5-20)\Pr #
#                          ojects\GenericApp\Source\GenericApp.c" -D          #
#                          ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC  #
#                          -D HAL_PA_LNA -D SERIAL_SUPPORTED=DEBUG -D         #
#                          SENSOR_TYPE_Coord -D CHANLIST_C_R_E=25 -D          #
#                          ZDAPP_CONFIG_PAN_ID=0x0004 -D FT_PAN_ID_C_R_C -D   #
#                          ZigBee_C_R_E_Engineering -D ZDO_COORDINATOR=0 -D   #
#                          xNV_RESTORE -lC "C:\Users\win7\Desktop\ZStack´«¸ÐÆ #
#                          ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV2.45-13(´ø»ØÂë2018-5-20)\Projects\ #
#                          GenericApp\CC2530DB\Coordinator\List\" -lA         #
#                          "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV #
#                          2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\Coordinator\List\" --diag_suppress             #
#                          Pe001,Pa010 -o "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷ #
#                          Í¸Ã÷´«ÊäÔ´³ÌÐòV2.45-13(´ø»ØÂë2018-5-20)\Projects\G #
#                          enericApp\CC2530DB\Coordinator\Obj\" -e            #
#                          --require_prototypes --debug --core=plain          #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "C:\Users\win7\Desktop\ZSt #
#                          ack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV2.45-13(´ø»ØÂë2018-5-20)\P #
#                          rojects\GenericApp\CC2530DB\" -I                   #
#                          "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV #
#                          2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\SOURCE\" -I "C:\Users\win7\Desktop\ZStack´« #
#                          ¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV2.45-13(´ø»ØÂë2018-5-20)\Projec #
#                          ts\GenericApp\CC2530DB\..\..\..\COMPONENTS\ZMAIN\T #
#                          I2530DB\" -I "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸ #
#                          Ã÷´«ÊäÔ´³ÌÐòV2.45-13(´ø»ØÂë2018-5-20)\Projects\Gen #
#                          ericApp\CC2530DB\..\..\..\COMPONENTS\MT\" -I       #
#                          "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV #
#                          2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\HAL\INCLUDE\" -I           #
#                          "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV #
#                          2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\HAL\TARGET\CC2530EB\" -I   #
#                          "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV #
#                          2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\OSAL\MCU\CCSOC\" -I        #
#                          "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV #
#                          2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\OSAL\INCLUDE\" -I          #
#                          "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV #
#                          2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\STACK\AF\" -I              #
#                          "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV #
#                          2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\STACK\NWK\" -I             #
#                          "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV #
#                          2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\STACK\SEC\" -I             #
#                          "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV #
#                          2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\STACK\SAPI\" -I            #
#                          "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV #
#                          2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\STACK\SYS\" -I             #
#                          "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV #
#                          2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\STACK\ZDO\" -I             #
#                          "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV #
#                          2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\ZMAC\F8W\" -I              #
#                          "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV #
#                          2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\ZMAC\" -I                  #
#                          "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV #
#                          2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\SERVICES\SADDR\" -I        #
#                          "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV #
#                          2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\SERVICES\SDATA\" -I        #
#                          "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV #
#                          2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\MAC\INCLUDE\" -I           #
#                          "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV #
#                          2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\MAC\HIGH_LEVEL\" -I        #
#                          "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV #
#                          2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\" -I   #
#                          "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV #
#                          2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC253 #
#                          0DB\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE #
#                          _CHIP\" -I "C:\Program Files (x86)\IAR             #
#                          Systems\Embedded Workbench 5.4\8051\INC\" -I       #
#                          "C:\Program Files (x86)\IAR Systems\Embedded       #
#                          Workbench 5.4\8051\INC\CLIB\" -Ohz                 #
#    List file          =  C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV2 #
#                          .45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC2530 #
#                          DB\Coordinator\List\GenericApp.lst                 #
#    Object file        =  C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV2 #
#                          .45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\CC2530 #
#                          DB\Coordinator\Obj\GenericApp.r51                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV2.45-13(´ø»ØÂë2018-5-20)\Projects\GenericApp\Source\GenericApp.c
      1          /**************************************************************************************************
      2            Filename:       GenericApp.c
      3            Revised:        $Date: 2009-03-18 15:56:27 -0700 (Wed, 18 Mar 2009) $
      4            Revision:       $Revision: 19453 $
      5            NLME_SetPollRate( 0 );
      6          ZDApp_StopJoiningCycle();
      7          
      8            Description:    Generic Application (no Profile).
      9            Copyright 2004-2009 Texas Instruments Incorporated. All rights reserved.
     10            IMPORTANT: Your use of this Software is limited to those specific rights
     11            granted under the terms of a software license agreement between the user
     12            who downloaded the software, his/her employer (which must be your employer)
     13            and Texas Instruments Incorporated (the "License").  You may not use this
     14            Software unless you agree to abide by the terms of the License. The License
     15            limits your use, and you acknowledge, that the Software may not be modified,
     16            copied or distributed unless embedded on a Texas Instruments microcontroller
     17            or used solely and exclusively in conjunction with a Texas Instruments radio
     18            frequency transceiver, which is integrated into your product.  Other than for 
     19            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     20            works of, modify, distribute, perform, display or sell this Software and/or
     21            its documentation for any purpose.
     22          
     23            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     24            PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     25            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     26            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     27            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     28            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     29            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     30            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     31            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     32            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     33            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     34          
     35            Should you have any questions regarding your right to use this Software,
     36            contact Texas Instruments Incorporated at www.TI.com. 
     37          **************************************************************************************************/
     38           
     39          /*********************************************************************
     40            This application isn't intended to do anything useful, it is
     41            intended to be a simple example of an application's structure.
     42          
     43            This application sends "Hello World" to another "Generic"
     44            application every 15 seconds.  The application will also
     45            receive "Hello World" packets.
     46          
     47            The "Hello World" messages are sent/received as MSG type message.
     48          
     49            This applications doesn't have a profile, so it handles everything
     50            directly - itself.
     51          
     52            Key control:
     53              SW1:
     54              SW2:  initiates end device binding
     55              SW3:
     56              SW4:  initiates a match description request
     57          *********************************************************************/
     58          
     59          /*********************************************************************
     60           * INCLUDES
     61           */
     62          #include "OSAL.h"
     63          #include "AF.h"
     64          #include "ZDApp.h"
     65          #include "ZDObject.h"
     66          #include "ZDProfile.h"
     67          #include "OSAL_Nv.h"
     68          #include "LQ12864.h"

   \                                 In  segment SFR_AN, at 0xa0
   \   union <unnamed> volatile __sfr _A_P2
   \                     _A_P2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xcd
   \   unsigned char volatile __sfr T3CC0
   \                     T3CC0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd8
   \   union <unnamed> volatile __sfr _A_TIMIF
   \                     _A_TIMIF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xff
   \   unsigned char volatile __sfr P2DIR
   \                     P2DIR:
   \   000000                DS 1

   \                                 In  segment CODE_C, align 1
   \   static char const __code F8X16[1520]
   \                     F8X16:
   \   000000   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 248, 0, 0
   \            00000000
   \            00000000
   \            00000000
   \            000000F8
   \            0000    
   \   000016   00000000     DB 0, 0, 0, 0, 0, 51, 48, 0, 0, 0, 0, 16, 12, 6, 16, 12, 6, 0, 0, 0, 0
   \            00333000
   \            00000010
   \            0C06100C
   \            06000000
   \            00      
   \   00002B   00000000     DB 0, 0, 0, 0, 0, 64, 192, 120, 64, 192, 120, 64, 0, 4, 63, 4, 4, 63, 4
   \            0040C078
   \            40C07840
   \            00043F04
   \            043F04  
   \   00003E   04000070     DB 4, 0, 0, 112, 136, 252, 8, 48, 0, 0, 0, 24, 32, 255, 33, 30, 0, 0
   \            88FC0830
   \            00000018
   \            20FF211E
   \            0000    
   \   000050   F008F000     DB 240, 8, 240, 0, 224, 24, 0, 0, 0, 33, 28, 3, 30, 33, 30, 0, 0, 240
   \            E0180000
   \            00211C03
   \            1E211E00
   \            00F0    
   \   000062   08887000     DB 8, 136, 112, 0, 0, 0, 30, 33, 35, 36, 25, 39, 33, 16, 16, 22, 14, 0
   \            00001E21
   \            23241927
   \            21101016
   \            0E00    
   \   000074   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 224, 24, 4, 2, 0, 0, 0
   \            00000000
   \            00000000
   \            000000E0
   \            18040200
   \            0000    
   \   00008A   00071820     DB 0, 7, 24, 32, 64, 0, 0, 2, 4, 24, 224, 0, 0, 0, 0, 64, 32, 24, 7, 0
   \            40000002
   \            0418E000
   \            00000040
   \            20180700
   \   00009E   00004040     DB 0, 0, 64, 64, 128, 240, 128, 64, 64, 0, 2, 2, 1, 15, 1, 2, 2, 0, 0
   \            80F08040
   \            40000202
   \            010F0102
   \            020000  
   \   0000B1   0000F000     DB 0, 0, 240, 0, 0, 0, 0, 1, 1, 1, 31, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000001
   \            01011F01
   \            01010000
   \            00000000
   \            0000    
   \   0000C7   0080B070     DB 0, 128, 176, 112, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1
   \            00000000
   \            00000000
   \            00000000
   \            00000101
   \            01      
   \   0000DC   01010101     DB 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00000000
   \            00303000
   \            00000000
   \            0000    
   \   0000F2   00008060     DB 0, 0, 128, 96, 24, 4, 0, 96, 24, 6, 1, 0, 0, 0, 0, 224, 16, 8, 8, 16
   \            18040060
   \            18060100
   \            000000E0
   \            10080810
   \   000106   E000000F     DB 224, 0, 0, 15, 16, 32, 32, 16, 15, 0, 0, 16, 16, 248, 0, 0, 0, 0, 0
   \            10202010
   \            0F000010
   \            10F80000
   \            000000  
   \   000119   20203F20     DB 32, 32, 63, 32, 32, 0, 0, 0, 112, 8, 8, 8, 136, 112, 0, 0, 48, 40
   \            20000000
   \            70080808
   \            88700000
   \            3028    
   \   00012B   24222130     DB 36, 34, 33, 48, 0, 0, 48, 8, 136, 136, 72, 48, 0, 0, 24, 32, 32, 32
   \            00003008
   \            88884830
   \            00001820
   \            2020    
   \   00013D   110E0000     DB 17, 14, 0, 0, 0, 192, 32, 16, 248, 0, 0, 0, 7, 4, 36, 36, 63, 36, 0
   \            00C02010
   \            F8000000
   \            07042424
   \            3F2400  
   \   000150   00F80888     DB 0, 248, 8, 136, 136, 8, 8, 0, 0, 25, 33, 32, 32, 17, 14, 0, 0, 224
   \            88080800
   \            00192120
   \            20110E00
   \            00E0    
   \   000162   10888818     DB 16, 136, 136, 24, 0, 0, 0, 15, 17, 32, 32, 17, 14, 0, 0, 56, 8, 8
   \            0000000F
   \            11202011
   \            0E000038
   \            0808    
   \   000174   C8380800     DB 200, 56, 8, 0, 0, 0, 0, 63, 0, 0, 0, 0, 0, 112, 136, 8, 8, 136, 112
   \            0000003F
   \            00000000
   \            00708808
   \            088870  
   \   000187   00001C22     DB 0, 0, 28, 34, 33, 33, 34, 28, 0, 0, 224, 16, 8, 8, 16, 224, 0, 0, 0
   \            2121221C
   \            0000E010
   \            080810E0
   \            000000  
   \   00019A   31222211     DB 49, 34, 34, 17, 15, 0, 0, 0, 0, 192, 192, 0, 0, 0, 0, 0, 0, 48, 48
   \            0F000000
   \            00C0C000
   \            00000000
   \            003030  
   \   0001AD   00000000     DB 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 128, 96, 0, 0, 0, 0, 0, 0
   \            00008000
   \            00000000
   \            00806000
   \            00000000
   \            00      
   \   0001C2   80402010     DB 128, 64, 32, 16, 8, 0, 0, 1, 2, 4, 8, 16, 32, 0, 64, 64, 64, 64, 64
   \            08000001
   \            02040810
   \            20004040
   \            404040  
   \   0001D5   40400004     DB 64, 64, 0, 4, 4, 4, 4, 4, 4, 4, 0, 0, 8, 16, 32, 64, 128, 0, 0, 0
   \            04040404
   \            04040000
   \            08102040
   \            80000000
   \   0001E9   20100804     DB 32, 16, 8, 4, 2, 1, 0, 0, 112, 72, 8, 8, 8, 240, 0, 0, 0, 0, 48, 54
   \            02010000
   \            70480808
   \            08F00000
   \            00003036
   \   0001FD   010000C0     DB 1, 0, 0, 192, 48, 200, 40, 232, 16, 224, 0, 7, 24, 39, 36, 35, 20
   \            30C828E8
   \            10E00007
   \            18272423
   \            14      
   \   00020E   0B000000     DB 11, 0, 0, 0, 192, 56, 224, 0, 0, 0, 32, 60, 35, 2, 2, 39, 56, 32, 8
   \            C038E000
   \            0000203C
   \            23020227
   \            382008  
   \   000221   F8888888     DB 248, 136, 136, 136, 112, 0, 0, 32, 63, 32, 32, 32, 17, 14, 0, 192
   \            70000020
   \            3F202020
   \            110E00C0
   \   000231   30080808     DB 48, 8, 8, 8, 8, 56, 0, 7, 24, 32, 32, 32, 16, 8, 0, 8, 248, 8, 8, 8
   \            08380007
   \            18202020
   \            10080008
   \            F8080808
   \   000245   10E00020     DB 16, 224, 0, 32, 63, 32, 32, 32, 16, 15, 0, 8, 248, 136, 136, 232, 8
   \            3F202020
   \            100F0008
   \            F88888E8
   \            08      
   \   000256   1000203F     DB 16, 0, 32, 63, 32, 32, 35, 32, 24, 0, 8, 248, 136, 136, 232, 8, 16
   \            20202320
   \            180008F8
   \            8888E808
   \            10      
   \   000267   00203F20     DB 0, 32, 63, 32, 0, 3, 0, 0, 0, 192, 48, 8, 8, 8, 56, 0, 0, 7, 24, 32
   \            00030000
   \            00C03008
   \            08083800
   \            00071820
   \   00027B   20221E02     DB 32, 34, 30, 2, 0, 8, 248, 8, 0, 0, 8, 248, 8, 32, 63, 33, 1, 1, 33
   \            0008F808
   \            000008F8
   \            08203F21
   \            010121  
   \   00028E   3F200008     DB 63, 32, 0, 8, 8, 248, 8, 8, 0, 0, 0, 32, 32, 63, 32, 32, 0, 0, 0, 0
   \            08F80808
   \            00000020
   \            203F2020
   \            00000000
   \   0002A2   0808F808     DB 8, 8, 248, 8, 8, 0, 192, 128, 128, 128, 127, 0, 0, 0, 8, 248, 136
   \            0800C080
   \            80807F00
   \            000008F8
   \            88      
   \   0002B3   C0281808     DB 192, 40, 24, 8, 0, 32, 63, 32, 1, 38, 56, 32, 0, 8, 248, 8, 0, 0, 0
   \            00203F20
   \            01263820
   \            0008F808
   \            000000  
   \   0002C6   0000203F     DB 0, 0, 32, 63, 32, 32, 32, 32, 48, 0, 8, 248, 248, 0, 248, 248, 8, 0
   \            20202020
   \            300008F8
   \            F800F8F8
   \            0800    
   \   0002D8   203F003F     DB 32, 63, 0, 63, 0, 63, 32, 0, 8, 248, 48, 192, 0, 8, 248, 8, 32, 63
   \            003F2000
   \            08F830C0
   \            0008F808
   \            203F    
   \   0002EA   20000718     DB 32, 0, 7, 24, 63, 0, 224, 16, 8, 8, 8, 16, 224, 0, 15, 16, 32, 32
   \            3F00E010
   \            08080810
   \            E0000F10
   \            2020    
   \   0002FC   20100F00     DB 32, 16, 15, 0, 8, 248, 8, 8, 8, 8, 240, 0, 32, 63, 33, 1, 1, 1, 0, 0
   \            08F80808
   \            0808F000
   \            203F2101
   \            01010000
   \   000310   E0100808     DB 224, 16, 8, 8, 8, 16, 224, 0, 15, 24, 36, 36, 56, 80, 79, 0, 8, 248
   \            0810E000
   \            0F182424
   \            38504F00
   \            08F8    
   \   000322   88888888     DB 136, 136, 136, 136, 112, 0, 32, 63, 32, 0, 3, 12, 48, 32, 0, 112
   \            7000203F
   \            2000030C
   \            30200070
   \   000332   88080808     DB 136, 8, 8, 8, 56, 0, 0, 56, 32, 33, 33, 34, 28, 0, 24, 8, 8, 248, 8
   \            38000038
   \            20212122
   \            1C001808
   \            08F808  
   \   000345   08180000     DB 8, 24, 0, 0, 0, 32, 63, 32, 0, 0, 0, 8, 248, 8, 0, 0, 8, 248, 8, 0
   \            00203F20
   \            00000008
   \            F8080000
   \            08F80800
   \   000359   1F202020     DB 31, 32, 32, 32, 32, 31, 0, 8, 120, 136, 0, 0, 200, 56, 8, 0, 0, 7
   \            201F0008
   \            78880000
   \            C8380800
   \            0007    
   \   00036B   380E0100     DB 56, 14, 1, 0, 0, 248, 8, 0, 248, 0, 8, 248, 0, 3, 60, 7, 0, 7, 60, 3
   \            00F80800
   \            F80008F8
   \            00033C07
   \            00073C03
   \   00037F   00081868     DB 0, 8, 24, 104, 128, 128, 104, 24, 8, 32, 48, 44, 3, 3, 44, 48, 32, 8
   \            80806818
   \            0820302C
   \            03032C30
   \            2008    
   \   000391   38C800C8     DB 56, 200, 0, 200, 56, 8, 0, 0, 0, 32, 63, 32, 0, 0, 0, 16, 8, 8, 8
   \            38080000
   \            00203F20
   \            00000010
   \            080808  
   \   0003A4   C8380800     DB 200, 56, 8, 0, 32, 56, 38, 33, 32, 32, 24, 0, 0, 0, 0, 254, 2, 2, 2
   \            20382621
   \            20201800
   \            000000FE
   \            020202  
   \   0003B7   00000000     DB 0, 0, 0, 0, 127, 64, 64, 64, 0, 0, 12, 48, 192, 0, 0, 0, 0, 0, 0, 0
   \            7F404040
   \            00000C30
   \            C0000000
   \            00000000
   \   0003CB   010638C0     DB 1, 6, 56, 192, 0, 0, 2, 2, 2, 254, 0, 0, 0, 0, 64, 64, 64, 127, 0, 0
   \            00000202
   \            02FE0000
   \            00004040
   \            407F0000
   \   0003DF   00000004     DB 0, 0, 0, 4, 2, 2, 2, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            02020204
   \            00000000
   \            00000000
   \            00000000
   \            000000  
   \   0003F6   00008080     DB 0, 0, 128, 128, 128, 128, 128, 128, 128, 128, 0, 2, 2, 4, 0, 0, 0, 0
   \            80808080
   \            80800002
   \            02040000
   \            0000    
   \   000408   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 128, 128, 128, 0, 0, 0, 25, 36
   \            00000000
   \            00008080
   \            80800000
   \            001924  
   \   00041B   2222223F     DB 34, 34, 34, 63, 32, 8, 248, 0, 128, 128, 0, 0, 0, 0, 63, 17, 32, 32
   \            2008F800
   \            80800000
   \            00003F11
   \            2020    
   \   00042D   110E0000     DB 17, 14, 0, 0, 0, 0, 128, 128, 128, 0, 0, 0, 14, 17, 32, 32, 32, 17
   \            00008080
   \            80000000
   \            0E112020
   \            2011    
   \   00043F   00000000     DB 0, 0, 0, 0, 128, 128, 136, 248, 0, 0, 14, 17, 32, 32, 16, 63, 32, 0
   \            808088F8
   \            00000E11
   \            2020103F
   \            2000    
   \   000451   00808080     DB 0, 128, 128, 128, 128, 0, 0, 0, 31, 34, 34, 34, 34, 19, 0, 0, 128
   \            80000000
   \            1F222222
   \            22130000
   \            80      
   \   000462   80F08888     DB 128, 240, 136, 136, 136, 24, 0, 32, 32, 63, 32, 32, 0, 0, 0, 0, 128
   \            88180020
   \            203F2020
   \            00000000
   \            80      
   \   000473   80808080     DB 128, 128, 128, 128, 0, 0, 107, 148, 148, 148, 147, 96, 0, 8, 248, 0
   \            00006B94
   \            94949360
   \            0008F800
   \   000483   80808000     DB 128, 128, 128, 0, 0, 32, 63, 33, 0, 0, 32, 63, 32, 0, 128, 152, 152
   \            00203F21
   \            0000203F
   \            20008098
   \            98      
   \   000494   00000000     DB 0, 0, 0, 0, 0, 32, 32, 63, 32, 32, 0, 0, 0, 0, 0, 128, 152, 152, 0
   \            0020203F
   \            20200000
   \            00000080
   \            989800  
   \   0004A7   0000C080     DB 0, 0, 192, 128, 128, 128, 127, 0, 0, 8, 248, 0, 0, 128, 128, 128, 0
   \            80807F00
   \            0008F800
   \            00808080
   \            00      
   \   0004B8   203F2402     DB 32, 63, 36, 2, 45, 48, 32, 0, 0, 8, 8, 248, 0, 0, 0, 0, 0, 32, 32
   \            2D302000
   \            000808F8
   \            00000000
   \            002020  
   \   0004CB   3F202000     DB 63, 32, 32, 0, 0, 128, 128, 128, 128, 128, 128, 128, 0, 32, 63, 32
   \            00808080
   \            80808080
   \            00203F20
   \   0004DB   003F2000     DB 0, 63, 32, 0, 63, 128, 128, 0, 128, 128, 128, 0, 0, 32, 63, 33, 0, 0
   \            3F808000
   \            80808000
   \            00203F21
   \            0000    
   \   0004ED   203F2000     DB 32, 63, 32, 0, 0, 128, 128, 128, 128, 0, 0, 0, 31, 32, 32, 32, 32
   \            00808080
   \            80000000
   \            1F202020
   \            20      
   \   0004FE   1F008080     DB 31, 0, 128, 128, 0, 128, 128, 0, 0, 0, 128, 255, 161, 32, 32, 17, 14
   \            00808000
   \            000080FF
   \            A1202011
   \            0E      
   \   00050F   00000000     DB 0, 0, 0, 0, 128, 128, 128, 128, 0, 0, 14, 17, 32, 32, 160, 255, 128
   \            80808080
   \            00000E11
   \            2020A0FF
   \            80      
   \   000520   80808000     DB 128, 128, 128, 0, 128, 128, 128, 0, 32, 32, 63, 33, 32, 0, 1, 0, 0
   \            80808000
   \            20203F21
   \            20000100
   \            00      
   \   000531   00808080     DB 0, 128, 128, 128, 128, 128, 0, 0, 51, 36, 36, 36, 36, 25, 0, 0, 128
   \            80800000
   \            33242424
   \            24190000
   \            80      
   \   000542   80E08080     DB 128, 224, 128, 128, 0, 0, 0, 0, 0, 31, 32, 32, 0, 0, 128, 128, 0, 0
   \            00000000
   \            001F2020
   \            00008080
   \            0000    
   \   000554   00808000     DB 0, 128, 128, 0, 0, 31, 32, 32, 32, 16, 63, 32, 128, 128, 128, 0, 0
   \            001F2020
   \            20103F20
   \            80808000
   \            00      
   \   000565   80808000     DB 128, 128, 128, 0, 1, 14, 48, 8, 6, 1, 0, 128, 128, 0, 128, 0, 128
   \            010E3008
   \            06010080
   \            80008000
   \            80      
   \   000576   80800F30     DB 128, 128, 15, 48, 12, 3, 12, 48, 15, 0, 0, 128, 128, 0, 128, 128
   \            0C030C30
   \            0F000080
   \            80008080
   \   000586   80000020     DB 128, 0, 0, 32, 49, 46, 14, 49, 32, 0, 128, 128, 128, 0, 0, 128, 128
   \            312E0E31
   \            20008080
   \            80000080
   \            80      
   \   000597   8080818E     DB 128, 128, 129, 142, 112, 24, 6, 1, 0, 0, 128, 128, 128, 128, 128
   \            70180601
   \            00008080
   \            808080  
   \   0005A6   80000021     DB 128, 0, 0, 33, 48, 44, 34, 33, 48, 0, 0, 0, 0, 0, 128, 124, 2, 2, 0
   \            302C2221
   \            30000000
   \            0000807C
   \            020200  
   \   0005B9   00000000     DB 0, 0, 0, 0, 63, 64, 64, 0, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 255, 0
   \            3F404000
   \            000000FF
   \            00000000
   \            000000FF
   \            00      
   \   0005CE   00000002     DB 0, 0, 0, 2, 2, 124, 128, 0, 0, 0, 0, 64, 64, 63, 0, 0, 0, 0, 0, 6, 1
   \            027C8000
   \            00000040
   \            403F0000
   \            00000006
   \            01      
   \   0005E3   01020204     DB 1, 2, 2, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0
   \            04000000
   \            00000000
   \            00      

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant void OLED_delay(unsigned int)
   \                     OLED_delay:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   EA           MOV     A,R2
   \   000001   F8           MOV     R0,A
   \   000002   EB           MOV     A,R3
   \   000003   8007         SJMP    ??OLED_delay_0
   \                     ??OLED_delay_1:
   \   000005   E8           MOV     A,R0
   \   000006   24FF         ADD     A,#-0x1
   \   000008   18           DEC     R0
   \   000009   E9           MOV     A,R1
   \   00000A   34FF         ADDC    A,#-0x1
   \                     ??OLED_delay_0:
   \   00000C   F9           MOV     R1,A
   \   00000D   E8           MOV     A,R0
   \   00000E   7001         JNZ     ??OLED_delay_2
   \   000010   E9           MOV     A,R1
   \                     ??OLED_delay_2:
   \   000011   00           NOP
   \   000012   70F1         JNZ     ??OLED_delay_1
   \   000014   80..         SJMP    ??Subroutine27_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine27_0:
   \   000000   00           NOP
   \   000001   00           NOP
   \   000002   00           NOP
   \   000003   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant void OLED_IIC_Start(void)
   \                     OLED_IIC_Start:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   D2A2         SETB    0xa0.2
   \   000002   D2A1         SETB    0xa0.1
   \   000004   00           NOP
   \   000005   00           NOP
   \   000006   00           NOP
   \   000007   00           NOP
   \   000008   00           NOP
   \   000009   C2A1         CLR     0xa0.1
   \   00000B   80..         SJMP    ?Subroutine0
   \   00000D                REQUIRE _A_P2

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   C2A2         CLR     0xa0.2
   \   000002                REQUIRE ??Subroutine26_0
   \   000002                ; // Fall through to label ??Subroutine26_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine26_0:
   \   000000   00           NOP
   \   000001   00           NOP
   \   000002                REQUIRE ??Subroutine27_0
   \   000002                ; // Fall through to label ??Subroutine27_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant void OLED_IIC_Stop(void)
   \                     OLED_IIC_Stop:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   C2A2         CLR     0xa0.2
   \   000002   C2A1         CLR     0xa0.1
   \   000004   00           NOP
   \   000005   00           NOP
   \   000006   00           NOP
   \   000007   00           NOP
   \   000008   00           NOP
   \   000009   D2A2         SETB    0xa0.2
   \   00000B   D2A1         SETB    0xa0.1
   \   00000D   80..         SJMP    ??Subroutine26_0
   \   00000F                REQUIRE _A_P2

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant void Write_IIC_Byte(unsigned char)
   \                     Write_IIC_Byte:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   7A08         MOV     R2,#0x8
   \                     ??Write_IIC_Byte_0:
   \   000002   E9           MOV     A,R1
   \   000003   A2E7         MOV     C,0xE0 /* A   */.7
   \   000005   5004         JNC     ??Write_IIC_Byte_1
   \   000007   D2A1         SETB    0xa0.1
   \   000009   8002         SJMP    ??Write_IIC_Byte_2
   \                     ??Write_IIC_Byte_1:
   \   00000B   C2A1         CLR     0xa0.1
   \                     ??Write_IIC_Byte_2:
   \   00000D   D2A2         SETB    0xa0.2
   \   00000F   00           NOP
   \   000010   00           NOP
   \   000011   00           NOP
   \   000012   00           NOP
   \   000013   00           NOP
   \   000014   C2A2         CLR     0xa0.2
   \   000016   C3           CLR     C
   \   000017   33           RLC     A
   \   000018   F9           MOV     R1,A
   \   000019   00           NOP
   \   00001A   00           NOP
   \   00001B   00           NOP
   \   00001C   00           NOP
   \   00001D   00           NOP
   \   00001E   1A           DEC     R2
   \   00001F   EA           MOV     A,R2
   \   000020   70E0         JNZ     ??Write_IIC_Byte_0
   \   000022   D2A1         SETB    0xa0.1
   \   000024   D2A2         SETB    0xa0.2
   \   000026   00           NOP
   \   000027   00           NOP
   \   000028   00           NOP
   \   000029   00           NOP
   \   00002A   00           NOP
   \   00002B   80..         SJMP    ?Subroutine0
   \   00002D                REQUIRE _A_P2

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant void OLED_WrDat(unsigned char)
   \                     OLED_WrDat:
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000008                ; Setup parameters for call to function Write_IIC_Byte
   \   000008   7940         MOV     R1,#0x40
   \   00000A   80..         SJMP    ?Subroutine2

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   E9           MOV     A,R1
   \   000001   FE           MOV     R6,A
   \   000002                ; Setup parameters for call to function OLED_IIC_Start
   \   000002                ; Setup parameters for call to function OLED_IIC_Start
   \   000002   12....       LCALL   ??OLED_IIC_Start?relay
   \   000005                ; Setup parameters for call to function Write_IIC_Byte
   \   000005                ; Setup parameters for call to function Write_IIC_Byte
   \   000005   7978         MOV     R1,#0x78
   \   000007   12....       LCALL   ??Write_IIC_Byte?relay
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   ??Write_IIC_Byte?relay
   \   000003                ; Setup parameters for call to function Write_IIC_Byte
   \   000003                ; Setup parameters for call to function Write_IIC_Byte
   \   000003   EE           MOV     A,R6
   \   000004   F9           MOV     R1,A
   \   000005   12....       LCALL   ??Write_IIC_Byte?relay
   \   000008                ; Setup parameters for call to function OLED_IIC_Stop
   \   000008                ; Setup parameters for call to function OLED_IIC_Stop
   \   000008   12....       LCALL   ??OLED_IIC_Stop?relay
   \   00000B                REQUIRE ??Subroutine28_0
   \   00000B                ; // Fall through to label ??Subroutine28_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine28_0:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant void OLED_WrCmd(unsigned char)
   \                     OLED_WrCmd:
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000008                ; Setup parameters for call to function Write_IIC_Byte
   \   000008   7900         MOV     R1,#0x0
   \   00000A   80..         SJMP    ?Subroutine2

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant void OLED_Set_Pos(unsigned char, unsigned char)
   \                     OLED_Set_Pos:
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   EA           MOV     A,R2
   \   000008   FF           MOV     R7,A
   \   000009                ; Setup parameters for call to function OLED_WrCmd
   \   000009   74B0         MOV     A,#-0x50
   \   00000B   2F           ADD     A,R7
   \   00000C   F9           MOV     R1,A
   \   00000D   12....       LCALL   ??OLED_WrCmd?relay
   \   000010                ; Setup parameters for call to function OLED_WrCmd
   \   000010   EE           MOV     A,R6
   \   000011   C4           SWAP    A
   \   000012   540F         ANL     A,#0xf
   \   000014   4410         ORL     A,#0x10
   \   000016   F9           MOV     R1,A
   \   000017   12....       LCALL   ??OLED_WrCmd?relay
   \   00001A                ; Setup parameters for call to function OLED_WrCmd
   \   00001A   740F         MOV     A,#0xf
   \   00001C   5E           ANL     A,R6
   \   00001D   4401         ORL     A,#0x1
   \   00001F   F9           MOV     R1,A
   \   000020   12....       LCALL   ??OLED_WrCmd?relay
   \   000023   80..         SJMP    ??Subroutine28_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant void OLED_Fill(unsigned char)
   \                     OLED_Fill:
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   75..00       MOV     ?V0 + 0,#0x0
   \                     ??OLED_Fill_0:
   \   00000A                ; Setup parameters for call to function OLED_WrCmd
   \   00000A   74B0         MOV     A,#-0x50
   \   00000C   25..         ADD     A,?V0 + 0
   \   00000E   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000011   7F80         MOV     R7,#-0x80
   \                     ??OLED_Fill_1:
   \   000013                ; Setup parameters for call to function OLED_WrDat
   \   000013   EE           MOV     A,R6
   \   000014   F9           MOV     R1,A
   \   000015   12....       LCALL   ??OLED_WrDat?relay
   \   000018   1F           DEC     R7
   \   000019   EF           MOV     A,R7
   \   00001A   70F7         JNZ     ??OLED_Fill_1
   \   00001C   05..         INC     ?V0 + 0
   \   00001E   E5..         MOV     A,?V0 + 0
   \   000020   C3           CLR     C
   \   000021   9408         SUBB    A,#0x8
   \   000023   40E5         JC      ??OLED_Fill_0
   \   000025   80..         SJMP    ??Subroutine28_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   F9           MOV     R1,A
   \   000001   12....       LCALL   ??OLED_WrCmd?relay
   \   000004                ; Setup parameters for call to function OLED_WrCmd
   \   000004                ; Setup parameters for call to function OLED_WrCmd
   \   000004   7901         MOV     R1,#0x1
   \   000006   12....       LCALL   ??OLED_WrCmd?relay
   \   000009                ; Setup parameters for call to function OLED_WrCmd
   \   000009                ; Setup parameters for call to function OLED_WrCmd
   \   000009   7910         MOV     R1,#0x10
   \   00000B   12....       LCALL   ??OLED_WrCmd?relay
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant void OLED_CLS(void)
   \                     OLED_CLS:
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   7F00         MOV     R7,#0x0
   \                     ??OLED_CLS_0:
   \   000007                ; Setup parameters for call to function OLED_WrCmd
   \   000007   74B0         MOV     A,#-0x50
   \   000009   2F           ADD     A,R7
   \   00000A   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   00000D   7E80         MOV     R6,#-0x80
   \                     ??OLED_CLS_1:
   \   00000F                ; Setup parameters for call to function OLED_WrDat
   \   00000F   7900         MOV     R1,#0x0
   \   000011   12....       LCALL   ??OLED_WrDat?relay
   \   000014   1E           DEC     R6
   \   000015   EE           MOV     A,R6
   \   000016   70F7         JNZ     ??OLED_CLS_1
   \   000018   0F           INC     R7
   \   000019   EF           MOV     A,R7
   \   00001A   C3           CLR     C
   \   00001B   9408         SUBB    A,#0x8
   \   00001D   40E8         JC      ??OLED_CLS_0
   \   00001F   80..         SJMP    ??Subroutine28_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant void OLED_Init(void)
   \                     OLED_Init:
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   43FF06       ORL     0xff,#0x6
   \   000007   E5FF         MOV     A,0xff
   \   000009                ; Setup parameters for call to function OLED_delay
   \   000009   7AF4         MOV     R2,#-0xc
   \   00000B   7B01         MOV     R3,#0x1
   \   00000D   12....       LCALL   ??OLED_delay?relay
   \   000010                ; Setup parameters for call to function OLED_WrCmd
   \   000010   79AE         MOV     R1,#-0x52
   \   000012   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000015                ; Setup parameters for call to function OLED_WrCmd
   \   000015   7910         MOV     R1,#0x10
   \   000017   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   00001A                ; Setup parameters for call to function OLED_WrCmd
   \   00001A   7981         MOV     R1,#-0x7f
   \   00001C   12....       LCALL   ??OLED_WrCmd?relay
   \   00001F                ; Setup parameters for call to function OLED_WrCmd
   \   00001F   79CF         MOV     R1,#-0x31
   \   000021   12....       LCALL   ??OLED_WrCmd?relay
   \   000024                ; Setup parameters for call to function OLED_WrCmd
   \   000024   79A1         MOV     R1,#-0x5f
   \   000026   12....       LCALL   ??OLED_WrCmd?relay
   \   000029                ; Setup parameters for call to function OLED_WrCmd
   \   000029   79C8         MOV     R1,#-0x38
   \   00002B   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   00002E                ; Setup parameters for call to function OLED_WrCmd
   \   00002E   79A8         MOV     R1,#-0x58
   \   000030   12....       LCALL   ??OLED_WrCmd?relay
   \   000033                ; Setup parameters for call to function OLED_WrCmd
   \   000033   793F         MOV     R1,#0x3f
   \   000035   12....       LCALL   ??OLED_WrCmd?relay
   \   000038                ; Setup parameters for call to function OLED_WrCmd
   \   000038   79D3         MOV     R1,#-0x2d
   \   00003A   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00003D                ; Setup parameters for call to function OLED_WrCmd
   \   00003D   79D5         MOV     R1,#-0x2b
   \   00003F   12....       LCALL   ??OLED_WrCmd?relay
   \   000042                ; Setup parameters for call to function OLED_WrCmd
   \   000042   7980         MOV     R1,#-0x80
   \   000044   12....       LCALL   ??OLED_WrCmd?relay
   \   000047                ; Setup parameters for call to function OLED_WrCmd
   \   000047   79D9         MOV     R1,#-0x27
   \   000049   12....       LCALL   ??OLED_WrCmd?relay
   \   00004C                ; Setup parameters for call to function OLED_WrCmd
   \   00004C   79F1         MOV     R1,#-0xf
   \   00004E   12....       LCALL   ??OLED_WrCmd?relay
   \   000051                ; Setup parameters for call to function OLED_WrCmd
   \   000051   79DA         MOV     R1,#-0x26
   \   000053   12....       LCALL   ??OLED_WrCmd?relay
   \   000056                ; Setup parameters for call to function OLED_WrCmd
   \   000056   7912         MOV     R1,#0x12
   \   000058   12....       LCALL   ??OLED_WrCmd?relay
   \   00005B                ; Setup parameters for call to function OLED_WrCmd
   \   00005B   79DB         MOV     R1,#-0x25
   \   00005D   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000060                ; Setup parameters for call to function OLED_WrCmd
   \   000060   7920         MOV     R1,#0x20
   \   000062   12....       LCALL   ??OLED_WrCmd?relay
   \   000065                ; Setup parameters for call to function OLED_WrCmd
   \   000065   7902         MOV     R1,#0x2
   \   000067   12....       LCALL   ??OLED_WrCmd?relay
   \   00006A                ; Setup parameters for call to function OLED_WrCmd
   \   00006A   798D         MOV     R1,#-0x73
   \   00006C   12....       LCALL   ??OLED_WrCmd?relay
   \   00006F                ; Setup parameters for call to function OLED_WrCmd
   \   00006F   7914         MOV     R1,#0x14
   \   000071   12....       LCALL   ??OLED_WrCmd?relay
   \   000074                ; Setup parameters for call to function OLED_WrCmd
   \   000074   79A4         MOV     R1,#-0x5c
   \   000076   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000079                ; Setup parameters for call to function OLED_WrCmd
   \   000079   79AF         MOV     R1,#-0x51
   \   00007B   12....       LCALL   ??OLED_WrCmd?relay
   \   00007E                ; Setup parameters for call to function OLED_Fill
   \   00007E   7900         MOV     R1,#0x0
   \   000080   12....       LCALL   ??OLED_Fill?relay
   \   000083                ; Setup parameters for call to function OLED_Set_Pos
   \   000083   7A00         MOV     R2,#0x0
   \   000085   7900         MOV     R1,#0x0
   \   000087   12....       LCALL   ??OLED_Set_Pos?relay
   \   00008A                REQUIRE ?Subroutine1
   \   00008A                REQUIRE P2DIR
   \   00008A                ; // Fall through to label ?Subroutine1

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   12....       LCALL   ??OLED_WrCmd?relay
   \   000003                ; Setup parameters for call to function OLED_WrCmd
   \   000003                ; Setup parameters for call to function OLED_WrCmd
   \   000003   79A6         MOV     R1,#-0x5a
   \   000005   12....       LCALL   ??OLED_WrCmd?relay
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   12....       LCALL   ??OLED_WrCmd?relay
   \   000003                ; Setup parameters for call to function OLED_WrCmd
   \   000003                ; Setup parameters for call to function OLED_WrCmd
   \   000003   7940         MOV     R1,#0x40
   \   000005   12....       LCALL   ??OLED_WrCmd?relay
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   12....       LCALL   ??OLED_WrCmd?relay
   \   000003                ; Setup parameters for call to function OLED_WrCmd
   \   000003                ; Setup parameters for call to function OLED_WrCmd
   \   000003   7900         MOV     R1,#0x0
   \   000005   12....       LCALL   ??OLED_WrCmd?relay
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant void OLED_P8x16Str(unsigned char, unsigned char, char *)
   \                     OLED_P8x16Str:
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   8A..         MOV     ?V0 + 1,R2
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   \   00000D   43FF06       ORL     0xff,#0x6
   \   000010   E5FF         MOV     A,0xff
   \   000012   75..00       MOV     ?V0 + 7,#0x0
   \   000015   805D         SJMP    ??OLED_P8x16Str_0
   \                     ??OLED_P8x16Str_1:
   \   000017   24E0         ADD     A,#-0x20
   \   000019   F5..         MOV     ?V0 + 4,A
   \   00001B   E5..         MOV     A,?V0 + 0
   \   00001D   C3           CLR     C
   \   00001E   9479         SUBB    A,#0x79
   \   000020   4005         JC      ??OLED_P8x16Str_2
   \   000022   75..00       MOV     ?V0 + 0,#0x0
   \   000025   05..         INC     ?V0 + 1
   \                     ??OLED_P8x16Str_2:
   \   000027                ; Setup parameters for call to function OLED_Set_Pos
   \   000027   AA..         MOV     R2,?V0 + 1
   \   000029   A9..         MOV     R1,?V0 + 0
   \   00002B   12....       LCALL   ??OLED_Set_Pos?relay
   \   00002E   75..00       MOV     ?V0 + 6,#0x0
   \   000031   75..00       MOV     ?V0 + 5,#0x0
   \   000034   7404         MOV     A,#0x4
   \   000036   78..         MOV     R0,#?V0 + 4
   \   000038   12....       LCALL   ?S_SHL
   \   00003B   85....       MOV     ?V0 + 2,?V0 + 4
   \   00003E   85....       MOV     ?V0 + 3,?V0 + 5
   \                     ??OLED_P8x16Str_3:
   \   000041                ; Setup parameters for call to function OLED_WrDat
   \   000041   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000044   24..         ADD     A,#(F8X16 & 0xff)
   \   000046   F582         MOV     DPL,A
   \   000048   E9           MOV     A,R1
   \   000049   34..         ADDC    A,#((F8X16 >> 8) & 0xff)
   \   00004B   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   00004E   40F1         JC      ??OLED_P8x16Str_3
   \   000050                ; Setup parameters for call to function OLED_Set_Pos
   \   000050   7401         MOV     A,#0x1
   \   000052   25..         ADD     A,?V0 + 1
   \   000054   FA           MOV     R2,A
   \   000055   A9..         MOV     R1,?V0 + 0
   \   000057   12....       LCALL   ??OLED_Set_Pos?relay
   \   00005A   75..00       MOV     ?V0 + 6,#0x0
   \                     ??OLED_P8x16Str_4:
   \   00005D                ; Setup parameters for call to function OLED_WrDat
   \   00005D   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000060   24..         ADD     A,#((F8X16 + 8) & 0xff)
   \   000062   F582         MOV     DPL,A
   \   000064   E9           MOV     A,R1
   \   000065   34..         ADDC    A,#(((F8X16 + 8) >> 8) & 0xff)
   \   000067   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   00006A   40F1         JC      ??OLED_P8x16Str_4
   \   00006C   7408         MOV     A,#0x8
   \   00006E   25..         ADD     A,?V0 + 0
   \   000070   F5..         MOV     ?V0 + 0,A
   \   000072   05..         INC     ?V0 + 7
   \                     ??OLED_P8x16Str_0:
   \   000074   85....       MOV     ?V0 + 2,?V0 + 7
   \   000077   EE           MOV     A,R6
   \   000078   25..         ADD     A,?V0 + 2
   \   00007A   F582         MOV     DPL,A
   \   00007C   EF           MOV     A,R7
   \   00007D   3400         ADDC    A,#0x0
   \   00007F   F583         MOV     DPH,A
   \   000081   E0           MOVX    A,@DPTR
   \   000082   7093         JNZ     ??OLED_P8x16Str_1
   \   000084   53FFF9       ANL     0xff,#0xf9
   \   000087   E5FF         MOV     A,0xff
   \   000089   7F08         MOV     R7,#0x8
   \   00008B   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00008E                REQUIRE P2DIR

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   85....       MOV     ?V0 + 4,?V0 + 6
   \   000003   E5..         MOV     A,?V0 + 4
   \   000005   25..         ADD     A,?V0 + 2
   \   000007   F8           MOV     R0,A
   \   000008   E4           CLR     A
   \   000009   35..         ADDC    A,?V0 + 3
   \   00000B   F9           MOV     R1,A
   \   00000C   E8           MOV     A,R0
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   F583         MOV     DPH,A
   \   000002   E4           CLR     A
   \   000003   93           MOVC    A,@A+DPTR
   \   000004   F9           MOV     R1,A
   \   000005   12....       LCALL   ??OLED_WrDat?relay
   \   000008   05..         INC     ?V0 + 6
   \   00000A   E5..         MOV     A,?V0 + 6
   \   00000C   C3           CLR     C
   \   00000D   9408         SUBB    A,#0x8
   \   00000F   22           RET
     69          #include "delay.h"
     70          
     71          #include "GenericApp.h"
     72          #include "DebugTrace.h"
     73          
     74          #if !defined( WIN32 )
     75            #include "OnBoard.h"
     76          #endif
     77          
     78          /* HAL */
     79          
     80          #include "hal_adc.h"
     81          #include "hal_lcd.h"
     82          #include "hal_led.h"
     83          #include "hal_key.h"  
     84          #include "hal_uart.h"
     85          #include "MT_UART.h"
     86          #include "appr51.h"
     87          #if((SENSOR_TYPE =='U')||(SENSOR_TYPE ==0X06))
     88          #include "18B20.h"
     89          #endif 
     90          #if(SENSOR_TYPE =='E')
     91          #include "SHT1x.h"  
     92          #endif 
     93          #if(SENSOR_TYPE ==0X85)
     94          #include "MLX90615.h" 
     95            char data[9]={0x5A,0x5a,0x45,0x04,0x00,0x00,0xaa,0xaa,0x00};
     96          #endif 
     97          #if(SENSOR_TYPE ==0X08) 
     98          #define TRF7970A   //Èç¹û ÊÇTRF7970A´ò¿ª´Ë¶¨Òå ¡£Èç¹ûÊÇTRF7960ÆÁ±Î´Ë¶¨Òå
     99          #endif
    100          #if(SENSOR_TYPE ==0X82)
    101          #include "HMC5883.H"  
    102          #define PI  3.14159265
    103          #define M_PI  3.14159265
    104          unsigned char T_MUMPT_y=0;    // ¼ÇÂ¼ÊýÖµ½øÐÐ±È½Ï
    105          unsigned char T_MUMPT_z=0;    // ¼ÇÂ¼ÊýÖµ½øÐÐ±È½Ï
    106          float HMC5883_x,HMC5883_y,HMC5883_z;
    107          #endif 
    108          #if(SENSOR_TYPE ==0X07)
    109          unsigned char AB;
    110          #endif
    111          #if(SENSOR_TYPE ==0X14) 
    112          #if defined(PH_E201C)
    113          #include "18B20.h"
    114          #endif 
    115          #endif 
    116          
    117          #if(ZDO_COORDINATOR==2)  //ZIGBEE  ATÃüÁîÄ£Ê½ Í¸´«Ä£Ê½
    118          uint8 FT_AT=0;//0 ÃüÁîÄ£Ê½//1 Í¸´«Ä£Ê½
    119          #endif
    120          
    121          #if defined (NB_IOT_S10)
    122            unsigned char NBliucheng=0;//Á÷³Ì±êºÅ
    123            unsigned int NBjishu=0;//¼ÆÊýÖÜÆÚ
    124            unsigned char NB_IMEI[16]={0};//IMEIºÅ
    125            unsigned char NB_S=0;//ÄÚÈÝ³¤¶È
    126          #endif
    127          
    128          #if(SENSOR_TYPE ==0X76)
    129           unsigned int lens=0;
    130           unsigned char p=0;
    131          #endif
    132          #if(SENSOR_TYPE ==0X65)
    133          #include "lcd12232.h"
    134          #endif 
    135          #if(SENSOR_TYPE ==0X6B)
    136          //#define LEDA8  //¶¨Òå A8¹ã¸æ»ú ÆÁ±Î ledÏÔÊ¾ÆÁ
    137          //#define LED16X64  //¶¨ÒåledÏÔÊ¾ÆÁ
    138          #endif
    139          #if(SENSOR_TYPE ==0X6C)
    140          #define CS P1_7//Æ¬Ñ¡ÐÅºÅ
    141           #define SDA P1_6//Êý¾ÝÐÅºÅ
    142           #define SCLK P1_5//Ê±ÖÓÐÅºÅ 
    143          #define code __code
    144          #define com  0
    145          #define dat  1
    146          const unsigned char code tab0[]={
    147          "  ÎÞÎý·ºÌ«¿Æ¼¼    ¹«½»¹ÜÀíÏµÍ³  "}; 
    148          const unsigned char code tab1[]={
    149          "    Â·¹«½»Î´Ê»³ö¹«½»Ê×Ä©Õ¾, Çë³Ë¿ÍÄÍÐÄµÈ´ý"};   
    150          const unsigned char code tab2[]={
    151          "    Â·¹«½»ÒÑµ½´ï±¾Õ¾, Çë³Ë¿Í°´´ÎÐòÉÏÏÂ³µ"};  
    152          const unsigned char code tab3[]={
    153          "    Â·¹«½»Àë±¾Õ¾»¹ÓÐ    Õ¾, Ô¤¼Æ    ·ÖÖÓºóµ½´ï"};
    154          
    155          unsigned char str0[];
    156          //unsigned char str1[]={"0123456789"};
    157          const unsigned char code str1[]={
    158          "0 1 2 3 4 5 6 7 8 9 " 
    159          };
    160          const unsigned char code str2[]="ÎÞÎý¹«½»Ê×Ä©Õ¾  ";
    161          const unsigned char code str3[]="  ÎÞÎý»ð³µÕ¾    ";
    162          const unsigned char code str4[]="    ½­ÄÏ´óÑ§    ";
    163          const unsigned char code str5[]="    ó»ºþ¹«Ô°    ";
    164          
    165          #endif 
    166          #if(SENSOR_TYPE ==0X6F)
    167          #define CS P1_7//Æ¬Ñ¡ÐÅºÅ
    168           #define SDA P1_6//Êý¾ÝÐÅºÅ
    169           #define SCLK P1_5//Ê±ÖÓÐÅºÅ 
    170          #define code __code
    171          #define com  0
    172          #define dat  1
    173          #endif 
    174          #if(SENSOR_TYPE ==0X28)
    175          #include "LCD_SPI.h"
    176          #endif 
    177          #if(SENSOR_TYPE ==0X33)
    178          #include "B_LUX_V30.h"
    179          #endif 
    180          #if(SENSOR_TYPE ==0X83)
    181          unsigned char PDI=0;
    182          #endif  
    183          
    184          #if(SENSOR_TYPE ==0X6A) 
    185          #if defined(HX711P) 
    186          #include <HX711.h>   
    187          #endif 
    188          #endif 
    189          #if(SENSOR_TYPE ==0X79)
    190          #include "SHT1x.h"  
    191          unsigned char PDI=0;
    192          unsigned char ERR_TEMP=0;
    193          unsigned char T_TEMP=0;
    194          unsigned char T_ADC=0;
    195          #endif  
    196          #if(SENSOR_TYPE ==0X66)
    197          #include "LCD.h"
    198          unsigned char Disp_Tab[10] ={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90};
    199          unsigned int LedNumVal=88;
    200          unsigned char LEDtime=0;//LEDÏÔÊ¾Ê±¼ä¼ÇÂ¼
    201          unsigned char LED_HL=0;//LEDÏÔÊ¾ÊýÂë¶Ì
    202          #endif 
    203          
    204          #if(SENSOR_TYPE ==0X78)
    205          unsigned char data_buf[9]={0};
    206          unsigned char data_RPY=0;
    207          //int ROLL=0,PITCH=0,YAW=0;
    208          //int rpy[3]={0},Acc[3]={0},Gyr[3]={0},Mag[3]={0},Q[4]={0};
    209          
    210          #endif  
    211          #if(SENSOR_TYPE ==0X81)
    212           unsigned int max_byte ,bytee,t; 
    213          #define SO P1_5 
    214          #define CS P1_6 
    215          #define SCK P1_7
    216          #endif
    217          #if(SENSOR_TYPE ==0X6E)
    218          #include "LCD.h"
    219          #endif 
    220          #if(SENSOR_TYPE =='Q')
    221          #include <HX711.h>
    222          #include <HT1621B.h>
    223          uchar  Ht1621Tab[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
    224          uchar  table1[]={0x0B,0x00,0x07,0x05,0x0C,0x0D,0x0F,0x00,0x0F,0x0D};//0123456789
    225          uchar  table2[]={0x0E,0x06,0x0C,0x0E,0x06,0x0A,0x0A,0x0E,0x0E,0x0E};//0123456789
    226          unsigned char  RS=0, RSn=0;
    227          unsigned char  HXS=0,HX_Q=0;
    228          unsigned int  HXtime=0;
    229          unsigned char AD_SHINING=83;  //µ÷½Ú³ÐÖØÎó²î²ÎÊý  50-150Ö®¼ä
    230          #endif 
    231          //¶¨Ê±3
    232          /* Çå³ýTIMER3ÖÐ¶Ï±êÖ¾Î» */
    233          /********************************************************************/
    234          #define CLR_TIMER34_IF( bitMask ) TIMIF=(TIMIF&0x40)|(0x3F&(~bitMask))
    235          /* ³õÊ¼»¯¶¨Ê±Æ÷3ºê¶¨Òå */
    236          #define TIMER34_INIT(timer)   \
    237             do {                       \
    238                T##timer##CTL   = 0xEF; \
    239             } while (0)
    240          // ¶¨Ê±Æ÷3Ê¹ÄÜ
    241          #define TIMER3_RUN(value)      (T3CTL = (value) ? T3CTL | 0x10 : T3CTL & ~0x10)
    242          /********************************************************************/
    243          #define NOP()  asm("NOP")
    244          #if(SENSOR_TYPE =='B')
    245          #include  "mma7660.h"
    246          #endif 
    247          #if(SENSOR_TYPE =='C')
    248          #include "IIC.h"
    249          #endif 
    250          #if(SENSOR_TYPE =='F')
    251          #if defined(BMP085) 
    252          #include "IIC.h"
    253          #endif 
    254          #if defined(BMP180) 
    255          #include "bmp180.h"
    256                
    257          #endif 
    258          #endif 
    259          
    260          
    261          
    262          /*********************************************************************
    263           * MACROS
    264           */
    265          #if(SENSOR_TYPE =='B')
    266          #define uchar unsigned char
    267          #define uint unsigned int
    268          int Xavg8,Yavg8,Zavg8;//´æ·ÅÆ½¾ùÖµ
    269          int Xraw[RawDataLength],Yraw[RawDataLength],Zraw[RawDataLength]; //8¸ö¿Õ¼äµÄÊý×é£¬²É¼¯8¸öÊýÈ¡Ò»´ÎÆ½¾ù
    270          int Xnew8,Ynew8,Znew8;//ÐÂ²É¼¯µ½µÄÊý¾Ý
    271          int RawDataPointer = 0;
    272          #endif  
    273          #if(SENSOR_TYPE =='C')
    274          #define _BH1710FVC_DEF_
    275          #define uchar unsigned char
    276          #define uint unsigned int
    277          //1710Ö¸Áî¶¨Òå
    278          #define power_down 0x00
    279          #define power_on 0x01
    280          #define reset 0x07
    281          #define h_resolution_mod 0x10
    282          #define m_resolution_mod 0x13
    283          #define l_resolution_mod 0x16
    284          #define onetime_h 0x20
    285          #define onetime_m 0x23
    286          #define onetime_l 0x26
    287          #define write_1710 0x46
    288          #define read_1710 0x47
    289          #endif
    290          #if((SENSOR_TYPE ==0X24)||(SENSOR_TYPE ==0X80))
    291          uint8 CSB_Len_H;
    292          uint8 CSB_Len_L;
    293          #endif
    294          #if(SENSOR_TYPE ==0X40)
    295          uint8 LED_START=0;
    296          #endif
    297          #if(SENSOR_TYPE =='G')
    298          #define A1 P1_0	//¶¨ÒåAÏßÈ¦Õý¶Ë¿Ú
    299          #define A2 P1_1	//¶¨ÒåAÏßÈ¦¸º¶Ë¿Ú
    300          #define B1 P1_2	//¶¨ÒåBÏßÈ¦Õý¶Ë¿Ú
    301          #define B2 P1_3	//¶¨ÒåBÏßÈ¦¸º¶Ë¿Ú
    302          #define Coil_A1   {A1=0;A2=1;B1=1;B2=1;}  //AÏßÈ¦Í¨ÕýÏòµçÑ¹
    303          #define Coil_B1   {A1=1;A2=1;B1=0;B2=1;}	//BÏßÈ¦Í¨ÕýÏòµçÑ¹
    304          #define Coil_A2   {A1=1;A2=0;B1=1;B2=1;}  //AÏßÈ¦Í¨·´ÏòµçÑ¹
    305          #define Coil_B2   {A1=1;A2=1;B1=1;B2=0;}	//BÏßÈ¦Í¨·´ÏòµçÑ¹
    306          #define Coil_OFF  {A1=1;A2=1;B1=1;B2=1;}  //È«²¿¶Ïµç 
    307          uint8 Coil_AB=0;
    308          #endif
    309          #if(SENSOR_TYPE ==0X67)
    310          #define  NSYNC P1_7 //dac7512 Ê¹ÄÜ¶Ë
    311          #define  SCLK P1_6 //dac7512 Ê±ÖÓ¶Ë
    312          #define  DIN P1_5  //dac7512 Êý¾Ý¶Ë
    313          #endif
    314          #if(SENSOR_TYPE ==0X30)
    315          #define  NSYNC P1_7 //dac7512 Ê¹ÄÜ¶Ë
    316          #define  SCLK P1_6 //dac7512 Ê±ÖÓ¶Ë
    317          #define  DIN P1_5  //dac7512 Êý¾Ý¶Ë
    318          
    319          #define B01 0x0D//(1 =14.8¶È)µç»ú½Ç¶ÈÉè¶¨ 0X07 42BYGH408AA(1=7.2)Éè¶¨0X0D  Ä¬ÈÏ 0x0D
    320          #define A1 P1_0	//¶¨ÒåAÏßÈ¦Õý¶Ë¿Ú
    321          #define A2 P1_1	//¶¨ÒåAÏßÈ¦¸º¶Ë¿Ú
    322          #define B1 P1_2	//¶¨ÒåBÏßÈ¦Õý¶Ë¿Ú
    323          #define B2 P1_3	//¶¨ÒåBÏßÈ¦¸º¶Ë¿Ú
    324          #define Coil_A1   {A1=0;A2=1;B1=1;B2=1;}  //AÏßÈ¦Í¨ÕýÏòµçÑ¹
    325          #define Coil_B1   {A1=1;A2=1;B1=0;B2=1;}	//BÏßÈ¦Í¨ÕýÏòµçÑ¹
    326          #define Coil_A2   {A1=1;A2=0;B1=1;B2=1;}  //AÏßÈ¦Í¨·´ÏòµçÑ¹
    327          #define Coil_B2   {A1=1;A2=1;B1=1;B2=0;}	//BÏßÈ¦Í¨·´ÏòµçÑ¹
    328          #define Coil_OFF  {A1=1;A2=1;B1=1;B2=1;}  //È«²¿¶Ïµç 
    329          uint8 a68=0,b68=0,c68=0; //a68·½Ïò b68½Ç¶È c68 Ê±¼ä
    330          #endif
    331          #if(SENSOR_TYPE ==0X73)
    332          #define DIR P1_7
    333          #define CP P1_6
    334          uint8 a68=0;
    335          int b68=0;
    336          uint8 C68=0,A8n=0;
    337          #endif
    338          #if(SENSOR_TYPE =='D')
    339          #define S0 P1_6
    340          #define S1 P1_7
    341          #define OE	P1_5	
    342          #define L2      P1_1
    343          #define L3	P1_2
    344          #define OUT P1_0
    345          #define uchar unsigned char
    346          #define uint unsigned int
    347          volatile uint times = 0;	//Âö³å¼ÆÊý
    348          float OUTR,OUTG,OUTB;
    349          #endif
    350          #if(SENSOR_TYPE =='F')
    351          #if defined(BMP085) 
    352          #define XCLR P1_5 
    353          #define XCLROUT P1DIR|=0x20       //Êý¾ÝÊä³ö 
    354          #define uchar unsigned char
    355          #define uint unsigned int
    356          //±äÁ¿ÉùÃ÷
    357          //BMP085ÖÐE2PROM´æ´¢µÄ±ê¶¨²ÎÊý
    358          int AC1=0;   				//(0xAA,0xAB)
    359          int AC2=0;  				//(0xAC,0xAD)
    360          int AC3=0;  				//(0xAE,0xAF)
    361          unsigned int AC4=0;				//(0xB0,0xB1)
    362          unsigned int AC5=0;				//(0xB2,0xB3)
    363          unsigned int AC6=0;				//(0xB4,0xB5)
    364          int B1=0;				//(0xB6,0xB7)
    365          int B2=0;				//(0xB8,0xB9)
    366          int MB=0;				//(0xBA,0xBB)
    367          int MC=0;				//(0xBC,0xBD)
    368          int MD=0;				//(0xBE,0xBF)
    369          unsigned long T=0;				//ÎÂ¶È
    370          unsigned long p=0;				//Ñ¹Á¦
    371          #endif
    372          
    373          #endif
    374             //±êÖ¾ ³¤¶È Ä¿µØµØÖ·  Ô­µØµØÖ·  ÀàÐÍ ÊýÖµ ÊýÖµ 

   \                                 In  segment XDATA_I, align 1, keep-with-next
    375          uint8 Send_data[0X80] = {0XFA,0X0A,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00};
   \                     Send_data:
   \   000000                DS 128
   \   000080                REQUIRE `?<Initializer for Send_data>`
   \   000080                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    376          uint8 Send_datalend=0; //ÄÚÈÝ+Ð£ÑéºÍ³¤¶È
   \                     Send_datalend:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    377          uint8 AF_OK=0;//ÎÞÏßÊý¾Ý·¢ËÍ³É¹¦Óë·ñ±êÖ¾  1³É¹¦ 0Ê§°Ü
   \                     AF_OK:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    378          uint8 AF_RF=0;//ÎÞÏßÊý¾Ý·¢ËÍÊ§°Ü£¬ÖØ·¢±êÖ¾
   \                     AF_RF:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    379          uint8 AF_RFn=0;//ÖØ·¢´ÎÊý
   \                     AF_RFn:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    380          uint8 AF_RFnd=0;//ÖØ·¢×éÊý
   \                     AF_RFnd:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    381          uint8 AF_RFnds=0;//ÖØ·¢Ë³ÐòºÅ °´Ë³Ðò·¢ËÍ
   \                     AF_RFnds:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    382          #if defined( SENSOR_TYPE_Coord )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    383          uint8  chnnd[5][120];//Êý¾Ý»º´æ
   \                     chnnd:
   \   000000                DS 600
   \   000258                REQUIRE __INIT_XDATA_Z
    384          #endif
    385          
    386          #if((SENSOR_TYPE ==0X31)||(SENSOR_TYPE ==0XA3))
    387          uint8  chnndr[120];//Êý¾Ý»º´æ
    388          #endif
    389          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    390          unsigned int GenericApp_applicationdata=0;
   \                     GenericApp_applicationdata:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    391          unsigned char GenericApp_time=0;
   \                     GenericApp_time:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    392          unsigned int  GenericApp_applicationbuf=0;
   \                     GenericApp_applicationbuf:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    393          unsigned int GenericApp_uart_data=0;
   \                     GenericApp_uart_data:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    394          unsigned char  GenericApp_CR;
   \                     GenericApp_CR:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    395          uint8  openoff=0;
   \                     openoff:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    396          uint8  PWRMGR_ALWAYS_ON_OFF=0;
   \                     PWRMGR_ALWAYS_ON_OFF:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    397          unsigned char OSAL_SET_CPU_INTO_SLEEP=0;
   \                     OSAL_SET_CPU_INTO_SLEEP:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    398          unsigned int GenericApp_sbum=0;
   \                     GenericApp_sbum:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    399          unsigned int GenericApp_KSH_H=0;
   \                     GenericApp_KSH_H:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    400          unsigned int GenericApp_KSH=0;    //86ºÐ °´¼ü¼ÆÊý
   \                     GenericApp_KSH:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    401          unsigned int GenericApp_KSH86=0;  //86ºÐ °´¼üËÙ¶È¼ÆÊý
   \                     GenericApp_KSH86:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    402          //**********************************************************88

   \                                 In  segment XDATA_I, align 1, keep-with-next
    403          unsigned long T3_t1Val=100;//¶¨Ê±3 Ê±¼ä¼ÆÊýÉèÖÃ ms
   \                     T3_t1Val:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for T3_t1Val>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    404          unsigned long t1Val=0;  //¶¨Ê±3 ¼ÆÊý±äÁ¿
   \                     t1Val:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    405          unsigned char T_MG=0;    // ¿ØÖÆÉè±¸ ×´Ì¬ÐÅÏ¢±äÁ¿
   \                     T_MG:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    406          uint8 T_MGSbit=0;    // ×´Ì¬ÐÅÏ¢ Êý¾ÝÐÅÏ¢  Á¬Êý¾ÝÐÅÏ¢¼ÇÂ¼
   \                     T_MGSbit:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    407          //¹Ø±Õ¶¨Ê±  Ö÷¶¯   ¿ØÖÆÀà  ×ÛºÏÐÍ  

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    408          unsigned char  GenericApp_appIO=0;
   \                     GenericApp_appIO:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    409          unsigned char GenericApp_BX=0;
   \                     GenericApp_BX:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    410          unsigned int GenericApp_ON_OFF=0;
   \                     GenericApp_ON_OFF:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    411          unsigned int GenericApp_switch=0;//¿ª¹ØÁ¿¶¨Ê±·´À¡
   \                     GenericApp_switch:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    412          unsigned int GenericApp_switchk2=0;//¿ª¹ØÁ¿¶¨Ê±·´À¡
   \                     GenericApp_switchk2:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    413          #define LMOUT P2_0
    414          /*********************************************************************
    415           * CONSTANTS
    416           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    417          unsigned char T_MUMPT1=0;    // ¼ÇÂ¼ÊýÖµ½øÐÐ±È½Ï
   \                     T_MUMPT1:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    418          unsigned int T_MUMPTS=0;    //   ½üËÆÕæÊµÊý¾Ý×ª»»
   \                     T_MUMPTS:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    419          #if(SENSOR_TYPE ==0X22)
    420          unsigned char  T_MUMPTZ1=0;//¼ÇÂ¼×î´óÊýÖµ 
    421          #endif 
    422          #if((SENSOR_TYPE ==0X18)||(SENSOR_TYPE ==0X5A)||(SENSOR_TYPE ==0X5B)||(SENSOR_TYPE ==0X70))
    423          unsigned char  GenericApp_uart_485=0;
    424          #endif 
    425          #if(SENSOR_TYPE ==0X23)
    426          unsigned char  SFG_R30X=0;
    427          unsigned char  SFG_R30XA[3]={0};
    428          #endif 
    429          #if(SENSOR_TYPE ==0X31)
    430          uint8 Uart_Rev_Buff_1[6]={0};
    431          uint8 Uart_Rev_Buff_2[6]={0};
    432          uint8 car_stata;
    433          uint8 car_op;//¶Á¿¨¼ÆÊý
    434          uint8 car_sum;
    435          uint8 holzer=0;
    436          #endif
    437          /*********************************************************************
    438           * TYPEDEFS
    439           */
    440          /*********************************************************************
    441           * GLOBAL VARIABLES
    442           */
    443          // This list should be filled with Application specific Cluster IDs.

   \                                 In  segment XDATA_ROM_C, align 1
    444          const cId_t GenericApp_ClusterList[GENERICAPP_MAX_CLUSTERS] =
   \                     GenericApp_ClusterList:
   \   000000   0100         DW 1
    445          {
    446            GENERICAPP_CLUSTERID
    447          };

   \                                 In  segment XDATA_ROM_C, align 1
    448          const SimpleDescriptionFormat_t GenericApp_SimpleDesc =
   \                     GenericApp_SimpleDesc:
   \   000000   0A           DB 10
   \   000001   040F0100     DW 3844, 1
   \   000005   0001         DB 0, 1
   \   000007   ....         DW GenericApp_ClusterList
   \   000009   01           DB 1
   \   00000A   ....         DW GenericApp_ClusterList
    449          {
    450            GENERICAPP_ENDPOINT,              //  int Endpoint;
    451            GENERICAPP_PROFID,                //  uint16 AppProfId[2];
    452            GENERICAPP_DEVICEID,              //  uint16 AppDeviceId[2];
    453            GENERICAPP_DEVICE_VERSION,        //  int   AppDevVer:4;
    454            GENERICAPP_FLAGS,                 //  int   AppFlags:4;
    455            GENERICAPP_MAX_CLUSTERS,          //  byte  AppNumInClusters;
    456            (cId_t *)GenericApp_ClusterList,  //  byte *pAppInClusterList;
    457            GENERICAPP_MAX_CLUSTERS,          //  byte  AppNumInClusters;
    458            (cId_t *)GenericApp_ClusterList   //  byte *pAppInClusterList;
    459          };
    460          
    461          // This is the Endpoint/Interface description.  It is defined here, but
    462          // filled-in in GenericApp_Init().  Another way to go would be to fill
    463          // in the structure here and make it a "const" (in code space).  The
    464          // way it's defined in this sample app it is define in RAM.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    465          endPointDesc_t GenericApp_epDesc;
   \                     GenericApp_epDesc:
   \   000000                DS 6
   \   000006                REQUIRE __INIT_XDATA_Z
    466          /*********************************************************************
    467           * EXTERNAL VARIABLES
    468           */
    469          
    470          /*********************************************************************
    471           * EXTERNAL FUNCTIONS
    472           */
    473          
    474          /*********************************************************************
    475           * LOCAL VARIABLES
    476           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    477          byte GenericApp_TaskID;   // Task ID for internal task/event processing
   \                     GenericApp_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    478                                    // This variable will be received when
    479                                    // GenericApp_Init() is called.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    480          devStates_t GenericApp_NwkState;
   \                     GenericApp_NwkState:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    481          byte GenericApp_TransID;  // This is the unique message ID (counter)
   \                     GenericApp_TransID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    482          afAddrType_t GenericApp_DstAddr;
   \                     GenericApp_DstAddr:
   \   000000                DS 12
   \   00000C                REQUIRE __INIT_XDATA_Z
    483          /*********************************************************************
    484           * LOCAL FUNCTIONS
    485           */
    486          //void GenericApp_ProcessZDOMsgs( zdoIncomingMsg_t *inMsg );
    487          void GenericApp_HandleKeys( byte shift, byte keys );
    488          void GenericApp_MessageMSGCB( afIncomingMSGPacket_t *pckt );
    489          void GenericApp_SendTheMessage( void );
    490          void GenericApp_SendFT( void );
    491          void GenericAppEndDeviceEB(void);
    492          
    493          /*********************************************************************
    494           * NETWORK LAYER CALLBACKS
    495           */
    496          
    497          /*********************************************************************
    498           * PUBLIC FUNCTIONS
    499           */
    500          #if(SENSOR_TYPE =='B')
    501          void MMA7660_XYZ_Read_and_Filter(void);
    502          void MMA7660_XYZ_Read_and_Filter(void)
    503          {
    504            int i;
    505            int temp16;
    506            IIC_Read_MMA7660_XYZ6(&Xnew8, &Ynew8, &Znew8);
    507            if((++RawDataPointer)>=RawDataLength) RawDataPointer = 0;
    508            Xraw[RawDataPointer] = Xnew8;
    509            Yraw[RawDataPointer] = Ynew8;
    510            Zraw[RawDataPointer] = Znew8;
    511            for(i=0, temp16=0;i<RawDataLength;i++)
    512            {
    513              temp16 += (int)Xraw[i];
    514            }
    515            Xavg8 = (int)(temp16/RawDataLength);
    516            for(i=0, temp16=0;i<RawDataLength;i++)
    517            {
    518              temp16 += (int)Yraw[i];
    519            }
    520            Yavg8 = (int)(temp16/RawDataLength);
    521            for(i=0, temp16=0;i<RawDataLength;i++)
    522            {
    523              temp16 += (int)Zraw[i];
    524            }
    525            Zavg8 = (int)(temp16/RawDataLength);
    526          }
    527          #endif  
    528          #if((SENSOR_TYPE ==0X6C)||(SENSOR_TYPE ==0X6F))
    529          void wr_lcd(unsigned char dat_com,unsigned char content);
    530          void delay_us(unsigned int us_value);
    531          void delay_ms(unsigned int ms_value);
    532          void init_lcd (void);
    533          void txt_disp(const unsigned char code *cn,unsigned char adr,unsigned char len);
    534          void lcd_disp(unsigned char *cn,unsigned char adr,unsigned char len);
    535          void hzkdis(unsigned char adr,const unsigned char code *s);
    536          void hzkdis_b(unsigned char adr,unsigned char *s,unsigned char len);
    537          void lcd_txt_clr(void);
    538          void lcd_gra_clr(void);
    539          void sendbyte(unsigned char zdata);
    540          /******************************************************************************************
    541          *º¯ÊýÃû³Æ£º init_lcd
    542          *¹¦ÄÜÃèÊö£º ³õÊ¼»¯
    543          ******************************************************************************************/
    544          void init_lcd (void)
    545          {
    546           wr_lcd(com,0x30);  /*30---¹¦ÄÜÉè¶¨,8-bitÄ£Ê½*/   
    547           wr_lcd(com,0x30);  /*30---¹¦ÄÜÉè¶¨,»ù±¾Ö¸Áî*/  
    548           wr_lcd(com,0x01);  /*ÇåÆÁ£¬µØÖ·Ö¸ÕëÖ¸Ïò00H*/
    549           wr_lcd(com,0x06);  /*¹â±êµÄÒÆ¶¯·½Ïò*/
    550           wr_lcd(com,0x0c);  /*¿ªÏÔÊ¾£¬¹ØÓÎ±ê*/
    551          }
    552          
    553          /********************************************************************
    554          * Ãû³Æ : hzkdis()
    555          * ¹¦ÄÜ : ÏÔÊ¾×Ö·û´®
    556          * ÊäÈë : *s
    557          * Êä³ö : ÎÞ
    558          ***********************************************************************/
    559          void hzkdis(unsigned char adr,const unsigned char code *s)
    560          {
    561           wr_lcd(com,0x30);
    562          //delay_ms(50); 
    563          //wr_lcd(com,0x80);
    564           int i=0;char x[4]={0};
    565          switch(adr)
    566          {
    567          case 0:x[0]=0x80;x[1]=0x90;x[2]=0x88;x[3]=0x98;break; 
    568          case 1:x[0]=0x90;x[1]=0x88;x[2]=0x98;break; 
    569          case 2:x[0]=0x88;x[1]=0x98;break; 
    570          case 3:x[0]=0x98;break; 
    571          default:break;
    572          }
    573          while(*s > 0)
    574          { switch(i)
    575          {case 0:wr_lcd(com,x[0]);break; 
    576          case 16:wr_lcd(com,x[1]);break;
    577          case 32:wr_lcd(com,x[2]);break;
    578          case 48:wr_lcd(com,x[3]);break;
    579          default:break;
    580          }
    581          wr_lcd(dat,*s);
    582          s++;
    583          i++;
    584          delay_ms(50);
    585          }
    586          }
    587          /********************************************************************
    588          * Ãû³Æ : hzkdis-b()
    589          * ¹¦ÄÜ : ÏÔÊ¾×Ö·û´®
    590          * ÊäÈë : *s
    591          * Êä³ö : ÎÞ
    592          ***********************************************************************/
    593          void hzkdis_b(unsigned char adr,unsigned char *s,unsigned char len)
    594          {
    595           wr_lcd(com,0x30);
    596          //delay_ms(50); 
    597          //wr_lcd(com,0x80);
    598           int i=0;char x[4]={0};
    599          switch(adr)
    600          {
    601          case 0:x[0]=0x80;x[1]=0x90;x[2]=0x88;x[3]=0x98;break; 
    602          case 1:x[0]=0x90;x[1]=0x88;x[2]=0x98;break; 
    603          case 2:x[0]=0x88;x[1]=0x98;break; 
    604          case 3:x[0]=0x98;break; 
    605          default:break;
    606          }
    607          while(i < len)
    608          { switch(i)
    609          {case 0:wr_lcd(com,x[0]);break; 
    610          case 16:wr_lcd(com,x[1]);break;
    611          case 32:wr_lcd(com,x[2]);break;
    612          case 48:wr_lcd(com,x[3]);break;
    613          default:break;
    614          }
    615          wr_lcd(dat,*s);
    616          s++;
    617          i++;
    618          delay_ms(50);
    619          }
    620          }
    621          /******************************************************************************************
    622          *º¯ÊýÃû³Æ£º lcd_disp
    623          *¹¦ÄÜÃèÊö£º ÏÔÊ¾Ò»ÐÐºº×Ö»ò×Ö·û
    624          ******************************************************************************************/
    625          void lcd_disp(unsigned char *cn,unsigned char adr,unsigned char len)
    626          {
    627           unsigned char i;
    628           wr_lcd(com,0x30);
    629           wr_lcd(com,adr);   //µÚÒ»µ½ËÄÐÐµØÖ··Ö±ðÊÇ0x80,0x90,0x88,0x98
    630           for(i=0;i<len;i++)
    631            wr_lcd(dat,cn[i]);
    632          }
    633          /******************************************************************************************
    634          *º¯ÊýÃû³Æ£º txt_disp
    635          *¹¦ÄÜÃèÊö£º ÏÔÊ¾Ò»ÐÐºº×Ö»ò×Ö·û
    636          ******************************************************************************************/
    637          void txt_disp(const unsigned char code *cn,unsigned char adr,unsigned char len)
    638          {
    639           unsigned char i;
    640           wr_lcd(com,0x30);
    641           wr_lcd(com,adr);   //µÚÒ»µ½ËÄÐÐµØÖ··Ö±ðÊÇ0x80,0x90,0x88,0x98
    642           for(i=0;i<len;i++)
    643            wr_lcd(dat,cn[i]);
    644          }
    645          /********************************************************************
    646          * Ãû³Æ : sendbyte()
    647          * ¹¦ÄÜ : °´ÕÕÒº¾§µÄ´®¿ÚÍ¨ÐÅÐ­Òé£¬·¢ËÍÊý¾Ý
    648          * ÊäÈë : zdata
    649          * Êä³ö : ÎÞ
    650          ***********************************************************************/
    651          void sendbyte(unsigned char zdata)
    652          {
    653          unsigned int i;
    654          for(i=0; i<8; i++)
    655          {
    656          if((zdata << i) & 0x80)
    657          {
    658          SDA = 1;
    659          }
    660          else 
    661          {
    662          SDA = 0;
    663          }
    664          SCLK = 0;
    665          SCLK = 1;
    666          }
    667          }
    668          /******************************************************************************************
    669          *º¯ÊýÃû³Æ£ºwr_lcd
    670          *¹¦ÄÜÃèÊö£ºÐ´ÈëÖ¸Áî/Êý¾Ý×Ó³ÌÐò 
    671          ******************************************************************************************/
    672          void wr_lcd (unsigned char dat_comm,unsigned char content)
    673          {CS = 1;
    674          if(dat_comm)
    675          sendbyte(0xfa);
    676          else sendbyte(0xf8);
    677          sendbyte(content & 0xf0);
    678          sendbyte((content << 4) & 0xf0);
    679          delay_us(2);
    680          }
    681          
    682          /******************************************************************************************
    683          *º¯ÊýÃû³Æ£ºdelay_us
    684          *¹¦ÄÜÃèÊö£ºÑÓÊ±us 
    685          ******************************************************************************************/
    686          void delay_us(unsigned int t)   //delay time
    687          {
    688           unsigned int i,j;
    689          for(i=0; i<t; i++)
    690          for(j=0; j<10; j++);
    691          }
    692          /******************************************************************************************
    693          *º¯ÊýÃû³Æ£ºdelay_ms
    694          *¹¦ÄÜÃèÊö£ºÑÓÊ±ms
    695          ******************************************************************************************/
    696          void delay_ms(unsigned int ms_value)
    697          {
    698           unsigned int i,j;
    699           for(i=0;i<ms_value;i++)
    700            for(j=0;j<20;j++)
    701             delay_us(1);
    702          }
    703          
    704          /******************************************************************************************
    705          *º¯ÊýÃû³Æ£º lcd_txt_clr
    706          *¹¦ÄÜÃèÊö£º ÎÄ±¾ÇøÇåRAMº¯Êý
    707          ******************************************************************************************/
    708          void lcd_txt_clr(void)
    709          {
    710           wr_lcd(com,0x30);
    711           wr_lcd(com,0x01);
    712           delay_ms(20);
    713          }
    714          /******************************************************************************************
    715          *º¯ÊýÃû³Æ£º lcd_gra_clr
    716          *¹¦ÄÜÃèÊö£º Í¼ÐÎÇøÇåRAMº¯Êý
    717          ******************************************************************************************/
    718          void lcd_gra_clr(void)
    719          {
    720           unsigned char i,j;
    721           wr_lcd(com,0x34);      //8BitÀ©³äÖ¸Áî¼¯,¼´Ê¹ÊÇ36HÒ²ÒªÐ´Á½´Î
    722           for(j=0;j<32;j++)
    723            {
    724             for(i=0;i<16;i++)
    725              {
    726               wr_lcd(com,0x34);
    727               wr_lcd(com,0x80+j);
    728               wr_lcd(com,0x80+i);
    729               wr_lcd(com,0x30);
    730               wr_lcd(dat,0);
    731               wr_lcd(dat,0);
    732              }
    733            }
    734          }
    735          #endif 
    736          #if(SENSOR_TYPE ==0X78)
    737          void send_Instruction(void);
    738          void send_Instruction(void)
    739          {halMcuWaitMs(1000);
    740          	unsigned  char send_data[3]={0};
    741          	send_data[0]=0xa5;
    742          	send_data[1]=0x15;//¼Ó¼Æ¹¦ÄÜ×Ö½Ú
    743          	send_data[2]=(unsigned char)(send_data[0]+send_data[1]);//Ö¸ÁîÐ£ÑéºÍ
    744                   HalUARTWrite(HAL_UART_PORT_0, send_data,3);//·¢ËÍ¼ÓËÙ¶ÈÊä³öÖ¸Áî
    745          	halMcuWaitMs(10);
    746          	send_data[0]=0xa5;
    747          	send_data[1]=0x25;
    748          	send_data[2]=(unsigned char)(send_data[0]+send_data[1]);
    749          	 HalUARTWrite(HAL_UART_PORT_0,send_data,3);//·¢ËÍÍÓÂÝÒÇÊý¾ÝÊä³öÖ¸Áî
    750          	halMcuWaitMs(10);
    751          	send_data[0]=0xa5;
    752          	send_data[1]=0x35;
    753          	send_data[2]=(unsigned char)(send_data[0]+send_data[1]);
    754          	 HalUARTWrite(HAL_UART_PORT_0,send_data,3);//·¢ËÍ´Å³¡Êý¾ÝÊä³öÖ¸Áî
    755          	halMcuWaitMs(10);
    756          	send_data[0]=0xa5;
    757          	send_data[1]=0x45;
    758          	send_data[2]=(unsigned char)(send_data[0]+send_data[1]);
    759          	 HalUARTWrite(HAL_UART_PORT_0,send_data,3);//·¢ËÍÅ·À­½ÇÊý¾ÝÊä³öÖ¸Áî
    760          	halMcuWaitMs(10);
    761          	send_data[0]=0xa5;
    762          	send_data[1]=0x65;
    763          	send_data[2]=(unsigned char)(send_data[0]+send_data[1]);
    764          	 HalUARTWrite(HAL_UART_PORT_0,send_data,3);//·¢ËÍËÄÔªÊýÊý¾ÝÊä³öÖ¸Áî
    765          }
    766          
    767          #endif 
    768          #if(SENSOR_TYPE ==0X81)
    769          unsigned int read_max6675(void);
    770          unsigned int read_max6675(void)    
    771            { max_byte=0;   
    772                 unsigned char i=0;    
    773                CS=0;   
    774                SCK=0;        
    775                  for(i=0;i<16;i++)    
    776                   {    
    777                    halMcuWaitMs(1);	  
    778                    SCK=1;     
    779                    halMcuWaitMs(1);	   
    780                    if(SO)     
    781                     max_byte|=(1<<(15-i));   
    782                    SCK=0;    
    783                   }   
    784                  CS=1;   
    785                  SCK=0;    
    786                  bytee=max_byte;   
    787                  if(bytee&0x8000)max_byte=0x8000;   //´íÎó  D15 Ä£ÄâÎ»   0Õý³£ 1 Ä£ÄâÎ»
    788                  else if(bytee&0x4)max_byte=0x8001;   //´íÎó D2 µçÅ¼¿ªÂ·Î»¼ì²â 0 Á¬½Ó 1 ¿ªÂ·
    789                  else   
    790                   {   
    791                     max_byte=max_byte&0x7ff8;   
    792                     max_byte=max_byte>>3;   
    793                    }   
    794                 return max_byte;    
    795          
    796          
    797          
    798            }    
    799          #endif  
    800          #if(SENSOR_TYPE =='F')
    801          #if defined(BMP085) 
    802          void BMP085_init(void);
    803          void BMP085_sample(uchar oss);
    804          //====================================================
    805          //Ñ¹Á¦´«¸ÐÆ÷Çý¶¯º¯Êý £¨BMP085£©
    806          //====================================================
    807          void BMP085_init(void)//¶ÁÈ¡BMP085ÖÐE2PROMµÄ²ÎÊý£¬²¢¸³¸øÈ«¾Ö±äÁ¿
    808          {		
    809          	char memo[22];
    810          	uchar i;
    811          	//void *pf;
    812          	//´ÓEEPROMÖÐ¶ÁÈ¡Ô¤Éè²ÎÊý
    813          	for(i=0;i<22;i++){memo[i]=Single_Read_(0xAA+i);}
    814                  AC1=(memo[0]<<8)+memo[1];
    815          	AC2=(memo[2]<<8)+memo[3];	
    816                  AC3=(memo[4]<<8)+memo[5];	
    817                  AC4=(memo[6]<<8)+memo[7];	
    818                  AC5=(memo[8]<<8)+memo[9];	
    819                  AC6=(memo[10]<<8)+memo[11];	
    820                  B1=(memo[12]<<8)+memo[13];	
    821                  B2=(memo[14]<<8)+memo[15];	
    822                  MB=(memo[16]<<8)+memo[17];	
    823                  MC=(memo[18]<<8)+memo[19];	
    824                  MD=(memo[20]<<8)+memo[21];	
    825                  //AC1=408;
    826                 /*  AC2=-72;
    827                   AC3=-14383;
    828                  AC4=32741;
    829                  AC5=32757;
    830                  AC6=23153;
    831                  B1=6190;
    832                  B2=4;
    833                  MB=-32768;
    834                  MC=-8711;
    835                  MD=2868; 
    836                  */
    837          }
    838          void BMP085_sample(uchar oss)//ÎÂ¶È¡¢Ñ¹Á¦²ÉÑù
    839          //ossÎª¹¤×÷·½Ê½£º
    840          //0-ultra low power;
    841          //1-standard;
    842          //2-high resolution;
    843          //3-ultra high resolution
    844          {
    845          	 long UT=0;			//ÎÂ¶ÈÔ­Ê¼Öµ	
    846          	 long UP=0;			//Ñ¹Á¦Ô­Ê¼Öµ
    847          	 long X1,X2,X3;
    848          	long B3,B5,B6;
    849          	unsigned long B4,B7;
    850          	char i,BMPmemo[3];
    851          	//void *pf;
    852          	Single_Write_(0xF4,0x2E);	//·¢ÃüÁî²ÉÎÂ¶È
    853          	mDelay(100); //ÑÓÊ±						//µÈ´ýAD£¬ÑÓ³Ù4.5msÒÔÉÏ
    854          	for(i=0;i<2;i++){BMPmemo[i]=Single_Read_(0xF6+i);}//¶ÁÈ¡½á¹û	
    855                  UT=BMPmemo[0]*256+BMPmemo[1];
    856                 // UT=UT-5000;  //Îó²î²¹³¥£¨¸ù¾ÝÊµ¼Ê²âÊÔ£©
    857          	Single_Write_(0xF4,0x34+(oss<<6));//·¢ÃüÁî²ÉÑ¹Á¦
    858          	mDelay(200); //ÑÓÊ±								//ÑÓ³ÙÊ±¼äÊÓ¹¤×÷·½Ê½¶ø¶¨£¬¾ßÌå²éÊÖ²á
    859          	for(i=0;i<3;i++){BMPmemo[i]=Single_Read_(0xF6+i);}//¶ÁÈ¡½á¹û	
    860                  
    861                  UP=BMPmemo[0]*65536+BMPmemo[1]*256+BMPmemo[2];
    862          	UP=(UP>>(8-oss));
    863                  
    864                  X1=(UT-AC6)*AC5/32768; 		//¼ÆËãÎÂ¶È
    865          	X2=MC;
    866          	X2=X2*2048/(X1+MD);
    867          	B5=X1+X2;
    868          	T=(B5+8)/16;
    869          	B6=B5-4000;			//¼ÆËãÑ¹Á¦
    870          	X1=B2;
    871          	X1=(X1*(B6*B6/4096))/2048;
    872          	X2=AC2;
    873          	X2=X2*B6/2048;
    874          	X3=X1+X2;
    875          	B3=AC1;
    876          	B3=(((B3*4+X3)<<oss)+2)/4;	
    877          	X1=AC3;
    878          	X1=X1*B6/8192;
    879          	X2=B1;
    880          	X2=(X2*(B6*B6/4096))/65536;
    881          	X3=((X1+X2)+2)/4;
    882          	B4=AC4;
    883          	B4=B4*(unsigned long)(X3+32768)/32768;
    884          	B7=((unsigned long)UP-B3)*(50000>>oss);	
    885          	if(B7<0x80000000){p=(B7*2)/B4;}
    886          	else {p=(B7/B4)*2;}
    887          	X1=(p/256)*(p/256); 
    888          	X1=(X1*3038)/65536;        
    889          	X2=(-7357*p)/65536; 
    890          	p=p+(X1+X2+3791)/16;  
    891          }
    892          #endif 
    893          #endif  
    894          
    895          #if(SENSOR_TYPE =='D')
    896          float TCS3200(uchar t);
    897          //===================TCS3200²âÑÕÉ«=========================
    898          float TCS3200(uchar t)
    899          {       float OUTS;
    900                  uint8 n=1;
    901                  switch(t)
    902                 { case 1:L2=0;L3=0;break;//R
    903                   case 2:L2=1;L3=1;break;//G
    904                   case 3:L2=0;L3=1;break;//B
    905                   default:L2=1;L3=0;break;//ÎÞ
    906                  }
    907          	for(unsigned int i=0;i<100;i++);
    908          	times = 0;
    909          	OE=0;//¼ì²âÒ»´Î
    910          	for(unsigned int i=0;i<50000;i++)
    911                    {if(n)
    912                      {if(OUT){times++;n=0;}}
    913                       if(!n){if(!OUT)n=1;}
    914                      }
    915          	OE=1;
    916          	OUTS= times;
    917          	times = 0;
    918          	OE=0;			//Á½´Î
    919          	for(unsigned int i=0;i<50000;i++)
    920                    {if(n)
    921                      {if(OUT){times++;n=0;}}
    922                       if(!n){if(!OUT)n=1;}
    923                      }
    924          	OE=1;	
    925          	OUTS += times;
    926          	times = 0;
    927          	OE=0;			//Èý´Î
    928          	for(unsigned int i=0;i<50000;i++)
    929                    {if(n)
    930                      {if(OUT){times++;n=0;}}
    931                       if(!n){if(!OUT)n=1;}
    932                      }
    933          	OE=1;	
    934          	OUTS += times;
    935          	times = 0;
    936          	OE=0;				//ËÄ´Î
    937          	for(unsigned int i=0;i<50000;i++)
    938                    {if(n)
    939                      {if(OUT){times++;n=0;}}
    940                       if(!n){if(!OUT)n=1;}
    941                      }
    942          	OE=1;	
    943          	OUTS += times;
    944          	OUTS/=4.0;					//È¡ËÄ´ÎµÄÆ½¾ùÖµ
    945          	return OUTS;
    946          }
    947          #endif    
    948          #if((SENSOR_TYPE ==0X27)||(SENSOR_TYPE ==0X6F))
    949          void SYN_FrameInfo(uint8 Music,uint8 GBK,uint8 *HZdata,uint8 lens);
    950          /***********************************************************
    951          * Ãû    ³Æ£º  YS-SYN6288 ÎÄ±¾ºÏ³Éº¯Êý
    952          * ¹¦    ÄÜ£º  ·¢ËÍºÏ³ÉÎÄ±¾µ½SYN6288Ð¾Æ¬½øÐÐºÏ³É²¥·Å
    953          * Èë¿Ú²ÎÊý£ºMusic(±³¾°ÒôÀÖÑ¡Ôñ):0ÎÞ±³¾°ÒôÀÖ¡£1-15£ºÏà¹Ø±³¾°ÒôÀÖ
    954                      GBK : ºº×Ö±àÂë¸ñÊ½  0: GB2312  1: GBK  2:BIG5  3 :UNICODE
    955                      *HZdata:ÎÄ±¾Ö¸Õë±äÁ¿ 
    956          * ³ö¿Ú²ÎÊý£º
    957          * Ëµ    Ã÷£º ±¾º¯ÊýÖ»ÓÃÓÚÎÄ±¾ºÏ³É£¬¾ß±¸±³¾°ÒôÀÖÑ¡Ôñ¡£Ä¬ÈÏ²¨ÌØÂÊ9600bps¡£					 
    958          **********************************************************/
    959          void SYN_FrameInfo(uint8 Music,uint8 GBK,uint8 *HZdata,uint8 lens)
    960          {
    961          /****************ÐèÒª·¢ËÍµÄÎÄ±¾**********************************/ 
    962          		 unsigned  char  Frame_Info[85];
    963                   unsigned  char  HZ_Length;  
    964          		 unsigned  char  ecc  = 0;  			//¶¨ÒåÐ£Ñé×Ö½Ú
    965          	     unsigned  int i=0; 
    966          		 HZ_Length =strlen(HZdata); 			//ÐèÒª·¢ËÍÎÄ±¾µÄ³¤¶È
    967                           if(HZ_Length>lens)
    968                             HZ_Length =lens; 
    969           
    970          /*****************Ö¡¹Ì¶¨ÅäÖÃÐÅÏ¢**************************************/           
    971          		 Frame_Info[0] = 0xFD ; 			//¹¹ÔìÖ¡Í·FD
    972          		 Frame_Info[1] = 0x00 ; 			//¹¹ÔìÊý¾ÝÇø³¤¶ÈµÄ¸ß×Ö½Ú
    973          		 Frame_Info[2] = HZ_Length + 3; 		//¹¹ÔìÊý¾ÝÇø³¤¶ÈµÄµÍ×Ö½Ú
    974          		 Frame_Info[3] = 0x01 ; 			//¹¹ÔìÃüÁî×Ö£ººÏ³É²¥·ÅÃüÁî		 		 
    975          		 Frame_Info[4] =( 0x00 | Music<<4 )|GBK;  //¹¹ÔìÃüÁî²ÎÊý£º±³¾°ÒôÀÖÉè¶¨
    976          
    977          /*******************Ð£ÑéÂë¼ÆËã***************************************/		 
    978          		 for(i = 0; i<5; i++)   				//ÒÀ´Î·¢ËÍ¹¹ÔìºÃµÄ5¸öÖ¡Í·×Ö½Ú
    979          	     {  
    980          	         ecc=ecc^(Frame_Info[i]);		//¶Ô·¢ËÍµÄ×Ö½Ú½øÐÐÒì»òÐ£Ñé	
    981          	     }
    982          
    983          	   	 for(i= 0; i<HZ_Length; i++)   		//ÒÀ´Î·¢ËÍ´ýºÏ³ÉµÄÎÄ±¾Êý¾Ý
    984          	     {  
    985          	         ecc=ecc^(HZdata[i]); 				//¶Ô·¢ËÍµÄ×Ö½Ú½øÐÐÒì»òÐ£Ñé		
    986          	     }		 
    987          /*******************·¢ËÍÖ¡ÐÅÏ¢***************************************/		  
    988          		  memcpy(&Frame_Info[5], HZdata, HZ_Length);
    989          		  Frame_Info[5+HZ_Length]=ecc;
    990          		//  PrintCom(Frame_Info,5+HZ_Length+1);
    991                            HalUARTWrite(HAL_UART_PORT_0,Frame_Info,5+HZ_Length+1);//ÖÇÄÜÓïÑÔ²¥±¨
    992          }
    993          #endif    
    994          #if(SENSOR_TYPE ==0X66)
    995          void display(void);
    996          void display()			   //ÏÔÊ¾×Ó³ÌÐò
    997          {     
    998          	unsigned int LedOut[2];
    999                  LedOut[0]=Disp_Tab[LedNumVal%100/10];
   1000          	LedOut[1]=Disp_Tab[LedNumVal%100%10];
   1001                    SendData(LedOut[LED_HL]);
   1002          	  switch(LED_HL)					  
   1003          	     {	case 0:DS1=1;DS2=0;break; 
   1004          		case 1:DS2=1;DS1=0;break;
   1005          	    }
   1006          }
   1007          #endif 
   1008          #if((SENSOR_TYPE ==0X30)||(SENSOR_TYPE ==0X67))
   1009          void DAchange(unsigned int dat);
   1010          //daÇý¶¯³ÌÐò£¬Èë¿Ú²ÎÊýdat,±ØÐëÐ¡ÓÚ4096£¡4096¶ÔÓ¦5vµçÑ¹£¡
   1011          void DAchange(unsigned int dat)
   1012          {
   1013          unsigned char DA,i,j,DAL,DAH;
   1014           NSYNC=1;
   1015          if(dat>4095)dat=0;
   1016          else
   1017          {DAL=dat%256;
   1018            DAH=dat/256;
   1019              NSYNC=0;
   1020              i=0;
   1021                  while(i<2)
   1022                  {if(i<1)DA=DAH;else DA=DAL;
   1023                  for(j=8;j>0;j--)
   1024                  {
   1025                      if(DA&0x80)DIN=1;else DIN=0;
   1026                      DA=(DA<<1);SCLK=1;SCLK=0;
   1027                   }
   1028                  i=i+1;
   1029                  }
   1030              NSYNC=1;
   1031              }
   1032          }
   1033          #endif
   1034          #if(SENSOR_TYPE ==0X13) 
   1035          #if defined(HUABANG) 
   1036          float ieee754(void);
   1037          float ieee754(void)
   1038          {
   1039            typedef union                                        
   1040          {
   1041             float Float_buf;
   1042             unsigned char  unchar_Buf[4];
   1043          }un_DtformConver;
   1044          
   1045          un_DtformConver   DtformConver;
   1046          
   1047          unsigned char i;
   1048          long long_buf;
   1049          long long_bufS;
   1050          float Float_buf;
   1051          	
   1052          long_buf=0;
   1053          long_bufS=Send_data[8];
   1054          long_buf=long_bufS<<24;
   1055          long_bufS=Send_data[9];
   1056          long_buf+=long_bufS<<16;
   1057          long_bufS=Send_data[10];
   1058          long_buf+=long_bufS<<8;
   1059          long_buf+=Send_data[11];
   1060           //long_bufS=long_buf(((long)Send_data[8]<<24)+((long)Send_data[9]<<16)+((long)Send_data[10]<<8)+Send_data[11]);
   1061           
   1062           memset((unsigned char *)&DtformConver.unchar_Buf[0],0,4);
   1063          
   1064            for(i=0;i<4;i++)
   1065           {
   1066              DtformConver.unchar_Buf[i] = (unsigned char )(long_buf>>(i*8));
   1067           }
   1068           Float_buf = DtformConver.Float_buf;
   1069           
   1070            return Float_buf;
   1071          }
   1072          #endif
   1073          #endif
   1074          #if(SENSOR_TYPE =='S')
   1075          void DimmingAppControl(unsigned char cmd,unsigned char ch);
   1076          void DimmingAppControl(unsigned char cmd,unsigned char ch)
   1077          {
   1078          	unsigned char i,dl,dh;			
   1079          	unsigned int datas=0;
   1080          	if(cmd<0X76)
   1081          	{if(cmd==0)
   1082                    dh=cmd;
   1083                   else
   1084                    dh = 0X76-cmd;
   1085          	if(ch == 1)
   1086          	dh |= 0x80;	
   1087          	dl = ~dh;
   1088          	datas  = dl;
   1089                 //datas=0xaa;
   1090          	datas |= dh<<8;					//×îÖÕÒª·¢ËÍµÄÊý¾ÝÎª16Î»
   1091          							//¸ß8Î»ÃüÁî µÍ8Î»È¡·´Ð§Ñé
   1092          	P1_2 = 0;					//À­µÍÆ¬Ñ¡
   1093          	halMcuWaitUs(50);
   1094          	for(i=0;i<16;i++)
   1095          	{
   1096          		P1_1 = 0;
   1097          		halMcuWaitUs(10);					//ÕâÀï´óÔ¼ÊÇ100us
   1098          		if(datas & 0x8000)	P1_0 = 1;
   1099          		else 			P1_0 = 0;
   1100          		halMcuWaitUs(90);
   1101          		P1_1 = 1;			
   1102          		halMcuWaitUs(100);					//ÕâÀï´óÔ¼ÊÇ100us
   1103          		datas <<= 1;
   1104          	}
   1105          	P1_0 = 1;
   1106          	P1_2 = 1;
   1107          	P1_1 = 1;
   1108                  }
   1109          }
   1110          #endif 
   1111          
   1112          
   1113          //¶¨Ê±3Æô¶¯»ò¹Ø±Õ
   1114          #define BOOL int
   1115          void halSetTimer3Period(uint16 period);
   1116          __interrupt void T3_IRQ(void);
   1117          
   1118          //ÉèÖÃ¶¨Ê±Æ÷1µÄ¶¨Ê±ÖÜÆÚ
   1119          /*********************************************************************
   1120           * º¯ÊýÃû³Æ£ºhalSetTimer3Period
   1121           * ¹¦    ÄÜ£ºÉèÖÃ¶¨Ê±Æ÷3¶¨Ê±ÖÜÆÚ
   1122           * Èë¿Ú²ÎÊý£ºperiod   ¶¨Ê±ÖÜÆÚ
   1123           * ³ö¿Ú²ÎÊý£ºÎÞ
   1124           * ·µ »Ø Öµ£ºÎÞ
   1125           ********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1126          void halSetTimer3Period(uint16 period)
   \                     halSetTimer3Period:
   1127          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1128            /* ¸øT3CC0Ð´Èë×îÖÕ¼ÆÊýÖµperiod */
   1129            T3CC0 = period & 0xFF;             // °ÑperiodÖµÐ´ÈëT3CC0
   \   000000   EA           MOV     A,R2
   \   000001   F5CD         MOV     0xcd,A
   1130          }
   \   000003   02....       LJMP    ?BRET
   \   000006                REQUIRE T3CC0
   1131          /*********************************************************************
   1132           * º¯ÊýÃû³Æ£ºT3_IRQ
   1133           * ¹¦    ÄÜ£º¶¨Ê±Æ÷3ÖÐ¶Ï·þÎñº¯Êý
   1134           * Èë¿Ú²ÎÊý£ºÎÞ
   1135           * ³ö¿Ú²ÎÊý£ºÎÞ
   1136           * ·µ »Ø Öµ£ºÎÞ
   1137           ********************************************************************/
   1138          #pragma vector=T3_VECTOR

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   1139          __interrupt void T3_IRQ(void)
   \                     T3_IRQ:
   1140          {
   \   000000   C0E0         PUSH    A
   \   000002   74EB         MOV     A,#-0x15
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 22
   \   000007                ; Auto size: 0
   1141          
   1142              EA=FALSE;
   \   000007   C2AF         CLR     0xa8.7
   1143             if(TIMIF & 0x01)
   \   000009   A2D8         MOV     C,0xd8.0
   \   00000B   5057         JNC     ??T3_IRQ_0
   1144              { t1Val++;
   \   00000D   90....       MOV     DPTR,#__Constant_1
   \   000010   78..         MOV     R0,#?V0 + 0
   \   000012   12....       LCALL   ?L_MOV_X
   \   000015   90....       MOV     DPTR,#t1Val
   \   000018   78..         MOV     R0,#?V0 + 0
   \   00001A   12....       LCALL   ?L_ADD_TO_X
   1145              //if(t1Val>=12500)  //100ms
   1146              if(t1Val>=(125*T3_t1Val))  //T3_t1Val ms    
   \   00001D   90....       MOV     DPTR,#t1Val
   \   000020   C082         PUSH    DPL
   \   000022   90....       MOV     DPTR,#T3_t1Val
   \   000025   78..         MOV     R0,#?V0 + 0
   \   000027   12....       LCALL   ?L_MOV_X
   \   00002A   90....       MOV     DPTR,#__Constant_7d
   \   00002D   78..         MOV     R0,#?V0 + 4
   \   00002F   12....       LCALL   ?L_MOV_X
   \   000032   78..         MOV     R0,#?V0 + 0
   \   000034   79..         MOV     R1,#?V0 + 4
   \   000036   12....       LCALL   ?L_MUL
   \   000039   7583..       MOV     DPH,#((t1Val >> 8) & 0xff)
   \   00003C   D082         POP     DPL
   \   00003E   78..         MOV     R0,#?V0 + 0
   \   000040   12....       LCALL   ?UL_GT_X
   \   000043   401F         JC      ??T3_IRQ_0
   1147              { t1Val=0;
   \   000045   90....       MOV     DPTR,#__Constant_0
   \   000048   78..         MOV     R0,#?V0 + 0
   \   00004A   12....       LCALL   ?L_MOV_X
   \   00004D   90....       MOV     DPTR,#t1Val
   \   000050   78..         MOV     R0,#?V0 + 0
   \   000052   12....       LCALL   ?L_MOV_TO_X
   1148                GenericApp_applicationbuf=60001;
   \   000055   90....       MOV     DPTR,#GenericApp_applicationbuf
   \   000058   7461         MOV     A,#0x61
   \   00005A   F0           MOVX    @DPTR,A
   \   00005B   A3           INC     DPTR
   \   00005C   74EA         MOV     A,#-0x16
   \   00005E   F0           MOVX    @DPTR,A
   1149                GenericApp_time=0;
   \   00005F   E4           CLR     A
   \   000060   90....       MOV     DPTR,#GenericApp_time
   \   000063   F0           MOVX    @DPTR,A
   1150              }
   1151              }
   1152               EA=TRUE;
   \                     ??T3_IRQ_0:
   \   000064   D2AF         SETB    0xa8.7
   1153           TIMIF &= ~0x01;
   \   000066   C2D8         CLR     0xd8.0
   1154           }
   \   000068   7F08         MOV     R7,#0x8
   \   00006A   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   00006D                REQUIRE _A_IEN0
   \   00006D                REQUIRE _A_TIMIF
   1155          /*********************************************************************
   1156           * @fn      GenericApp_Init
   1157           *
   1158           * @brief   Initialization function for the Generic App Task.
   1159           *          This is called during initialization and should contain
   1160           *          any application specific initialization (ie. hardware
   1161           *          initialization/setup, table initialization, power up
   1162           *          notificaiton ... ).
   1163           *
   1164           * @param   task_id - the ID assigned by OSAL.  This ID should be
   1165           *                    used to send messages and set timers.
   1166           *
   1167           * @return  none
   1168           */
   1169          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1170          void GenericApp_Init( byte task_id )
   \                     GenericApp_Init:
   1171          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   1172            GenericApp_TaskID = task_id;
   \   000006   90....       MOV     DPTR,#GenericApp_TaskID
   \   000009   F0           MOVX    @DPTR,A
   1173            GenericApp_NwkState = DEV_INIT;
   \   00000A   7401         MOV     A,#0x1
   \   00000C   90....       MOV     DPTR,#GenericApp_NwkState
   \   00000F   F0           MOVX    @DPTR,A
   1174            GenericApp_TransID = 0;
   \   000010   E4           CLR     A
   \   000011   90....       MOV     DPTR,#GenericApp_TransID
   \   000014   F0           MOVX    @DPTR,A
   1175            openoff=0xaa;
   \   000015   74AA         MOV     A,#-0x56
   \   000017   90....       MOV     DPTR,#openoff
   \   00001A   F0           MOVX    @DPTR,A
   1176            // Device hardware initialization can be added here or in main() (Zmain.c).
   1177            // If the hardware is application specific - add it here.
   1178            // If the hardware is other parts of the device add it in main().
   1179            GenericApp_DstAddr.addrMode = (afAddrMode_t)Addr16Bit;;
   \   00001B   7402         MOV     A,#0x2
   \   00001D   90....       MOV     DPTR,#(GenericApp_DstAddr + 8)
   \   000020   F0           MOVX    @DPTR,A
   1180            GenericApp_DstAddr.endPoint = GENERICAPP_ENDPOINT;;
   \   000021   740A         MOV     A,#0xa
   \   000023   90....       MOV     DPTR,#(GenericApp_DstAddr + 9)
   \   000026   12....       LCALL   ?Subroutine22 & 0xFFFF
   1181            GenericApp_DstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVALL;
   1182          #if defined( POWER_SAVING )
   1183            GenericApp_DstAddr.addr.shortAddr =NWK_BROADCAST_SHORTADDR_AABB;
   1184          #endif
   1185            // Fill out the endpoint description.
   1186            GenericApp_epDesc.endPoint = GENERICAPP_ENDPOINT;
   \                     ??CrossCallReturnLabel_32:
   \   000029   740A         MOV     A,#0xa
   \   00002B   90....       MOV     DPTR,#GenericApp_epDesc
   \   00002E   F0           MOVX    @DPTR,A
   1187            GenericApp_epDesc.task_id = &GenericApp_TaskID;
   \   00002F   90....       MOV     DPTR,#(GenericApp_epDesc + 1)
   \   000032   74..         MOV     A,#(GenericApp_TaskID & 0xff)
   \   000034   F0           MOVX    @DPTR,A
   \   000035   A3           INC     DPTR
   \   000036   74..         MOV     A,#((GenericApp_TaskID >> 8) & 0xff)
   \   000038   F0           MOVX    @DPTR,A
   1188            GenericApp_epDesc.simpleDesc = (SimpleDescriptionFormat_t *)&GenericApp_SimpleDesc;
   \   000039   90....       MOV     DPTR,#(GenericApp_epDesc + 3)
   \   00003C   74..         MOV     A,#(GenericApp_SimpleDesc & 0xff)
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   A3           INC     DPTR
   \   000040   74..         MOV     A,#((GenericApp_SimpleDesc >> 8) & 0xff)
   \   000042   F0           MOVX    @DPTR,A
   1189            GenericApp_epDesc.latencyReq = noLatencyReqs;
   \   000043   E4           CLR     A
   \   000044   90....       MOV     DPTR,#(GenericApp_epDesc + 5)
   \   000047   F0           MOVX    @DPTR,A
   1190            // Register the endpoint description with the AF
   1191            afRegister( &GenericApp_epDesc );
   \   000048                ; Setup parameters for call to function afRegister
   \   000048   7A..         MOV     R2,#(GenericApp_epDesc & 0xff)
   \   00004A   7B..         MOV     R3,#((GenericApp_epDesc >> 8) & 0xff)
   \   00004C   12....       LCALL   ??afRegister?relay
   1192            // Register for all key events - This app will handle all key events
   1193            RegisterForKeys( GenericApp_TaskID );
   \   00004F                ; Setup parameters for call to function RegisterForKeys
   \   00004F   90....       MOV     DPTR,#GenericApp_TaskID
   \   000052   E0           MOVX    A,@DPTR
   \   000053   F9           MOV     R1,A
   \   000054   12....       LCALL   ??RegisterForKeys?relay
   1194          #if defined( ZigBee_C_R_E_Transparent )
   1195          #if !defined( SENSOR_TYPE_Coord )
   1196          #if defined( SENSOR_TYPE_R_E )
   1197                   Send_data[4]= SENSOR_TYPE_R_E;
   1198                   Send_data[5]= SENSOR_TYPE;
   1199          #endif
   1200          #endif
   1201          #endif
   1202          #if defined( SENSOR_TYPE_Coord )
   1203          #if (ZDO_COORDINATOR)
   1204          #if(ZDO_COORDINATOR==2)  //ZIGBEE  ATÃüÁîÄ£Ê½ Í¸´«Ä£Ê½
   1205                uint16 nv_data,nv_data1;
   1206              osal_nv_read(ZCD_NV_APP_PANID_H,0,sizeof(nv_data),&nv_data);
   1207              osal_nv_read(ZCD_NV_APP_PANID_L,0,sizeof(nv_data1),&nv_data1);
   1208              if((nv_data!=0)&&(zgConfigPANID==0XFFFF)&&(nv_data1!=0)&&(nv_data1==nv_data))
   1209              {zgConfigPANID=nv_data;
   1210             //  HalUARTWrite(HAL_UART_PORT_0,"AAAAA",5);
   1211              }
   1212          #else
   1213               ZigBee_C_R_E_Engineering_G();
   1214          #endif 
   1215          #endif 
   1216          #endif  
   1217          Send_data[0]=0XFA;
   \   000057   74FA         MOV     A,#-0x6
   \   000059   90....       MOV     DPTR,#Send_data
   \   00005C   F0           MOVX    @DPTR,A
   1218          #if defined( SENSOR_TYPE_Coord )
   1219          Send_data[0]=0XFD;
   \   00005D   74FD         MOV     A,#-0x3
   \   00005F   F0           MOVX    @DPTR,A
   1220          #endif
   1221          #if defined( SENSOR_TYPE_POWER )
   1222          Send_data[0]=0XFD;
   1223          #if defined( CC2530_V30 )
   1224           Send_data[0]=0XFE;
   1225          #endif
   1226          #endif
   1227          T_MGSbit=0x0A;//00001010¿É¿ØÀà ×ÛºÏÐÍ 
   \   000060   740A         MOV     A,#0xa
   \   000062   90....       MOV     DPTR,#T_MGSbit
   \   000065   F0           MOVX    @DPTR,A
   1228          
   1229          #if defined (NB_IOT_S10)
   1230            NBliucheng=0;
   1231          #endif
   1232            
   1233          #if((SENSOR_TYPE =='E')||(SENSOR_TYPE =='B')||(SENSOR_TYPE =='C')||(SENSOR_TYPE =='D')\
   1234            ||(SENSOR_TYPE =='F')||(SENSOR_TYPE =='U')||(SENSOR_TYPE ==0X10)||(SENSOR_TYPE ==0X21)\
   1235              ||(SENSOR_TYPE ==0X11)||(SENSOR_TYPE ==0X1A)||(SENSOR_TYPE ==0X0F)||(SENSOR_TYPE ==0X13)||(SENSOR_TYPE ==0X14)\
   1236                ||(SENSOR_TYPE ==0X24)||(SENSOR_TYPE ==0X6A)||(SENSOR_TYPE =='A')||(SENSOR_TYPE =='J')||\
   1237                  (SENSOR_TYPE =='L')||(SENSOR_TYPE =='M')||(SENSOR_TYPE ==0X33)\
   1238            ||(SENSOR_TYPE =='N')||(SENSOR_TYPE ==0X04)||(SENSOR_TYPE ==0X22)||(SENSOR_TYPE ==0X0C)\
   1239              ||(SENSOR_TYPE ==0X16)||(SENSOR_TYPE ==0X19)||(SENSOR_TYPE ==0X61)||(SENSOR_TYPE ==0X62)||(SENSOR_TYPE ==0X63)\
   1240                ||(SENSOR_TYPE ==0X5A)||(SENSOR_TYPE ==0X5B)||(SENSOR_TYPE ==0X72) ||(SENSOR_TYPE ==0X34)||(SENSOR_TYPE ==0X35)||(SENSOR_TYPE ==0X36)\
   1241                  ||(SENSOR_TYPE ==0X37)||(SENSOR_TYPE ==0X38)||(SENSOR_TYPE ==0X39)||(SENSOR_TYPE ==0X3A)||(SENSOR_TYPE ==0X80)\
   1242                    ||(SENSOR_TYPE ==0X3D)||(SENSOR_TYPE ==0X81)||(SENSOR_TYPE ==0X82)||(SENSOR_TYPE ==0X3B)||(SENSOR_TYPE ==0X3C)\
   1243                      ||(SENSOR_TYPE ==0X3E)||(SENSOR_TYPE ==0X3F)||(SENSOR_TYPE ==0X74)||(SENSOR_TYPE ==0X84)||(SENSOR_TYPE ==0X85)\
   1244                       ||(SENSOR_TYPE ==0X75)||(SENSOR_TYPE ==0X78) )
   1245                GenericApp_applicationbuf=60001;
   1246                GenericApp_time=1;
   1247          #if defined( POWER_SAVING )
   1248                GenericApp_time=25;
   1249          #endif
   1250          #endif
   1251          
   1252            
   1253          #if((SENSOR_TYPE =='A')||(SENSOR_TYPE =='J')||(SENSOR_TYPE =='L')||(SENSOR_TYPE =='M')||\
   1254            (SENSOR_TYPE =='N')||(SENSOR_TYPE ==0X04)||(SENSOR_TYPE ==0X0C)||(SENSOR_TYPE ==0X19)\
   1255              ||(SENSOR_TYPE ==0X22)||(SENSOR_TYPE ==0X61)||(SENSOR_TYPE ==0X62)||(SENSOR_TYPE ==0X63)||(SENSOR_TYPE ==0X72)\
   1256                ||(SENSOR_TYPE ==0X34)||(SENSOR_TYPE ==0X35)||(SENSOR_TYPE ==0X36)||(SENSOR_TYPE ==0X37)||(SENSOR_TYPE ==0X38)\
   1257                  ||(SENSOR_TYPE ==0X39)||(SENSOR_TYPE ==0X3A)||(SENSOR_TYPE ==0X3E)||(SENSOR_TYPE ==0X3F)||(SENSOR_TYPE ==0X75)) 
   1258          T_MGSbit=0x12;    // 00010010×´Ì¬ÐÅÏ¢ Êý¾ÝÐÅÏ¢  Á¬Êý¾ÝÐÅÏ¢¼ÇÂ¼
   1259          //²É¼¯Àà  BOOLÐÍ
   1260          #endif  
   1261          #if((SENSOR_TYPE =='B')||(SENSOR_TYPE =='C')||(SENSOR_TYPE =='D')||(SENSOR_TYPE =='G')||\
   1262            (SENSOR_TYPE =='I')||(SENSOR_TYPE ==0X77)||(SENSOR_TYPE =='Q')||(SENSOR_TYPE =='T')||(SENSOR_TYPE ==0X03)||(SENSOR_TYPE ==0X07)\
   1263              ||(SENSOR_TYPE ==0X0F)||(SENSOR_TYPE ==0X10)||(SENSOR_TYPE ==0X0E)\
   1264                ||(SENSOR_TYPE ==0X16)||(SENSOR_TYPE ==0X17)||(SENSOR_TYPE ==0X20)||(SENSOR_TYPE ==0X21)\
   1265                  ||(SENSOR_TYPE ==0X24)||(SENSOR_TYPE ==0X5A)||(SENSOR_TYPE ==0X5B)||(SENSOR_TYPE ==0X64)||(SENSOR_TYPE ==0X33)||(SENSOR_TYPE ==0X80)) 
   1266          T_MGSbit=0x14;    // 00010100×´Ì¬ÐÅÏ¢ Êý¾ÝÐÅÏ¢  Á¬Êý¾ÝÐÅÏ¢¼ÇÂ¼
   1267          //²É¼¯Àà  ÕûÐÍ
   1268          #endif 
   1269          #if((SENSOR_TYPE =='E')||(SENSOR_TYPE =='F')||(SENSOR_TYPE =='U')||(SENSOR_TYPE ==0X81)||(SENSOR_TYPE ==0X82)||(SENSOR_TYPE ==0X85)) 
   1270          T_MGSbit=0x16; // 00010110×´Ì¬ÐÅÏ¢ Êý¾ÝÐÅÏ¢  Á¬Êý¾ÝÐÅÏ¢¼ÇÂ¼
   1271          //²É¼¯Àà  ¸¡µãÐÍ
   1272          #endif
   1273          #if((SENSOR_TYPE ==0X08)||(SENSOR_TYPE ==0X0A)||(SENSOR_TYPE ==0X0B)||(SENSOR_TYPE ==0X0D)) 
   1274          T_MGSbit=0x18;    // 00011000×´Ì¬ÐÅÏ¢ Êý¾ÝÐÅÏ¢  Á¬Êý¾ÝÐÅÏ¢¼ÇÂ¼
   1275          //²É¼¯Àà  ×Ö·û´®  Êý¾ÝµÚÈýÎ»¿ªÊ¼
   1276          #endif
   1277           ////////////////////////////////////////////////////////////////////////////////////////////
   1278          //OLEDÆÁÏÔÊ¾ÄÚÈÝ
   1279          /*
   1280          OLED_Init(); //OLED³õÊ¼»¯ 
   1281          OLED_P8x16Str(0,0,"R       ID:");//µÚÒ»ÐÐ -- 8x16µÄÏÔÊ¾µ¥ÔªÏÔÊ¾ASCIIÂë
   1282          #if defined( SENSOR_TYPE_Coord )
   1283          #if (ZDO_COORDINATOR)
   1284             OLED_P8x16Str(0,0,"C    PANID:");//µÚÒ»ÐÐ -- 8x16µÄÏÔÊ¾µ¥ÔªÏÔÊ¾ASCIIÂë
   1285          #endif 
   1286          #endif 
   1287          #if defined( POWER_SAVING )
   1288           OLED_P8x16Str(0,0,"E       ID:");//µÚÒ»ÐÐ -- 8x16µÄÏÔÊ¾µ¥ÔªÏÔÊ¾ASCIIÂë
   1289          #endif
   1290          char *s=0;
   1291          uint16 nv_data; 
   1292          osal_nv_read(ZCD_NV_APP_CHANLIST,0,sizeof(nv_data),&nv_data);
   1293          sprintf(s, "%02d", (nv_data&0x00ff)); 
   1294          OLED_P8x16Str(16,0,s);//µÚÒ»ÐÐ -- 8x16µÄÏÔÊ¾µ¥ÔªÏÔÊ¾ASCIIÂë
   1295          #if !defined( SENSOR_TYPE_Coord )
   1296          sprintf(s, "%02X", SENSOR_TYPE); 
   1297          OLED_P8x16Str(40,0,s);//µÚÒ»ÐÐ -- 8x16µÄÏÔÊ¾µ¥ÔªÏÔÊ¾ASCIIÂë
   1298          #endif 
   1299          osal_nv_read(ZCD_NV_APP_PANID_H,0,sizeof(nv_data),&nv_data);
   1300          sprintf(s, "%04X", nv_data); 
   1301          OLED_P8x16Str(88,0,s);//µÚÒ»ÐÐ -- 8x16µÄÏÔÊ¾µ¥ÔªÏÔÊ¾ASCIIÂë
   1302          OLED_P8x16Str(0,2,"V2.45");
   1303          #if defined( CC2530_V30 )
   1304          OLED_P8x16Str(0,2,"V3.00");
   1305          #endif
   1306          sprintf(s, "%04X", NLME_GetCoordShortAddr()); 
   1307          OLED_P8x16Str(48,2,s);
   1308          sprintf(s, "%04X", NLME_GetShortAddr());
   1309          OLED_P8x16Str(88,2,s);
   1310           byte * Send_d;
   1311            Send_d=NLME_GetExtAddr();
   1312          sprintf(s, "%02X%02X%02X%02X%02X%02X%02X%02X", *Send_d,*(Send_d+1),*(Send_d+2),*(Send_d+3),*(Send_d+4),*(Send_d+5),*(Send_d+6),*(Send_d+7));
   1313          OLED_P8x16Str(0,4,s);
   1314          */
   1315           ////////////////////////////////////////////////////////////////////////////////////////////
   1316          #if(SENSOR_TYPE =='Q') 
   1317            P1DIR|=0x02 ;  //Êý¾ÝÊä³ö P1_1
   1318            P1DIR&=~0X04;  //Êý¾ÝÊäÈë P1_2
   1319            P1DIR |= 0XF9;  
   1320            Send_data[6]='Q';//´«¸ÐÆ÷ÀàÐÍ
   1321           Send_datalend=0x03;    
   1322           RSn=50;
   1323           HX_Q=0;
   1324           HXtime=0;
   1325           HXS=0;
   1326           T_MUMPT1=0;
   1327            uint16 nv_data=0X0000;
   1328           osal_nv_read(ZCD_NV_APP_AD_SHINING,0,sizeof(nv_data),&nv_data);  
   1329           if((nv_data>49)&&(nv_data<151))AD_SHINING=nv_data;
   1330           else AD_SHINING=90;
   1331           
   1332           Ht1621_Init(); //ÉÏµç³õÊ¼»¯LCD
   1333           char t;
   1334            P1_0=0;
   1335            for (char i=0;i<15;i++) //30¸ö×Ö¶Î 18¸ö×Ö¶Î SEG0¡«SEG17 
   1336                   {t=0x01;
   1337                    for (char j=0;j<4;j++)//4¸öÒ»×é COM0-3
   1338                           {
   1339                            Ht1621WrOneData(i,t); //SEG0 COM0-3. SEG1 COM0-3. SEG2 COM0-3. SEG3 COM0-3. .......
   1340                           t<<=1;
   1341                            t++;
   1342                            }
   1343                     }
   1344           halMcuWaitMs(5000);//ÑÓÊ±5Ãë È¥Æ¤²Ù×÷ //ÑÓÊ±Ò»¶ÎÊ±¼ä
   1345            Ht1621WrAllData(0,Ht1621Tab,9);//Çå³ý1621¼Ä´æÆ÷Êý¾Ý£¬ôßÇåÆÁ //SEG0¡«SEG17 COM0-3=0X00 0000 È«Ãð
   1346           Tozero();//×Ô¶¯¹éÁã
   1347          #endif   
   1348          #if(SENSOR_TYPE ==0X08) 
   1349             Send_data[7]=0xA1;//¶Á¿¨  15693
   1350             GenericApp_appIO=0;
   1351            GenericApp_BX=0;
   1352          #endif  
   1353          #if(SENSOR_TYPE ==0X0D) 
   1354          #if defined(TGRD15693) 
   1355             Send_data[7]=0xA1;//¶Á¿¨  15693
   1356          #endif 
   1357          #if defined(PN532) 
   1358             Send_data[7]=0xA2;//M1¿¨
   1359          #endif 
   1360          #endif 
   1361          #if(SENSOR_TYPE ==0X0A) 
   1362             Send_datalend=0X14;
   1363              Send_data[7]=0xA1;//¶Á¿¨  15693
   1364          #endif  
   1365          #if(SENSOR_TYPE ==0X0B) 
   1366             Send_datalend=0X14;
   1367              Send_data[7]=0x01;//¶Á¿¨  125K
   1368          #endif  
   1369          #if((SENSOR_TYPE ==0X10)||(SENSOR_TYPE ==0X0F)||(SENSOR_TYPE ==0X17)||(SENSOR_TYPE ==0X21)) 
   1370           Send_datalend=0x03;   
   1371          HalAdcInit ();
   1372          #endif  
   1373          #if((SENSOR_TYPE ==0X11)||(SENSOR_TYPE ==0X1A)||(SENSOR_TYPE ==0X3D)||(SENSOR_TYPE ==0X3B)||(SENSOR_TYPE ==0X3C))
   1374           Send_datalend=0x06;   
   1375           GenericApp_sbum=0;
   1376           T_MUMPT1=0;
   1377          HalAdcInit ();
   1378          #endif  
   1379          #if(SENSOR_TYPE ==0X84) 
   1380           Send_datalend=0x05;   
   1381           GenericApp_sbum=0;
   1382            P1DIR|=0x1E;   //Êý¾ÝÊä³ö
   1383           T_MUMPT1=0;
   1384          HalAdcInit ();
   1385          #endif 
   1386          #if(SENSOR_TYPE ==0X23) 
   1387             Send_datalend=0X05;
   1388          #endif 
   1389          #if(SENSOR_TYPE ==0X24)
   1390             P1DIR|=0x04;   //Êý¾ÝÊä³ö P1_2
   1391             P1DIR&=~0x02;  //Êý¾ÝÊäÈë P1_1
   1392             P1_1=0;   P1_2=0;     //³õÊ¼»¯Òý½Å
   1393             Send_datalend=0x05;
   1394          #endif 
   1395          #if(SENSOR_TYPE ==0X80)
   1396             P2DIR&=~0x01;  //Êý¾ÝÊäÈë P2_0  ÆðÊ¼¼ì²âµã
   1397             P2INP&=~0x01;//ÉÏÀ­
   1398             Send_datalend=0x07;
   1399          #endif 
   1400          #if(SENSOR_TYPE ==0X27)
   1401            // uint8 syn[11]={0XFD,0X00,0X08,0X01,0X01,0X5B,0X76,0X31,0X36,0X5D,0X82};//ÒôÁ¿×î´ó
   1402            // uint8 syn[11]={0XFD,0X00,0X08,0X01,0X01,0X5B,0X76,0X31,0X31,0X5D,0X82};//ÒôÁ¿×îÖÐ´ó
   1403             
   1404             //FD 00 07 01 01 5B 76 39 5D B3 //ÒôÁ¿Ð¡ÖÐ
   1405             //FD 00 07 01 01 5B 76 32 5D 82// ÒôÁ¿Ð¡
   1406               Send_datalend=3;
   1407                SYN_FrameInfo(0,1,"msgh",250) ;//ringo
   1408                // HalUARTWrite(HAL_UART_PORT_0,syn,11);//ÖÇÄÜÓïÑÔ²¥±¨
   1409          #endif
   1410          #if(SENSOR_TYPE ==0X6F)
   1411            
   1412           P1DIR|=0XE0;
   1413           P1DIR|=0x1E;       //P1.1-P1.4Êý¾ÝÊä³ö
   1414           P1|=0X1E;           //
   1415           delay_ms(1);
   1416           init_lcd();
   1417           lcd_gra_clr();
   1418           lcd_txt_clr(); 
   1419           //hzkdis_b(0,"msgh",4);
   1420                hzkdis_b(0,"  ÎÞÎý·ºÌ«¿Æ¼¼",14);
   1421                Send_datalend=0x05;
   1422                SYN_FrameInfo(0,1,"msgh",250) ;//ringo
   1423                // HalUARTWrite(HAL_UART_PORT_0,syn,11);//ÖÇÄÜÓïÑÔ²¥±¨
   1424          #endif
   1425                
   1426          #if(SENSOR_TYPE ==0X28)
   1427          { 
   1428            LCD_Init();   // LCD³õÊ¼»¯
   1429            LCD_Clear();  // LCDÇåÆÁ
   1430            /* ÏÔÊ¾ÐÅÏ¢ */
   1431            LCD_WriteString(0,6,"WWW.fantaitech.com");
   1432           // LCD_WriteString(0,3,"FANTAI ELECTRONICS");
   1433           // LCD_WriteString(0,5,"WWW.fantaitech.com");
   1434           // LCD_WriteString(6,7,"453:0510-88236212");
   1435            Send_datalend=5;
   1436          } 
   1437          #endif 
   1438          #if(SENSOR_TYPE ==0X31)
   1439          car_stata=0;
   1440          car_op=0; //ÇåÁã£¬¿É´¦Àí¶Á¿¨
   1441          car_sum=0;
   1442            P1SEL&=~0X01;
   1443            P1DIR&=~0X01;  //P1_0ÊäÈëÄ£Ê½
   1444          #endif
   1445          #if(SENSOR_TYPE ==0X64)
   1446          { Send_datalend=0x03;
   1447            P1SEL&=~0Xff;
   1448            P1DIR&=~0X99;
   1449            P1DIR|=0X55;
   1450          }  
   1451          #endif
   1452          #if(SENSOR_TYPE ==0X65)
   1453           P0SEL=0X00;
   1454              P1SEL&=0X00;
   1455              P1DIR|=0Xff;
   1456              P1INP|=0Xf0;
   1457              Send_datalend=0x05;
   1458              LCD_lni();    //lcd³õÊ¼»¯
   1459              LCD_clrscr(); //lcdÇåÆÁ
   1460              show_left_up();  //lcd×ó°ëÆÁÉÏÃæ4¸ö×ÖÏÔÊ¾º¯Êý   ÎÞÎý·º
   1461              show_right_up();//lcdÓÒ°ëÆÁÉÏÃæ4¸ö×ÖÏÔÊ¾º¯Êý   Ì«¿Æ¼¼
   1462              show_left_down();
   1463          #endif
   1464          #if(SENSOR_TYPE ==0X6C)
   1465           P1DIR|=0XE0;
   1466           P1DIR|=0x1E;       //P1.1-P1.4Êý¾ÝÊä³ö
   1467           P1|=0X1E;           //
   1468          Send_datalend=0x05;
   1469           delay_ms(1);
   1470           init_lcd();
   1471           lcd_gra_clr();
   1472           lcd_txt_clr(); 
   1473            hzkdis(0,tab0);
   1474          #endif
   1475          #if(SENSOR_TYPE ==0X33)
   1476            P1SEL &= ~(0x18);		//Ñ¡ÔñIO¿Ú
   1477            B_LUX30_Init();
   1478          #endif
   1479          #if((SENSOR_TYPE ==0X66)||(SENSOR_TYPE ==0X6E))
   1480           P0SEL=0X00;
   1481              P1SEL&=0X00;
   1482              P1DIR|=0Xff;
   1483              P1INP|=0Xf0;
   1484               P2SEL&=0X00;
   1485              P2DIR|=0X01;
   1486              Send_datalend=0x05;
   1487              uint8 spt[2]={0,0};
   1488               SendDataS(spt,2);
   1489          #endif
   1490          #if(SENSOR_TYPE ==0X76)
   1491               P2DIR&=~0X01;//ÊäÈë
   1492              P2INP&=~0x01;//ÉÏÀ­
   1493              Send_datalend=0x05;
   1494          #endif
   1495          #if(SENSOR_TYPE ==0X30)
   1496              P1DIR|=0XE0;//Êä³ö
   1497              P1DIR|=0X0f;
   1498              P2DIR&=~0X01;//ÊäÈë
   1499              P2INP&=~0x01;//ÉÏÀ­
   1500              Coil_OFF;
   1501              Send_datalend=0x05;
   1502              DAchange(4095);
   1503          #endif
   1504          #if(SENSOR_TYPE ==0X73)
   1505              P1DIR|=0Xf0;   //P1.6 P1.7Êä³ö
   1506              P2DIR&=~0X01;//ÊäÈë
   1507              P2INP&=~0x01;//ÉÏÀ­
   1508              A8n=1;
   1509              Send_datalend=0x05;
   1510          #endif
   1511              
   1512          #if(SENSOR_TYPE ==0X7C)
   1513                uint8  hr[5]={0XF7,0x03,0xB1,0X52,0X00};
   1514               HalUARTWrite(HAL_UART_PORT_0,hr,5);//¿ª¹Ø°ó¶¨Ä£Ê½ 
   1515          #endif
   1516          #if(SENSOR_TYPE =='D') 
   1517          { Send_datalend=0x05;
   1518                 P1DIR|=0xff;       //Êý¾ÝÊä³ö
   1519                 P1SEL&=~0x01;P1DIR&=~0X01;
   1520                 P2SEL|=0x01;P2DIR|=0X01;
   1521                 P1_3=0;
   1522                 for(unsigned int i=0;i<50000;i++);
   1523                  S0=1;S1=1;
   1524          //----------------------°×Æ½ºâµ÷Õû-----------------------------
   1525          	 OUTR = 255.0/TCS3200(1);
   1526          	 OUTG = 255.0/TCS3200(2);
   1527          	 OUTB = 255.0/TCS3200(3);
   1528          } 
   1529          #endif                           
   1530          #if(SENSOR_TYPE =='S') 
   1531              P1SEL &=0xF7;
   1532              P1DIR |= 0x07;//P1.1,P1.2,P1.3Êý¾ÝÊä³ö
   1533              P1DIR &= ~(0xE0);//P1.5,P1.6,P1.7Êý¾ÝÊäÈë
   1534              P1INP |= 0x07;
   1535            Send_datalend=0x05;                         
   1536          #endif   
   1537          #if(SENSOR_TYPE ==0X67) 
   1538              P0SEL &=0x30;
   1539              P0DIR |= 0x30;//P0.4,P0.5,Êý¾ÝÊä³ö
   1540              P1DIR|=0XE0;//Êä³ö
   1541              P1DIR|=0X0F;//Êä³ö
   1542              P1_0=0;
   1543              P1_1=0;
   1544              P1_2=0;
   1545              P1_3=0;
   1546              P0_4=0;
   1547              P0_5=0;
   1548            Send_datalend=0x05;   
   1549          int mled=0;
   1550          //DAchange(4095);
   1551              mled=1000;
   1552              for(int i=0;i<3000;i++)
   1553              {halMcuWaitMs(1);
   1554              DAchange(mled);
   1555              mled+=1;
   1556              }
   1557          DAchange(0);
   1558          #endif  
   1559          #if(ENSOR_TYPE ==0X68) 
   1560              P0DIR |= 0x0F;//P0.0-3,Êý¾ÝÊä³ö
   1561              P0_0=0;P0_1=0;P0_2=0;P0_3=0;
   1562            Send_datalend=0x05;                         
   1563          #endif  
   1564          #if(SENSOR_TYPE ==0X6A) 
   1565          #if defined(ADCP) 
   1566              HalAdcInit ();
   1567          #endif 
   1568              Send_data[7]=0;
   1569          #if defined(HX711P) 
   1570               P1DIR|=0x02 ;  //Êý¾ÝÊä³ö P1_1
   1571              P1DIR&=~0X04;  //Êý¾ÝÊäÈë P1_2
   1572              Tozero();//×Ô¶¯¹éÁã
   1573          #endif 
   1574            Send_datalend=0x05;                         
   1575          #endif 
   1576          #if(SENSOR_TYPE ==0X03)  //P1.0-P1.3  D0-D3  P0.7 VT
   1577             
   1578              P1DIR &= ~(0x1F);//P1.0,P1.1,P1.2,P1.3,P1.4Êý¾ÝÊäÈë
   1579               P1INP |= 0x1F;
   1580             Send_datalend=0x03;                         
   1581          #endif   
   1582          #if(SENSOR_TYPE ==0X05) 
   1583           //P1DIR&=(~0x06);       //P1.1 P1.2Êý¾ÝÊäÈë
   1584          P1DIR|=0xC0;       //P1.6,P1.7Êý¾ÝÊä³ö
   1585          P1_6=0;
   1586          P1_7=0;
   1587          Send_datalend=0x05;                                             
   1588          #endif   
   1589          #if(SENSOR_TYPE =='U') 
   1590            Send_datalend=0x04;
   1591           P1SEL &= ~0X04;P1INP|=0X04;
   1592          #endif    
   1593          #if(SENSOR_TYPE =='H') 
   1594           P1DIR|=0xC1;       //P1.0,P1.6,P1.7Êý¾ÝÊä³ö
   1595          P1_0=1;
   1596          P1_6=1;
   1597          P1_7=1;
   1598          Send_datalend=0x05;                         
   1599          #endif      
   1600          #if((SENSOR_TYPE =='P')||(SENSOR_TYPE ==0X02))
   1601          Send_datalend=0x05;
   1602          #endif  
   1603          #if(SENSOR_TYPE ==0X77)
   1604          Send_datalend=0x03;
   1605            P1SEL&=~0Xff;
   1606            P1DIR&=~0Xff;
   1607           // P1INP&=~0Xff;P2INP&=~0X40;
   1608          #endif  
   1609          #if(SENSOR_TYPE =='I')
   1610          { Send_datalend=0x05;
   1611            P1SEL&=~0Xff;
   1612            P1DIR&=~0Xff;
   1613           // P1INP|= 0Xff;
   1614            
   1615            P2SEL&=~0X07;
   1616            P2DIR&=~0X07;
   1617           // P2INP|= 0X07;
   1618            P0SEL&=~0X10;
   1619            P0DIR&=~0X10;
   1620            //P0INP|= 0X10;
   1621          }  
   1622          #endif  
   1623          
   1624          #if(SENSOR_TYPE =='G')
   1625          { Send_datalend=0x08;
   1626           P1DIR|=0X0f;
   1627           Coil_OFF;
   1628          Coil_AB=0;
   1629          } 
   1630          #endif                            
   1631          #if(SENSOR_TYPE =='F')
   1632          #if defined(BMP085) 
   1633          { Send_datalend=0x06;
   1634           XCLROUT;
   1635            BMP085_init();	//¶ÁÈ¡BMP085µÄE2PROMÖÐµÄ11¸ö±ê¶¨²ÎÊý
   1636          }
   1637          #endif 
   1638          #if defined(BMP180) 
   1639          
   1640          #define XCLR P1_5 
   1641          #define XCLROUT P1DIR|=0x20       //Êý¾ÝÊä³ö
   1642          Send_datalend=0x06;
   1643           XCLROUT;
   1644           XCLR=1; 
   1645           
   1646           Init_BMP180();
   1647           
   1648          #endif
   1649          #endif                         
   1650          #if(SENSOR_TYPE =='C')
   1651          { Send_datalend=0x03;}
   1652          #endif            
   1653          
   1654          #if(SENSOR_TYPE =='B')
   1655          { Send_datalend=0x05;
   1656            MMA7660_Startup();
   1657          } 
   1658          #endif   
   1659          #if((SENSOR_TYPE ==0X13)||(SENSOR_TYPE ==0X5A)||(SENSOR_TYPE ==0X5B)||(SENSOR_TYPE ==0X70))
   1660                P1DIR|=0x01;       //P1.0Êý¾ÝÊä³ö  485¿ØÖÆ¶Ë
   1661            P1_0=0;
   1662            Send_data[6]=SENSOR_TYPE;
   1663            Send_data[7]=0XAA;
   1664             Send_datalend=0X04;
   1665            //U0UCR|=0X38;
   1666          #endif 
   1667          #if(SENSOR_TYPE ==0X14) 
   1668            P1DIR|=0x01;       //P1.0Êý¾ÝÊä³ö  485¿ØÖÆ¶Ë
   1669            P1_0=0;
   1670             Send_datalend=0X07;
   1671          #if defined(PH_E201C)
   1672           P1SEL &= ~0X04;P1INP|=0X04;
   1673             HalAdcInit ();
   1674          #endif 
   1675          #endif 
   1676          #if(SENSOR_TYPE ==0X74)
   1677            P1DIR|=0x01;       //P1.0Êý¾ÝÊä³ö  485¿ØÖÆ¶Ë
   1678            P1_0=0;
   1679            Send_datalend=0X05;
   1680          #endif 
   1681          #if(SENSOR_TYPE ==0X15)
   1682          { 
   1683          P1DIR|=0x1E;       //P1.0-P1.4Êý¾ÝÊä³ö
   1684          P1=0X1E;           //
   1685          Send_datalend=0x05;
   1686          } 
   1687          #endif 
   1688          #if(SENSOR_TYPE =='K')
   1689          { 
   1690          P1DIR&=(~0x06);       //P1.1 P1.2Êý¾ÝÊäÈë
   1691          P1SEL &= ~0X06;P1INP|=0X06;  //ÉÏÀ²
   1692          P1DIR|=0x01;       //P1.0Êý¾ÝÊä³ö
   1693          P1_0=1;  T_MG=0X00;       //¼ÌµçÆ÷¹Ø
   1694          Send_datalend=0x05;
   1695          } 
   1696          #endif  
   1697          #if(SENSOR_TYPE ==0X79)
   1698          PDI=0;
   1699          ERR_TEMP=0;
   1700          P1DIR|=0x21;       //P1_5  P1_0Êý¾ÝÊä³ö
   1701          P1_5=P1_0=0X01;         //¼ÌµçÆ÷¹Ø
   1702          Send_datalend=0x05;
   1703            P1SEL &= ~0X06;P1INP|=0X04; P1DIR|=0x06;
   1704            s_connectionreset(); //ÎÂÊª¶È³õÊ¼»¯
   1705           HalAdcInit (); //ad²É¼¯³õÊ¼»¯
   1706          #endif  
   1707          #if(SENSOR_TYPE ==0X83)
   1708          {
   1709          P0DIR&=(~0xf0);       //P07 P06 P05Êý¾ÝÊäÈë
   1710          P0SEL &= ~0Xf0;P0INP|=0Xf0;  //ÉÏÀ²
   1711          P1DIR|=0xFF;       //P1Êý¾ÝÊä³ö
   1712          P1=0XFF; T_MG=0X00;       //¼ÌµçÆ÷¹Ø
   1713          Send_datalend=0x05;
   1714          } 
   1715          #endif  
   1716          #if(SENSOR_TYPE ==0X40)
   1717          { 
   1718          P1DIR|=0x0E;       //P1.1 P1.2 P1.3Êý¾ÝÊä³ö
   1719          P1DIR|=0x91;       //P1.7 P1.4 P1.0Êý¾ÝÊä³ö
   1720          P1_1=1;           //
   1721          P1_2=1;           //
   1722          P1_3=1;           //
   1723          P1_0=0;           //·äÃùÆ÷
   1724          P1_4=0;           //ºìµÆ
   1725          P1_7=0;           //À¶µÆ
   1726          Send_datalend=0x05;
   1727          } 
   1728          #endif 
   1729          
   1730          #if(SENSOR_TYPE ==0X07)
   1731          AB=0x0A;
   1732          #endif 
   1733          #if(SENSOR_TYPE ==0X12)
   1734          { 
   1735          P1DIR&=(~0x06);       //P1.1 P1.2Êý¾ÝÊäÈë
   1736          P1SEL &= ~0X06;P1INP|=0X06;  //ÉÏÀ²
   1737          P1DIR|=0xC1;       //P1.0,P1.6,P1.7Êý¾ÝÊä³ö
   1738          P1_0=1;//¼ÌµçÆ÷¹Ø
   1739          P1_6=1;
   1740          P1_7=1;     
   1741          Send_datalend=0x05;
   1742          } 
   1743          #endif 
   1744          #if(SENSOR_TYPE ==0X18)
   1745          { 
   1746          P1DIR&=(~0x06);       //P1.1 P1.2Êý¾ÝÊäÈë
   1747          P1SEL &= ~0X06;P1INP|=0X06;  //ÉÏÀ²
   1748          P1DIR|=0xC1;       //P1.0,P1.6,P1.7Êý¾ÝÊä³ö
   1749          P1_0=1;   
   1750          U0UCR|=0X38;
   1751          Send_datalend=0x05;
   1752          } 
   1753          #endif 
   1754          #if(SENSOR_TYPE ==0X06)
   1755          Send_datalend=0x05;
   1756           P1SEL &= ~0X04;P1INP|=0X04;
   1757           ReadTemperature(); 
   1758          #endif
   1759          #if(SENSOR_TYPE ==0X09)
   1760          Send_datalend=0x05;
   1761          #endif
   1762          
   1763          #if defined (NB_IOT_S10)
   1764          P0SEL &= ~0X10;
   1765          P0DIR|=0x10;       //P0.4,Êý¾ÝÊä³ö
   1766          P0_4=0;   
   1767          #endif
   1768          
   1769          #if(SENSOR_TYPE =='E')
   1770          { Send_datalend=0x06;
   1771            P1SEL &= ~0X06;P1INP|=0X04; P1DIR|=0x06;
   1772            s_connectionreset();
   1773          } 
   1774          #endif 
   1775          #if(SENSOR_TYPE ==0X85)
   1776                _SCL_IO;                                            //ÒýÓÃºê¶¨Òå-ÉèÖÃSCLÎª¿ªÂ©Ê½I/O¿Ú
   1777               _SDA_OUTPUT;                                //ÒýÓÃºê¶¨Òå-ÉèÖÃSDAÎª¿ªÂ©Ê½Êä³ö
   1778               SCL=0;				//
   1779               Delay_mlx90615(30000);		 //SMBusÇëÇóÊ±¼ä£¬½«PWMÄ£Ê½×ª»»ÎªSMBusÄ£Ê½(21ms - 39ms)
   1780               SCL=1;				//	
   1781          #endif 
   1782          #if(SENSOR_TYPE ==0X82)
   1783          { Send_datalend=0x09;
   1784            P1SEL &= ~0X18;P1INP|=0X18; P1DIR|=0x18;
   1785            P1DIR&=(~0x04)  ; //P1_2Êý¾ÝÊäÈë ÉÏÀ­
   1786            Init_HMC5883();
   1787          } 
   1788          #endif 
   1789          #if(SENSOR_TYPE ==0X81)
   1790          { 
   1791            Send_datalend=0x06;
   1792            P1DIR&=(~0x20);       // P1.5Êý¾ÝÊäÈë
   1793          P1SEL &= ~0X20;P1INP|=0X20;  //ÉÏÀ²
   1794          P1DIR|=0xC0;       //PP1.6,P1.7Êý¾ÝÊä³ö
   1795          } 
   1796          #endif 
   1797          #if(SENSOR_TYPE ==0X78)
   1798          Send_datalend=34;
   1799          send_Instruction();//ÏòÄ£¿é·¢ËÍ5¸öÖ¸Áî
   1800          
   1801          #endif 
   1802          
   1803          #if((SENSOR_TYPE =='A')||(SENSOR_TYPE =='J')||(SENSOR_TYPE =='L')||(SENSOR_TYPE =='M')||(SENSOR_TYPE =='N')\
   1804            ||(SENSOR_TYPE ==0X04)||(SENSOR_TYPE ==0X22)||(SENSOR_TYPE ==0X0C)||(SENSOR_TYPE ==0X16)||(SENSOR_TYPE ==0X19)\
   1805              ||(SENSOR_TYPE ==0X61)||(SENSOR_TYPE ==0X62)||(SENSOR_TYPE ==0X63)||(SENSOR_TYPE ==0X72) ||(SENSOR_TYPE ==0X34)\
   1806                ||(SENSOR_TYPE ==0X35)||(SENSOR_TYPE ==0X36)||(SENSOR_TYPE ==0X37)||(SENSOR_TYPE ==0X38)||(SENSOR_TYPE ==0X39)\
   1807                  ||(SENSOR_TYPE ==0X3A)||(SENSOR_TYPE ==0X3E)||(SENSOR_TYPE ==0X3F)||(SENSOR_TYPE ==0X75))
   1808          {
   1809            Send_datalend=0x04;
   1810          #if(SENSOR_TYPE ==0X72)
   1811              Send_datalend=0x06;
   1812          #if defined( SDS011 )
   1813          Send_datalend=0x08;
   1814          #endif
   1815          #endif   
   1816          #if(SENSOR_TYPE ==0X22)
   1817          Send_datalend=0x05;
   1818          #endif
   1819          HalAdcInit ();
   1820          P2SEL &=( ~0X01);
   1821          P2DIR&=(~0x01);       // P2.0Êý¾ÝÊäÈë
   1822          P2INP=0X00;  //ÉÏÀ²  
   1823          P2INP &=(~0X01); //ÉÏÀ²
   1824          T_MUMPT1=0;
   1825          }  
   1826          #endif     
   1827          
   1828            // Update the display
   1829          #ifdef SERIAL_DEBUG_SUPPORTED
   1830            //printf("GenericApp\n"); 
   1831          #endif
   1832            
   1833            //ZDO_RegisterForZDOMsg( GenericApp_TaskID, End_Device_Bind_rsp );
   1834            //ZDO_RegisterForZDOMsg( GenericApp_TaskID, Match_Desc_rsp );
   1835          }
   \   000066   02....       LJMP    ??Subroutine28_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   90....       MOV     DPTR,#GenericApp_DstAddr
   \   000004   74FF         MOV     A,#-0x1
   \   000006   F0           MOVX    @DPTR,A
   \   000007   A3           INC     DPTR
   \   000008   F0           MOVX    @DPTR,A
   \   000009   22           RET
   1836          /*********************************************************************
   1837           * @fn      GenericApp_ProcessEvent
   1838           *
   1839           * @brief   Generic Application Task event processor.  This function
   1840           *          is called to process all events for the task.  Events
   1841           *          include timers, messages and any other user defined events.
   1842           *
   1843           * @param   task_id  - The OSAL assigned task ID.
   1844           * @param   events - events to process.  This is a bit map and can
   1845           *                   contain more than one event.
   1846           *
   1847           * @return  none
   1848           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1849          UINT16 GenericApp_ProcessEvent( byte task_id, UINT16 events )
   \                     GenericApp_ProcessEvent:
   1850          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1851            afIncomingMSGPacket_t *MSGpkt;
   1852            afDataConfirm_t *afDataConfirm;
   1853            // Data Confirmation message fields
   1854            byte sentEP;
   1855            ZStatus_t sentStatus;
   1856            byte sentTransID;       // This should match the value sent
   1857            (void)task_id;  // Intentionally unreferenced parameter
   1858          
   1859            if ( events & SYS_EVENT_MSG )
   \   00000E   7480         MOV     A,#-0x80
   \   000010   5F           ANL     A,R7
   \   000011   F9           MOV     R1,A
   \   000012   E4           CLR     A
   \   000013   7001         JNZ     ??GenericApp_ProcessEvent_0
   \   000015   E9           MOV     A,R1
   \                     ??GenericApp_ProcessEvent_0:
   \   000016   7003         JNZ     $+5
   \   000018   02....       LJMP    ??GenericApp_ProcessEvent_1 & 0xFFFF
   1860            {
   1861              MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( GenericApp_TaskID );
   \   00001B                ; Setup parameters for call to function osal_msg_receive
   \   00001B   801F         SJMP    ??GenericApp_ProcessEvent_2
   1862              while ( MSGpkt )
   1863              { 
   1864                switch ( MSGpkt->hdr.event )
                       ^
Warning[Pe546]: transfer of control bypasses initialization of:
            variable "s" (declared at line 1908 of
                      "C:\Users\win7\Desktop\ZStack´«¸ÐÆ÷Í¸Ã÷´«ÊäÔ´³ÌÐòV2.45-13
                      (´ø»ØÂë2018-5-20)\Projects\GenericApp\Source\GenericApp.c
                      ")
   1865                {
   1866                  /*case ZDO_CB_MSG:
   1867                    GenericApp_ProcessZDOMsgs( (zdoIncomingMsg_t *)MSGpkt );
   1868                    break;*/
   1869                    
   1870                  case KEY_CHANGE:
   1871                    GenericApp_HandleKeys(((keyChange_t *)MSGpkt)->state, ((keyChange_t *)MSGpkt)->keys);
   \                     ??GenericApp_ProcessEvent_3:
   \   00001D                ; Setup parameters for call to function GenericApp_HandleKeys
   \   00001D   85..82       MOV     DPL,?V0 + 0
   \   000020   85..83       MOV     DPH,?V0 + 1
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   E0           MOVX    A,@DPTR
   \   000027   FA           MOV     R2,A
   \   000028   85..82       MOV     DPL,?V0 + 0
   \   00002B   85..83       MOV     DPH,?V0 + 1
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F9           MOV     R1,A
   \   000032   12....       LCALL   ??GenericApp_HandleKeys?relay
   1872          		  break; 
   1873          
   1874                  case AF_DATA_CONFIRM_CMD:
   1875                    // This message is received as a confirmation of a data packet sent.
   1876                    // The status is of ZStatus_t type [defined in ZComDef.h]
   1877                    // The message fields are defined in AF.h
   1878                    afDataConfirm = (afDataConfirm_t *)MSGpkt;
   1879                    sentEP = afDataConfirm->endpoint;
   1880                    sentStatus = afDataConfirm->hdr.status;
   1881                    sentTransID = afDataConfirm->transID;
   1882                    (void)sentEP;
   1883                    (void)sentTransID;
   1884          
   1885                    // Action taken when confirmation is received.
   1886                    if ( sentStatus != ZSuccess )
   1887                    {
   1888                      // The data wasn't delivered -- Do something
   1889                    }
   1890                    break;
   1891          
   1892                  case AF_INCOMING_MSG_CMD:
   1893                    GenericApp_MessageMSGCB( MSGpkt );
   1894                    break;
   1895          
   1896                  case ZDO_STATE_CHANGE:
   1897                    GenericApp_NwkState = (devStates_t)(MSGpkt->hdr.status);
   1898                    if ( (GenericApp_NwkState == DEV_ZB_COORD)
   1899                        /*|| (GenericApp_NwkState == DEV_ROUTER)
   1900                        || (GenericApp_NwkState == DEV_END_DEVICE)*/ )
   1901                    {
   1902                      // Start sending "the" message in a regular interval.
   1903                      osal_start_timerEx( GenericApp_TaskID, GENERICAPP_SEND_MSG_EVT,
   1904                                          GENERICAPP_SEND_MSG_TIMEOUT );
   1905                    }
   1906          ////////////////////////////////////////////////////////////////////////////////////////////
   1907          //OLEDÆÁÏÔÊ¾ÄÚÈÝ        
   1908          char *s=0;
   1909          uint16 nv_data; 
   1910          osal_nv_read(ZCD_NV_APP_PANID_H,0,sizeof(nv_data),&nv_data);
   1911          sprintf(s, "%04X", nv_data); 
   1912          OLED_P8x16Str(88,0,s);//µÚÒ»ÐÐ -- 8x16µÄÏÔÊ¾µ¥ÔªÏÔÊ¾ASCIIÂë
   1913          sprintf(s, "%04X", NLME_GetCoordShortAddr());  
   1914          OLED_P8x16Str(48,2,s);
   1915          sprintf(s, "%04X", NLME_GetShortAddr());  
   1916          OLED_P8x16Str(88,2,s); 
   1917           ////////////////////////////////////////////////////////////////////////////////////////////
   1918                    break;
   1919                  default:
   1920                    break;
   1921          }
   1922                // Release the memory
   1923                osal_msg_deallocate( (uint8 *)MSGpkt );
   \                     ??GenericApp_ProcessEvent_4:
   \   000035                ; Setup parameters for call to function osal_msg_deallocate
   \   000035   AA..         MOV     R2,?V0 + 0
   \   000037   AB..         MOV     R3,?V0 + 1
   \   000039   12....       LCALL   ??osal_msg_deallocate?relay
   1924                // Next
   1925                MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( GenericApp_TaskID );
   \   00003C                ; Setup parameters for call to function osal_msg_receive
   \                     ??GenericApp_ProcessEvent_2:
   \   00003C   90....       MOV     DPTR,#GenericApp_TaskID
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F9           MOV     R1,A
   \   000041   12....       LCALL   ??osal_msg_receive?relay
   \   000044   8A..         MOV     ?V0 + 0,R2
   \   000046   8B..         MOV     ?V0 + 1,R3
   \   000048   E5..         MOV     A,?V0 + 0
   \   00004A   7002         JNZ     ??GenericApp_ProcessEvent_5
   \   00004C   E5..         MOV     A,?V0 + 1
   \                     ??GenericApp_ProcessEvent_5:
   \   00004E   7003         JNZ     $+5
   \   000050   02....       LJMP    ??GenericApp_ProcessEvent_6 & 0xFFFF
   \   000053   85..82       MOV     DPL,?V0 + 0
   \   000056   85..83       MOV     DPH,?V0 + 1
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for GenericApp_ProcessEvent>_0`:
   \   00005D   00           DB        0
   \   00005E   04           DB        4
   \   00005F   1A           DB        26
   \   000060   ....         DW        ??GenericApp_ProcessEvent_7
   \   000062   C0           DB        192
   \   000063   ....         DW        ??GenericApp_ProcessEvent_3
   \   000065   D1           DB        209
   \   000066   ....         DW        ??GenericApp_ProcessEvent_8
   \   000068   FD           DB        253
   \   000069   ....         DW        ??GenericApp_ProcessEvent_4
   \   00006B   ....         DW        ??GenericApp_ProcessEvent_4
   \                     ??GenericApp_ProcessEvent_7:
   \   00006D                ; Setup parameters for call to function GenericApp_MessageMSGCB
   \   00006D   AA..         MOV     R2,?V0 + 0
   \   00006F   AB..         MOV     R3,?V0 + 1
   \   000071   12....       LCALL   ??GenericApp_MessageMSGCB?relay
   \   000074   80BF         SJMP    ??GenericApp_ProcessEvent_4
   \                     ??GenericApp_ProcessEvent_8:
   \   000076   85..82       MOV     DPL,?V0 + 0
   \   000079   85..83       MOV     DPH,?V0 + 1
   \   00007C   A3           INC     DPTR
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   90....       MOV     DPTR,#GenericApp_NwkState
   \   000081   F0           MOVX    @DPTR,A
   \   000082   6409         XRL     A,#0x9
   \   000084   7010         JNZ     ??GenericApp_ProcessEvent_9
   \   000086                ; Setup parameters for call to function osal_start_timerEx
   \   000086   7CF4         MOV     R4,#-0xc
   \   000088   7D01         MOV     R5,#0x1
   \   00008A   7A01         MOV     R2,#0x1
   \   00008C   7B00         MOV     R3,#0x0
   \   00008E   90....       MOV     DPTR,#GenericApp_TaskID
   \   000091   E0           MOVX    A,@DPTR
   \   000092   F9           MOV     R1,A
   \   000093   12....       LCALL   ??osal_start_timerEx?relay
   \                     ??GenericApp_ProcessEvent_9:
   \   000096                ; Setup parameters for call to function osal_nv_read
   \   000096   85..82       MOV     DPL,?XSP + 0
   \   000099   85..83       MOV     DPH,?XSP + 1
   \   00009C   8582..       MOV     ?V0 + 4,DPL
   \   00009F   8583..       MOV     ?V0 + 5,DPH
   \   0000A2   78..         MOV     R0,#?V0 + 4
   \   0000A4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A7   75..02       MOV     ?V0 + 4,#0x2
   \   0000AA   75..00       MOV     ?V0 + 5,#0x0
   \   0000AD   78..         MOV     R0,#?V0 + 4
   \   0000AF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B2   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   0000B5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B8                ; Setup parameters for call to function sprintf
   \   0000B8   85..82       MOV     DPL,?XSP + 0
   \   0000BB   85..83       MOV     DPH,?XSP + 1
   \   0000BE   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000C1   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   0000C4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C7                ; Setup parameters for call to function OLED_P8x16Str
   \   0000C7   7C00         MOV     R4,#0x0
   \   0000C9   7D00         MOV     R5,#0x0
   \   0000CB   7A00         MOV     R2,#0x0
   \   0000CD   7958         MOV     R1,#0x58
   \   0000CF   12....       LCALL   ??OLED_P8x16Str?relay
   \   0000D2                ; Setup parameters for call to function sprintf
   \   0000D2                ; Setup parameters for call to function NLME_GetCoordShortAddr
   \   0000D2   12....       LCALL   ??NLME_GetCoordShortAddr?relay
   \   0000D5   8A..         MOV     ?V0 + 4,R2
   \   0000D7   8B..         MOV     ?V0 + 5,R3
   \   0000D9   78..         MOV     R0,#?V0 + 4
   \   0000DB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000DE   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   0000E1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E4                ; Setup parameters for call to function OLED_P8x16Str
   \   0000E4   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   0000E7   8A..         MOV     ?V0 + 4,R2
   \   0000E9   8B..         MOV     ?V0 + 5,R3
   \   0000EB   78..         MOV     R0,#?V0 + 4
   \   0000ED   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F0   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   0000F3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F6                ; Setup parameters for call to function OLED_P8x16Str
   \   0000F6   7C00         MOV     R4,#0x0
   \   0000F8   7D00         MOV     R5,#0x0
   \   0000FA   7A02         MOV     R2,#0x2
   \   0000FC   7958         MOV     R1,#0x58
   \   0000FE   12....       LCALL   ??OLED_P8x16Str?relay
   \   000101   02....       LJMP    ??GenericApp_ProcessEvent_4 & 0xFFFF
   1926              }
   1927              // return unprocessed events
   1928              return (events ^ SYS_EVENT_MSG);
   \                     ??GenericApp_ProcessEvent_6:
   \   000104   EE           MOV     A,R6
   \   000105   FA           MOV     R2,A
   \   000106   7480         MOV     A,#-0x80
   \   000108   6F           XRL     A,R7
   \                     ??GenericApp_ProcessEvent_10:
   \   000109   FB           MOV     R3,A
   \   00010A   8020         SJMP    ??GenericApp_ProcessEvent_11
   1929            }
   1930            // Send a message out - This event is generated by a timer
   1931            // (setup in GenericApp_Init()).
   1932            if ( events & GENERICAPP_SEND_MSG_EVT )
   \                     ??GenericApp_ProcessEvent_1:
   \   00010C   EE           MOV     A,R6
   \   00010D   A2E0         MOV     C,0xE0 /* A   */.0
   \   00010F   5017         JNC     ??GenericApp_ProcessEvent_12
   1933            {
   1934              // Send "the" message
   1935            //  GenericApp_SendTheMessage();
   1936              // Setup to send message again
   1937             osal_start_timerEx( GenericApp_TaskID, GENERICAPP_SEND_MSG_EVT,
   1938                                 GENERICAPP_SEND_MSG_TIMEOUT );
   \   000111                ; Setup parameters for call to function osal_start_timerEx
   \   000111   7CF4         MOV     R4,#-0xc
   \   000113   7D01         MOV     R5,#0x1
   \   000115   7A01         MOV     R2,#0x1
   \   000117   7B00         MOV     R3,#0x0
   \   000119   90....       MOV     DPTR,#GenericApp_TaskID
   \   00011C   E0           MOVX    A,@DPTR
   \   00011D   F9           MOV     R1,A
   \   00011E   12....       LCALL   ??osal_start_timerEx?relay
   1939              // return unprocessed events
   1940              return (events ^ GENERICAPP_SEND_MSG_EVT);
   \   000121   7401         MOV     A,#0x1
   \   000123   6E           XRL     A,R6
   \   000124   FA           MOV     R2,A
   \   000125   EF           MOV     A,R7
   \   000126   80E1         SJMP    ??GenericApp_ProcessEvent_10
   1941            }
   1942            // Discard unknown events
   1943            return 0;
   \                     ??GenericApp_ProcessEvent_12:
   \   000128   7A00         MOV     R2,#0x0
   \   00012A   7B00         MOV     R3,#0x0
   \                     ??GenericApp_ProcessEvent_11:
   \   00012C   7402         MOV     A,#0x2
   \   00012E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000131   7F06         MOV     R7,#0x6
   \   000133   02....       LJMP    ?BANKED_LEAVE_XDATA
   1944          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   7C00         MOV     R4,#0x0
   \   000002   7D00         MOV     R5,#0x0
   \   000004   7A01         MOV     R2,#0x1
   \   000006                REQUIRE ??Subroutine29_0
   \   000006                ; // Fall through to label ??Subroutine29_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine29_0:
   \   000000   7B04         MOV     R3,#0x4
   \   000002   12....       LCALL   ??osal_nv_read?relay
   \   000005   7404         MOV     A,#0x4
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   7C..         MOV     R4,#(`?<Constant "%04X">` & 0xff)
   \   000002   7D..         MOV     R5,#((`?<Constant "%04X">` >> 8) & 0xff)
   \   000004                REQUIRE ??Subroutine30_0
   \   000004                ; // Fall through to label ??Subroutine30_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine30_0:
   \   000000   7A00         MOV     R2,#0x0
   \   000002   7B00         MOV     R3,#0x0
   \   000004   12....       LCALL   ??sprintf?relay
   \   000007   7402         MOV     A,#0x2
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   7C00         MOV     R4,#0x0
   \   000002   7D00         MOV     R5,#0x0
   \   000004   7A02         MOV     R2,#0x2
   \   000006   7930         MOV     R1,#0x30
   \   000008   12....       LCALL   ??OLED_P8x16Str?relay
   \   00000B                ; Setup parameters for call to function sprintf
   \   00000B                ; Setup parameters for call to function NLME_GetShortAddr
   \   00000B                ; Setup parameters for call to function sprintf
   \   00000B                ; Setup parameters for call to function NLME_GetShortAddr
   \   00000B                ; Setup parameters for call to function sprintf
   \   00000B                ; Setup parameters for call to function NLME_GetShortAddr
   \   00000B   12....       LCALL   ??NLME_GetShortAddr?relay
   \   00000E   22           RET
   1945          
   1946          /*********************************************************************
   1947           * Event Generation Functions
   1948           */
   1949          
   1950          /*********************************************************************
   1951           * @fn      GenericApp_ProcessZDOMsgs()
   1952           *
   1953           * @brief   Process response messages
   1954           *
   1955           * @param   none
   1956           *
   1957           * @return  none
   1958           *//*
   1959          void GenericApp_ProcessZDOMsgs( zdoIncomingMsg_t *inMsg )
   1960          {
   1961            switch ( inMsg->clusterID )
   1962            {
   1963              case End_Device_Bind_rsp:
   1964                if ( ZDO_ParseBindRsp( inMsg ) == ZSuccess )
   1965                {
   1966                  // Light LED
   1967                  HalLedSet( HAL_LED_2, HAL_LED_MODE_ON );
   1968                }
   1969          #if defined(BLINK_LEDS)
   1970                else
   1971                {
   1972                  // Flash LED to show failure
   1973                  HalLedSet ( HAL_LED_2, HAL_LED_MODE_FLASH );
   1974                }
   1975          #endif
   1976                break;
   1977          
   1978              case Match_Desc_rsp:
   1979                {
   1980                  ZDO_ActiveEndpointRsp_t *pRsp = ZDO_ParseEPListRsp( inMsg );
   1981                  if ( pRsp )
   1982                  {
   1983                    if ( pRsp->status == ZSuccess && pRsp->cnt )
   1984                    {
   1985                      GenericApp_DstAddr.addrMode = (afAddrMode_t)Addr16Bit;
   1986                      GenericApp_DstAddr.addr.shortAddr = pRsp->nwkAddr;
   1987                      // Take the first endpoint, Can be changed to search through endpoints
   1988                      GenericApp_DstAddr.endPoint = pRsp->epList[0];
   1989          
   1990                      // Light LED
   1991                      HalLedSet( HAL_LED_2, HAL_LED_MODE_ON );
   1992                    }
   1993                    osal_mem_free( pRsp );
   1994                  }
   1995                }
   1996                break;
   1997            }
   1998          }*/
   1999          
   2000          /*********************************************************************
   2001           * @fn      GenericApp_HandleKeys
   2002           *
   2003           * @brief   Handles all key events for this device.
   2004           *
   2005           * @param   shift - true if in shift/alt.
   2006           * @param   keys - bit field for key events. Valid entries:
   2007           *                 HAL_KEY_SW_2
   2008           *                 HAL_KEY_SW_1
   2009           *
   2010           * @return  none
   2011           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2012          void GenericApp_HandleKeys( byte shift, byte keys )
   \                     GenericApp_HandleKeys:
   2013          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   2014            zAddrType_t dstAddr;
   2015            // Shift is used to make each button/switch dual purpose.
   2016            if ( true )
   2017            {
   2018              if ( keys & HAL_KEY_SW_1 )
   \   00000C   EA           MOV     A,R2
   \   00000D   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000F   4003         JC      $+5
   \   000011   02....       LJMP    ??GenericApp_HandleKeys_0 & 0xFFFF
   2019              {
   2020          #if(SENSOR_TYPE =='O')
   2021                char hr[5]={0xCE,0x03,0xFC,0x00,0xDE};
   2022                hr[3]=0XCC;
   2023                HalUARTWrite(HAL_UART_PORT_0, (uint8*)hr,5);
   2024          #endif    
   2025          #if(SENSOR_TYPE =='G')
   2026          if(Coil_AB==0)Coil_AB=1;
   2027          else if(Coil_AB<5)Coil_AB=10;
   2028          else Coil_AB=0;
   2029          #endif 
   2030          #if(SENSOR_TYPE =='P')
   2031                uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   2032              GenericApp_applicationbuf=0;
   2033              GenericApp_SendTheMessage();
   2034               HalUARTWrite(HAL_UART_PORT_0,hr,8);//Ñ§Ï°
   2035          #endif
   2036          #if(SENSOR_TYPE ==0X25)
   2037                uint8  hr[10]={0XF7,0x08,0xAA,0X02,0X01,0X01,0X00,0X0B,0X0B,0X0B};
   2038               Send_datalend=2;
   2039              GenericApp_SendTheMessage();
   2040               HalUARTWrite(HAL_UART_PORT_0,hr,10);//Ñ§Ï°ºìÍâ
   2041          #endif
   2042          #if(SENSOR_TYPE ==0X7C)
   2043                uint8  hr[5]={0XF7,0x03,0xB1,0X52,0X00};
   2044               Send_datalend=2;
   2045              GenericApp_SendTheMessage();
   2046               HalUARTWrite(HAL_UART_PORT_0,hr,5);//¿ª¹Ø°ó¶¨Ä£Ê½ 
   2047          #endif
   2048          #if(SENSOR_TYPE ==0X7B)
   2049               Send_datalend=6;
   2050              GenericApp_SendTheMessage();
   2051          #endif
   2052          #if(SENSOR_TYPE ==0X71)
   2053                uint8  hr[6]={0XF7, 0X03,0XBB,0X65,0X40, 0X01,};
   2054               Send_datalend=2;
   2055              GenericApp_SendTheMessage();
   2056              HalUARTWrite(HAL_UART_PORT_0,&hr[5],1);halMcuWaitMs(100);
   2057              HalUARTWrite(HAL_UART_PORT_0,hr,5);
   2058          #endif
   2059          #if(SENSOR_TYPE ==0X70)
   2060                uint8  hr[11]={0XF7,0x09,0x01,0X01,0XC0,0X10,0X10,0X40,0X06,0X06,0X20};
   2061               Send_datalend=2;
   2062             GenericApp_SendTheMessage();
   2063               P1_0=1; 
   2064               GenericApp_uart_485=0;
   2065               HalUARTWrite(HAL_UART_PORT_0,hr,11);
   2066          #endif
   2067          #if(SENSOR_TYPE ==0X86)
   2068               // uint8  hr[9]={0XF7,0x07,0xBA,0X01,0X01,0XA0,0X00,0X00,0X00};
   2069               Send_datalend=2;
   2070               GenericApp_SendTheMessage();
   2071             //  HalUARTWrite(HAL_UART_PORT_0,hr,9);//ÖÇÄÜÓïÑÔ²¥±¨
   2072          #endif
   2073          #if(SENSOR_TYPE ==0X87)
   2074               // uint8  hr[9]={0XF7,0x07,0xBA,0X01,0X01,0XA0,0X00,0X00,0X00};
   2075               Send_datalend=2;
   2076               GenericApp_SendTheMessage();
   2077             //  HalUARTWrite(HAL_UART_PORT_0,hr,9);//ÖÇÄÜÓïÑÔ²¥±¨
   2078          #endif
   2079          #if(SENSOR_TYPE ==0X26)
   2080                uint8  hr[9]={0XF7,0x07,0xBA,0X01,0X01,0XA0,0X00,0X00,0X00};
   2081               Send_datalend=2;
   2082               GenericApp_SendTheMessage();
   2083               HalUARTWrite(HAL_UART_PORT_0,hr,9);//ÖÇÄÜÓïÑÔ²¥±¨
   2084          #endif
   2085           #if(SENSOR_TYPE ==0X27)
   2086                SYN_FrameInfo(0,1,"soundy",250) ;
   2087          #endif
   2088                
   2089          #if(SENSOR_TYPE ==0X28)
   2090                 LCD_Init();   // LCD³õÊ¼»¯
   2091            LCD_Clear();  // LCDÇåÆÁ
   2092            /* ÏÔÊ¾ÐÅÏ¢ */
   2093            LCD_WriteString(0,0,"WWW.fantaitech.com");
   2094                GenericApp_switch=0;
   2095                 GenericApp_SendTheMessage();
   2096          #endif
   2097            #if(SENSOR_TYPE ==0X6F)
   2098                SYN_FrameInfo(0,1,"soundy",250) ;
   2099                   lcd_txt_clr(); 
   2100                hzkdis_b(0,"  ÎÞÎý·ºÌ«¿Æ¼¼",14);
   2101                GenericApp_switch=0;
   2102                 GenericApp_SendTheMessage();
   2103          #endif
   2104          #if(SENSOR_TYPE ==0X6B)
   2105          #if defined(LED16X64)
   2106                uint8  hr[4]={0X02,0x33,0x01,0X00};
   2107               HalUARTWrite(HAL_UART_PORT_0,hr,4);
   2108          #endif
   2109              GenericApp_applicationbuf=0;
   2110              GenericApp_SendTheMessage();
   2111          #endif
   2112          #if((SENSOR_TYPE ==0X05)||(SENSOR_TYPE ==0X0A)||(SENSOR_TYPE ==0X0B)||\
   2113               (SENSOR_TYPE =='R')||(SENSOR_TYPE =='S')||(SENSOR_TYPE =='H')||(SENSOR_TYPE ==0X65)\
   2114                 ||(SENSOR_TYPE ==0X66)||(SENSOR_TYPE ==0X67)||(SENSOR_TYPE ==0X76))
   2115                 GenericApp_SendTheMessage();
   2116          #endif
   2117          #if(SENSOR_TYPE ==0X6E)
   2118                uint8 spt[2]={0,0};
   2119               SendDataS(spt,2);
   2120              GenericApp_SendTheMessage();
   2121          #endif
   2122          #if(SENSOR_TYPE ==0X6C)
   2123                   lcd_txt_clr(); 
   2124            hzkdis(2,tab0);
   2125                 GenericApp_SendTheMessage();
   2126          #endif
   2127          
   2128          #if(SENSOR_TYPE ==0X6D)
   2129              GenericApp_applicationbuf=0;
   2130              GenericApp_SendTheMessage();
   2131          #endif
   2132          #if(SENSOR_TYPE ==0XF0)
   2133              GenericApp_applicationbuf=0;
   2134              GenericApp_SendTheMessage();
   2135          #endif
   2136          #if(SENSOR_TYPE ==0X30)
   2137                 if(a68!=0Xba){a68=0xba;b68=B01;c68=150;}
   2138                 else {a68=0xab;b68=B01;c68=0;}
   2139                 GenericApp_SendTheMessage();
   2140          #endif
   2141          #if(SENSOR_TYPE ==0X73)
   2142              if(a68!=0Xba){a68=0xba;b68=5000;}
   2143                 else {a68=0xab;b68=5000;}
   2144              Send_data[10]=0X00;
   2145              uint8 data8[6]={0X05,0XA8,0X01,0XA0,0X10,0X00};
   2146               if(A8n<8)A8n++;
   2147                else A8n=1;
   2148              data8[2]=A8n;
   2149                  HalUARTWrite(HAL_UART_PORT_0, data8,0X06);
   2150                 GenericApp_SendTheMessage();
   2151          #endif
   2152          #if(SENSOR_TYPE ==0X23)
   2153             
   2154              if(SFG_R30X)
   2155              {SFG_R30XA[0]=0X00;SFG_R30X=0;}
   2156              else
   2157              { SFG_R30XA[0]=0XA1;SFG_R30X=1;}
   2158              
   2159               GenericApp_applicationbuf=0;
   2160               GenericApp_SendTheMessage();
   2161          #endif
   2162          #if(SENSOR_TYPE ==0X20)
   2163                 GenericApp_ON_OFF=10;
   2164          #endif
   2165          #if(SENSOR_TYPE ==0X77)
   2166                GenericApp_appIO=0x00;
   2167                 GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   2168          #endif
   2169          #if((SENSOR_TYPE =='I')||(SENSOR_TYPE ==0X64))
   2170                GenericApp_appIO=0x01;
   2171          #endif
   2172          #if((SENSOR_TYPE =='E')||(SENSOR_TYPE =='B')||(SENSOR_TYPE =='C')||(SENSOR_TYPE =='D')\
   2173            ||(SENSOR_TYPE =='F')||(SENSOR_TYPE =='U')||(SENSOR_TYPE ==0X10)||(SENSOR_TYPE ==0X21)\
   2174              ||(SENSOR_TYPE ==0X11)||(SENSOR_TYPE ==0X1A)||(SENSOR_TYPE ==0X0F)||(SENSOR_TYPE ==0X13)||(SENSOR_TYPE ==0X14)\
   2175                ||(SENSOR_TYPE ==0X17)||(SENSOR_TYPE ==0X24)||(SENSOR_TYPE ==0X6A)||(SENSOR_TYPE =='A')\
   2176                  ||(SENSOR_TYPE =='J')||(SENSOR_TYPE =='L')||(SENSOR_TYPE =='M')\
   2177            ||(SENSOR_TYPE =='N')||(SENSOR_TYPE ==0X04)||(SENSOR_TYPE ==0X22)||(SENSOR_TYPE ==0X0C)\
   2178              ||(SENSOR_TYPE ==0X16)||(SENSOR_TYPE ==0X17)||(SENSOR_TYPE ==0X61)||(SENSOR_TYPE ==0X62)\
   2179                ||(SENSOR_TYPE ==0X19)||(SENSOR_TYPE ==0X5A)||(SENSOR_TYPE ==0X5B)||(SENSOR_TYPE ==0X63)||(SENSOR_TYPE ==0X33)||(SENSOR_TYPE ==0X72)\
   2180                   ||(SENSOR_TYPE ==0X34)||(SENSOR_TYPE ==0X35)||(SENSOR_TYPE ==0X36)||(SENSOR_TYPE ==0X37)||(SENSOR_TYPE ==0X38)\
   2181                     ||(SENSOR_TYPE ==0X39)||(SENSOR_TYPE ==0X3A)||(SENSOR_TYPE ==0X80)||(SENSOR_TYPE ==0X3D)||(SENSOR_TYPE ==0X81)\
   2182                       ||(SENSOR_TYPE ==0X82)||(SENSOR_TYPE ==0X3B)||(SENSOR_TYPE ==0X3C)||(SENSOR_TYPE ==0X3E)||(SENSOR_TYPE ==0X3F)\
   2183                         ||(SENSOR_TYPE ==0X74)||(SENSOR_TYPE ==0X84)||(SENSOR_TYPE ==0X85)||(SENSOR_TYPE ==0X75)||(SENSOR_TYPE ==0X78))
   2184                GenericApp_applicationbuf=60001; //µ¥´Î·¢ËÍ ²»¸Ä±ä¶¨Ê±×´Ì¬
   2185               //  GenericApp_time=0;
   2186                // TIMER3_RUN(FALSE);  //¹Ø±Õ¶¨Ê±
   2187          if(!(T_MGSbit&(0XC0)))  //1100 0000 ÅÐ¶ÏÊÇ·ñÎª ¹Ø±Õ¶¨Ê±×´Ì¬
   2188          {
   2189                GenericApp_time=0;
   2190                 TIMER3_RUN(FALSE);  //¹Ø±Õ¶¨Ê±
   2191          }
   2192          #endif
   2193          #if(SENSOR_TYPE ==0X79)
   2194                    P1_5=~P1_5;
   2195                    Send_data[7]=0X02;
   2196                    Send_data[8]=0XDD;
   2197                    Send_data[9]=P1_5;
   2198                    Send_data[9]=~((((Send_data[9]<<1)+P1_0)&0X03)|0XFC);
   2199                    Send_datalend=0x04;
   2200                    GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   2201          #endif  
   2202          #if(SENSOR_TYPE ==0X83)
   2203                 P1_1=~P1_1;
   2204                GenericApp_applicationbuf=0;
   2205                GenericApp_SendTheMessage();
   2206          #endif  
   2207          #if((SENSOR_TYPE =='K')||(SENSOR_TYPE ==0X02)||(SENSOR_TYPE ==0X06)||(SENSOR_TYPE ==0X40)\
   2208            ||(SENSOR_TYPE ==0X09)||(SENSOR_TYPE ==0X12)||(SENSOR_TYPE ==0X18)||(SENSOR_TYPE ==0X15)\
   2209              ||(SENSOR_TYPE ==0X29)||(SENSOR_TYPE ==0X31)||(SENSOR_TYPE ==0XA3))
   2210              //  P1_1=~P1_1;
   2211                GenericApp_applicationbuf=0;
   2212                GenericApp_SendTheMessage();
   2213          #endif
   2214           ////////////////////////////////////////////////////////////////////////////////////////////
   2215          //OLEDÆÁÏÔÊ¾ÄÚÈÝ
   2216          OLED_Init(); //OLED³õÊ¼»¯ 
   \   000014                ; Setup parameters for call to function OLED_Init
   \   000014   12....       LCALL   ?Subroutine17 & 0xFFFF
   2217          OLED_P8x16Str(0,0,"R       ID:");//µÚÒ»ÐÐ -- 8x16µÄÏÔÊ¾µ¥ÔªÏÔÊ¾ASCIIÂë
   2218          #if defined( SENSOR_TYPE_Coord )
   2219          #if (ZDO_COORDINATOR)
   2220             OLED_P8x16Str(0,0,"C    PANID:");//µÚÒ»ÐÐ -- 8x16µÄÏÔÊ¾µ¥ÔªÏÔÊ¾ASCIIÂë
   2221          #endif 
   2222          #endif 
   2223          #if defined( POWER_SAVING )
   2224           OLED_P8x16Str(0,0,"E       ID:");//µÚÒ»ÐÐ -- 8x16µÄÏÔÊ¾µ¥ÔªÏÔÊ¾ASCIIÂë
   2225          #endif
   2226          char *s=0;
   2227          uint16 nv_data; 
   2228          osal_nv_read(ZCD_NV_APP_CHANLIST,0,sizeof(nv_data),&nv_data);
   \                     ??CrossCallReturnLabel_23:
   \   000017   8582..       MOV     ?V0 + 10,DPL
   \   00001A   8583..       MOV     ?V0 + 11,DPH
   \   00001D   78..         MOV     R0,#?V0 + 10
   \   00001F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000022   75..02       MOV     ?V0 + 10,#0x2
   \   000025   75..00       MOV     ?V0 + 11,#0x0
   \   000028   78..         MOV     R0,#?V0 + 10
   \   00002A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002D   7C00         MOV     R4,#0x0
   \   00002F   7D00         MOV     R5,#0x0
   \   000031   7A0F         MOV     R2,#0xf
   \   000033   12....       LCALL   ??Subroutine29_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000036   12....       LCALL   ?DEALLOC_XSTACK8
   2229          sprintf(s, "%02d", (nv_data&0x00ff)); 
   \   000039                ; Setup parameters for call to function sprintf
   \   000039   85..82       MOV     DPL,?XSP + 0
   \   00003C   85..83       MOV     DPH,?XSP + 1
   \   00003F   12....       LCALL   ??Subroutine40_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   000042   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000045   7C..         MOV     R4,#(`?<Constant "%02d">` & 0xff)
   \   000047   7D..         MOV     R5,#((`?<Constant "%02d">` >> 8) & 0xff)
   \   000049   12....       LCALL   ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   00004C   12....       LCALL   ?DEALLOC_XSTACK8
   2230          OLED_P8x16Str(16,0,s);//µÚÒ»ÐÐ -- 8x16µÄÏÔÊ¾µ¥ÔªÏÔÊ¾ASCIIÂë
   \   00004F                ; Setup parameters for call to function OLED_P8x16Str
   \   00004F   12....       LCALL   ?Subroutine23 & 0xFFFF
   2231          #if !defined( SENSOR_TYPE_Coord )
   2232          sprintf(s, "%02X", SENSOR_TYPE); 
   2233          OLED_P8x16Str(40,0,s);//µÚÒ»ÐÐ -- 8x16µÄÏÔÊ¾µ¥ÔªÏÔÊ¾ASCIIÂë
   2234          #endif 
   2235          osal_nv_read(ZCD_NV_APP_PANID_H,0,sizeof(nv_data),&nv_data);
   \                     ??CrossCallReturnLabel_34:
   \   000052   8582..       MOV     ?V0 + 10,DPL
   \   000055   8583..       MOV     ?V0 + 11,DPH
   \   000058   78..         MOV     R0,#?V0 + 10
   \   00005A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005D   75..02       MOV     ?V0 + 10,#0x2
   \   000060   75..00       MOV     ?V0 + 11,#0x0
   \   000063   78..         MOV     R0,#?V0 + 10
   \   000065   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000068   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   00006B   12....       LCALL   ?DEALLOC_XSTACK8
   2236          sprintf(s, "%04X", nv_data); 
   \   00006E                ; Setup parameters for call to function sprintf
   \   00006E   85..82       MOV     DPL,?XSP + 0
   \   000071   85..83       MOV     DPH,?XSP + 1
   \   000074   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000077   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   00007A   12....       LCALL   ?DEALLOC_XSTACK8
   2237          OLED_P8x16Str(88,0,s);//µÚÒ»ÐÐ -- 8x16µÄÏÔÊ¾µ¥ÔªÏÔÊ¾ASCIIÂë
   \   00007D                ; Setup parameters for call to function OLED_P8x16Str
   \   00007D   12....       LCALL   ?Subroutine18 & 0xFFFF
   2238          OLED_P8x16Str(0,2,"V2.45");
   2239          #if defined( CC2530_V30 )
   2240          OLED_P8x16Str(0,2,"V3.00");
   2241          #endif
   2242          sprintf(s, "%04X", NLME_GetCoordShortAddr()); 
   \                     ??CrossCallReturnLabel_25:
   \   000080   8A..         MOV     ?V0 + 10,R2
   \   000082   8B..         MOV     ?V0 + 11,R3
   \   000084   78..         MOV     R0,#?V0 + 10
   \   000086   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000089   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   00008C   12....       LCALL   ?DEALLOC_XSTACK8
   2243          OLED_P8x16Str(48,2,s);
   \   00008F                ; Setup parameters for call to function OLED_P8x16Str
   \   00008F   12....       LCALL   ?Subroutine21 & 0xFFFF
   2244          sprintf(s, "%04X", NLME_GetShortAddr());
   \                     ??CrossCallReturnLabel_30:
   \   000092   8A..         MOV     ?V0 + 10,R2
   \   000094   8B..         MOV     ?V0 + 11,R3
   \   000096   78..         MOV     R0,#?V0 + 10
   \   000098   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009B   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   00009E   12....       LCALL   ?DEALLOC_XSTACK8
   2245          OLED_P8x16Str(88,2,s);
   \   0000A1                ; Setup parameters for call to function OLED_P8x16Str
   \   0000A1   12....       LCALL   ?Subroutine19 & 0xFFFF
   2246           byte * Send_d;
   2247            Send_d=NLME_GetExtAddr();
   2248          sprintf(s, "%02X%02X%02X%02X%02X%02X%02X%02X", *Send_d,*(Send_d+1),*(Send_d+2),*(Send_d+3),*(Send_d+4),*(Send_d+5),*(Send_d+6),*(Send_d+7));
   \                     ??CrossCallReturnLabel_27:
   \   0000A4   F5..         MOV     ?V0 + 10,A
   \   0000A6   75..00       MOV     ?V0 + 11,#0x0
   \   0000A9   78..         MOV     R0,#?V0 + 10
   \   0000AB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AE   8A82         MOV     DPL,R2
   \   0000B0   8B83         MOV     DPH,R3
   \   0000B2   A3           INC     DPTR
   \   0000B3   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   0000B6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B9   8A82         MOV     DPL,R2
   \   0000BB   8B83         MOV     DPH,R3
   \   0000BD   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   0000C0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C3   8A82         MOV     DPL,R2
   \   0000C5   8B83         MOV     DPH,R3
   \   0000C7   12....       LCALL   ??Subroutine36_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   0000CA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000CD   8A82         MOV     DPL,R2
   \   0000CF   8B83         MOV     DPH,R3
   \   0000D1   12....       LCALL   ??Subroutine37_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   0000D4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000D7   8A82         MOV     DPL,R2
   \   0000D9   8B83         MOV     DPH,R3
   \   0000DB   12....       LCALL   ??Subroutine38_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   0000DE   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000E1   8A82         MOV     DPL,R2
   \   0000E3   8B83         MOV     DPH,R3
   \   0000E5   12....       LCALL   ??Subroutine39_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   0000E8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000EB   8A82         MOV     DPL,R2
   \   0000ED   8B83         MOV     DPH,R3
   \   0000EF   12....       LCALL   ??Subroutine40_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   0000F2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F5   7C..         MOV     R4,#(`?<Constant "%02X%02X%02X%02X%02X%...">` & 0xff)
   \   0000F7   7D..         MOV     R5,#((`?<Constant "%02X%02X%02X%02X%02X%...">` >> 8) & 0xff)
   \   0000F9   7A00         MOV     R2,#0x0
   \   0000FB   7B00         MOV     R3,#0x0
   \   0000FD   12....       LCALL   ??sprintf?relay
   \   000100   7410         MOV     A,#0x10
   \   000102   12....       LCALL   ?DEALLOC_XSTACK8
   2249          OLED_P8x16Str(0,4,s);
   \   000105                ; Setup parameters for call to function OLED_P8x16Str
   \   000105   7C00         MOV     R4,#0x0
   \   000107   7D00         MOV     R5,#0x0
   \   000109   7A04         MOV     R2,#0x4
   \   00010B   7900         MOV     R1,#0x0
   \   00010D   12....       LCALL   ??OLED_P8x16Str?relay
   2250           /////////////////////////////////////////////////////////////////////////////////   
   2251          
   2252          #if !defined (SENSOR_TYPE_Coord)
   2253          #if((SENSOR_TYPE =='K')||(SENSOR_TYPE ==0X28))
   2254          ZigBee_C_R_E_Engineering_E();
   2255          #endif
   2256          #endif
   2257            }
   2258              if ( keys & HAL_KEY_SW_2 )
   \                     ??GenericApp_HandleKeys_0:
   \   000110   E5..         MOV     A,?V0 + 0
   \   000112   A2E1         MOV     C,0xE0 /* A   */.1
   \   000114   4003         JC      $+5
   \   000116   02....       LJMP    ??GenericApp_HandleKeys_1 & 0xFFFF
   2259              {
   2260          #if(SENSOR_TYPE =='O')
   2261                char hr[5]={0xCE,0x03,0xFC,0x00,0xDE};
   2262                hr[3]=0XAA;
   2263                HalUARTWrite(HAL_UART_PORT_0, (uint8*)hr,5);
   2264                GenericApp_SendTheMessage();
   2265          #endif 
   2266          #if(SENSOR_TYPE =='G')
   2267          if(Coil_AB==0)Coil_AB=1;
   2268          else if(Coil_AB<5)Coil_AB=10;
   2269          else Coil_AB=0;
   2270          #endif 
   2271          #if((SENSOR_TYPE ==0X03)||(SENSOR_TYPE ==0X17))
   2272               GenericApp_SendTheMessage();
   2273          #endif 
   2274          #if(SENSOR_TYPE ==0X07)
   2275           //    if(AB==0X0A)AB=0X0B;
   2276           //    else AB=0X0A;
   2277               Send_datalend=0X04;
   2278          GenericApp_SendTheMessage();
   2279          #endif 
   2280          #if(SENSOR_TYPE ==0X08)
   2281               if(GenericApp_BX)
   2282              { GenericApp_BX=0; 
   2283              Send_data[7]=0xA1;//¶Á¿¨  15693
   2284               //printf("010C00030410002101020000\n"); //ÉèÖÃ 15693¿¨
   2285              GenericApp_appIO=0;
   2286              }
   2287              else
   2288              {GenericApp_BX=1;
   2289               Send_data[7]=0xA2; //¶Á¿¨ 14443A
   2290             // printf("010C00030410002101020000\n"); //ÉèÖÃ 15693¿¨
   2291               GenericApp_appIO=0;
   2292              }
   2293          #endif 
   2294          #if(SENSOR_TYPE ==0X0D)
   2295          #if defined(TGRD15693) 
   2296               if(GenericApp_BX)
   2297              { GenericApp_BX=0; 
   2298              Send_data[7]=0xA1;//¶Á¿¨  15693
   2299               //printf("010C00030410002101020000\n"); //ÉèÖÃ 15693¿¨
   2300              GenericApp_appIO=0;
   2301              }
   2302              else
   2303              {GenericApp_BX=1;
   2304               Send_data[7]=0xA2; //¶Á¿¨ 14443A
   2305             // printf("010C00030410002101020000\n"); //ÉèÖÃ 15693¿¨
   2306               GenericApp_appIO=0;
   2307              }
   2308          #endif 
   2309          #if defined(PN532) 
   2310             
   2311          #endif 
   2312          #endif 
   2313          #if((SENSOR_TYPE =='R')||(SENSOR_TYPE =='S')||(SENSOR_TYPE =='H')||(SENSOR_TYPE ==0X65)||(SENSOR_TYPE ==0X66)||\
   2314            (SENSOR_TYPE ==0X67)||(SENSOR_TYPE ==0X05)||(SENSOR_TYPE ==0X0A)||(SENSOR_TYPE ==0X0B)\
   2315             ||(SENSOR_TYPE ==0X76) )
   2316                GenericApp_SendTheMessage();
   2317          #endif
   2318          #if(SENSOR_TYPE ==0X6E)
   2319                uint8 spt[2]={0XFF,0XFF};
   2320               SendDataS(spt,2);
   2321              GenericApp_SendTheMessage();
   2322          #endif
   2323          #if(SENSOR_TYPE ==0X6C)
   2324                  lcd_txt_clr(); 
   2325            hzkdis(1,tab0);
   2326                 GenericApp_SendTheMessage();
   2327          #endif
   2328          
   2329          #if(SENSOR_TYPE ==0X6D)
   2330              GenericApp_applicationbuf=0;
   2331              GenericApp_SendTheMessage();
   2332          #endif
   2333          #if(SENSOR_TYPE ==0XF0)
   2334              GenericApp_applicationbuf=0;
   2335              GenericApp_SendTheMessage();
   2336          #endif
   2337          #if(SENSOR_TYPE =='P')
   2338                uint8  hrx[8]={0X01,0x03,0x06,0X81,0X00,0X8a,0X0D,0X0A};
   2339               GenericApp_applicationbuf=0;
   2340                 GenericApp_SendTheMessage();
   2341                HalUARTWrite(HAL_UART_PORT_0,hrx,8);//·¢ËÍ
   2342                // GenericApp_SendTheMessage();
   2343          #endif 
   2344          #if(SENSOR_TYPE ==0X25)
   2345              Send_datalend=2;
   2346              GenericApp_SendTheMessage();
   2347          #endif 
   2348          #if(SENSOR_TYPE ==0X7C)
   2349              Send_datalend=2;
   2350              GenericApp_SendTheMessage();
   2351          #endif 
   2352          #if(SENSOR_TYPE ==0X7B)
   2353              Send_datalend=6;
   2354              GenericApp_SendTheMessage();
   2355          #endif 
   2356          #if(SENSOR_TYPE ==0X71)
   2357              uint8  hr[6]={0XF7, 0X03,0XBB,0X65,0X60, 0X01,};
   2358              Send_datalend=2;
   2359                HalUARTWrite(HAL_UART_PORT_0,hr,5);
   2360              GenericApp_SendTheMessage();
   2361          #endif 
   2362          #if(SENSOR_TYPE ==0X70)
   2363                uint8  hr[11]={0XF7,0x09,0x01,0X01,0XA0,0X10,0X10,0X40,0X06,0X06,0X20};
   2364               Send_datalend=2;
   2365              GenericApp_SendTheMessage();
   2366               P1_0=1; 
   2367               GenericApp_uart_485=0;
   2368               HalUARTWrite(HAL_UART_PORT_0,hr,11);
   2369          #endif 
   2370          #if(SENSOR_TYPE ==0X73)
   2371               if(a68!=0Xba){a68=0xba;b68=5000;}
   2372                 else {a68=0xab;b68=5000;}
   2373               Send_data[10]=0X00;
   2374                uint8 data8[6]={0X05,0XA8,0X01,0XA0,0X10,0X00};
   2375               if(A8n>1)A8n--;
   2376                else A8n=8;
   2377              data8[2]=A8n;
   2378                  HalUARTWrite(HAL_UART_PORT_0, data8,0X06);
   2379                 GenericApp_SendTheMessage();
   2380          #endif
   2381           #if(SENSOR_TYPE ==0X86)
   2382              Send_datalend=2;
   2383              GenericApp_SendTheMessage();
   2384          #endif 
   2385          #if(SENSOR_TYPE ==0X87)
   2386              Send_datalend=2;
   2387              GenericApp_SendTheMessage();
   2388          #endif 
   2389          #if(SENSOR_TYPE ==0X26)
   2390              Send_datalend=2;
   2391              GenericApp_SendTheMessage();
   2392          #endif 
   2393          #if(SENSOR_TYPE ==0X27)
   2394               SYN_FrameInfo(0,1,"soundy",250) ;
   2395              
   2396          #endif 
   2397               
   2398          #if(SENSOR_TYPE ==0X28)
   2399                LCD_Init();   // LCD³õÊ¼»¯
   2400            LCD_Clear();  // LCDÇåÆÁ
   2401            /* ÏÔÊ¾ÐÅÏ¢ */
   2402            LCD_WriteString(0,2,"   WUXIFANTAIKEJI");
   2403                  GenericApp_switch=0;
   2404                 GenericApp_SendTheMessage();
   2405          #endif
   2406          
   2407          #if(SENSOR_TYPE ==0X6F)
   2408                SYN_FrameInfo(0,1,"soundy",250) ;
   2409                 // lcd_txt_clr(); 
   2410                hzkdis_b(1,"  ¹«½»¹ÜÀíÏµÍ³",14);
   2411                  GenericApp_switch=0;
   2412                 GenericApp_SendTheMessage();
   2413          #endif
   2414          #if(SENSOR_TYPE ==0X6B)
   2415          #if defined(LED16X64)
   2416                uint8  hr[4]={0X02,0x33,0x02,0X00};
   2417               HalUARTWrite(HAL_UART_PORT_0,hr,4);
   2418          #endif
   2419               GenericApp_applicationbuf=0;
   2420                 GenericApp_SendTheMessage();
   2421          #endif 
   2422          #if(SENSOR_TYPE ==0X77)
   2423                GenericApp_appIO=0x00;
   2424                 GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   2425          #endif
   2426          #if((SENSOR_TYPE =='I')||(SENSOR_TYPE ==0X64))
   2427                GenericApp_appIO=0x02;
   2428          #endif
   2429          #if((SENSOR_TYPE =='E')||(SENSOR_TYPE =='B')||(SENSOR_TYPE =='C')||(SENSOR_TYPE =='D')\
   2430            ||(SENSOR_TYPE =='F')||(SENSOR_TYPE =='U')||(SENSOR_TYPE ==0X10)||(SENSOR_TYPE ==0X21)\
   2431              ||(SENSOR_TYPE ==0X11)||(SENSOR_TYPE ==0X1A)||(SENSOR_TYPE ==0X0F)||(SENSOR_TYPE ==0X13)||(SENSOR_TYPE ==0X14)\
   2432                ||(SENSOR_TYPE ==0X24)||(SENSOR_TYPE ==0X6A)||(SENSOR_TYPE =='A')||(SENSOR_TYPE =='J')||\
   2433                  (SENSOR_TYPE =='L')||(SENSOR_TYPE =='M')||(SENSOR_TYPE ==0X33)\
   2434            ||(SENSOR_TYPE =='N')||(SENSOR_TYPE ==0X04)||(SENSOR_TYPE ==0X22)||(SENSOR_TYPE ==0X0C)\
   2435              ||(SENSOR_TYPE ==0X16)||(SENSOR_TYPE ==0X19)||(SENSOR_TYPE ==0X61)||(SENSOR_TYPE ==0X62)||(SENSOR_TYPE ==0X63)\
   2436                ||(SENSOR_TYPE ==0X5A)||(SENSOR_TYPE ==0X5B)||(SENSOR_TYPE ==0X72) ||(SENSOR_TYPE ==0X34)||(SENSOR_TYPE ==0X35)||(SENSOR_TYPE ==0X36)\
   2437                  ||(SENSOR_TYPE ==0X37)||(SENSOR_TYPE ==0X38)||(SENSOR_TYPE ==0X39)||(SENSOR_TYPE ==0X3A)||(SENSOR_TYPE ==0X80)\
   2438                    ||(SENSOR_TYPE ==0X3D)||(SENSOR_TYPE ==0X81)||(SENSOR_TYPE ==0X82)||(SENSOR_TYPE ==0X3B)||(SENSOR_TYPE ==0X3C)\
   2439                      ||(SENSOR_TYPE ==0X3E)||(SENSOR_TYPE ==0X3F)||(SENSOR_TYPE ==0X74)||(SENSOR_TYPE ==0X84)||(SENSOR_TYPE ==0X85)\
   2440                       ||(SENSOR_TYPE ==0X75)||(SENSOR_TYPE ==0X78) )
   2441                GenericApp_applicationbuf=60001;
   2442          if(!(T_MGSbit&(0XC0)))  //1100 0000 ÅÐ¶ÏÊÇ·ñÎª ¹Ø±Õ¶¨Ê±×´Ì¬
   2443          {
   2444                GenericApp_time=1;
   2445          #if defined( POWER_SAVING )
   2446                GenericApp_time=25;
   2447          #endif
   2448          }
   2449          #endif
   2450          #if(SENSOR_TYPE ==0X23)
   2451               if(SFG_R30X)
   2452              {SFG_R30XA[0]=0X00;SFG_R30X=0;}
   2453              else
   2454              { SFG_R30XA[0]=0XA1;SFG_R30X=1;}
   2455              
   2456              GenericApp_applicationbuf=0;
   2457             GenericApp_SendTheMessage();
   2458          #endif
   2459          #if(SENSOR_TYPE ==0X20)
   2460                 GenericApp_ON_OFF=10;
   2461          #endif
   2462          #if(SENSOR_TYPE ==0X79)
   2463                 P1_0=~P1_0; //P1_5=~P1_5;
   2464                Send_data[7]=0X02;
   2465                    Send_data[8]=0XDD;
   2466                    Send_data[9]=P1_5;
   2467                     Send_data[9]=~((((Send_data[9]<<1)+P1_0)&0X03)|0XFC);
   2468                    Send_datalend=0x04;
   2469                    GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   2470          #endif  
   2471          #if(SENSOR_TYPE ==0X83)
   2472                P1_2=~P1_2; //P1_0=~P1_0;
   2473                GenericApp_applicationbuf=0;
   2474                GenericApp_SendTheMessage();
   2475          #endif  
   2476          #if((SENSOR_TYPE =='K')||(SENSOR_TYPE ==0X02)||(SENSOR_TYPE ==0X06)||(SENSOR_TYPE ==0X40)||\
   2477            (SENSOR_TYPE ==0X09)||(SENSOR_TYPE ==0X12)||(SENSOR_TYPE ==0X18)||(SENSOR_TYPE ==0X15)\
   2478               ||(SENSOR_TYPE ==0X29)||(SENSOR_TYPE ==0X31)||(SENSOR_TYPE ==0XA3))
   2479               // P1_2=~P1_2; //P1_0=~P1_0;
   2480                GenericApp_applicationbuf=0;
   2481                GenericApp_SendTheMessage();
   2482          #endif
   2483          ////////////////////////////////////////////////////////////////////////////////////////////
   2484          //OLEDÆÁÏÔÊ¾ÄÚÈÝ
   2485          OLED_Init(); //OLED³õÊ¼»¯ 
   \   000119                ; Setup parameters for call to function OLED_Init
   \   000119   12....       LCALL   ?Subroutine17 & 0xFFFF
   2486          OLED_P8x16Str(0,0,"R       ID:");//µÚÒ»ÐÐ -- 8x16µÄÏÔÊ¾µ¥ÔªÏÔÊ¾ASCIIÂë
   2487          #if defined( SENSOR_TYPE_Coord )
   2488          #if (ZDO_COORDINATOR)
   2489             OLED_P8x16Str(0,0,"C    PANID:");//µÚÒ»ÐÐ -- 8x16µÄÏÔÊ¾µ¥ÔªÏÔÊ¾ASCIIÂë
   2490          #endif 
   2491          #endif 
   2492          #if defined( POWER_SAVING )
   2493           OLED_P8x16Str(0,0,"E       ID:");//µÚÒ»ÐÐ -- 8x16µÄÏÔÊ¾µ¥ÔªÏÔÊ¾ASCIIÂë
   2494          #endif
   2495          char *s=0;
   2496          uint16 nv_data; 
   2497          osal_nv_read(ZCD_NV_APP_CHANLIST,0,sizeof(nv_data),&nv_data);
   \                     ??CrossCallReturnLabel_24:
   \   00011C   8582..       MOV     ?V0 + 2,DPL
   \   00011F   8583..       MOV     ?V0 + 3,DPH
   \   000122   78..         MOV     R0,#?V0 + 2
   \   000124   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000127   75..02       MOV     ?V0 + 2,#0x2
   \   00012A   75..00       MOV     ?V0 + 3,#0x0
   \   00012D   78..         MOV     R0,#?V0 + 2
   \   00012F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000132   7C00         MOV     R4,#0x0
   \   000134   7D00         MOV     R5,#0x0
   \   000136   7A0F         MOV     R2,#0xf
   \   000138   12....       LCALL   ??Subroutine29_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   00013B   12....       LCALL   ?DEALLOC_XSTACK8
   2498          sprintf(s, "%02d", (nv_data&0x00ff)); 
   \   00013E                ; Setup parameters for call to function sprintf
   \   00013E   85..82       MOV     DPL,?XSP + 0
   \   000141   85..83       MOV     DPH,?XSP + 1
   \   000144   12....       LCALL   ??Subroutine35_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000147   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00014A   7C..         MOV     R4,#(`?<Constant "%02d">` & 0xff)
   \   00014C   7D..         MOV     R5,#((`?<Constant "%02d">` >> 8) & 0xff)
   \   00014E   12....       LCALL   ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000151   12....       LCALL   ?DEALLOC_XSTACK8
   2499          OLED_P8x16Str(16,0,s);//µÚÒ»ÐÐ -- 8x16µÄÏÔÊ¾µ¥ÔªÏÔÊ¾ASCIIÂë
   \   000154                ; Setup parameters for call to function OLED_P8x16Str
   \   000154   12....       LCALL   ?Subroutine23 & 0xFFFF
   2500          #if !defined( SENSOR_TYPE_Coord )
   2501          sprintf(s, "%02X", SENSOR_TYPE); 
   2502          OLED_P8x16Str(40,0,s);//µÚÒ»ÐÐ -- 8x16µÄÏÔÊ¾µ¥ÔªÏÔÊ¾ASCIIÂë
   2503          #endif 
   2504          osal_nv_read(ZCD_NV_APP_PANID_H,0,sizeof(nv_data),&nv_data);
   \                     ??CrossCallReturnLabel_35:
   \   000157   8582..       MOV     ?V0 + 2,DPL
   \   00015A   8583..       MOV     ?V0 + 3,DPH
   \   00015D   78..         MOV     R0,#?V0 + 2
   \   00015F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000162   75..02       MOV     ?V0 + 2,#0x2
   \   000165   75..00       MOV     ?V0 + 3,#0x0
   \   000168   78..         MOV     R0,#?V0 + 2
   \   00016A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00016D   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   000170   12....       LCALL   ?DEALLOC_XSTACK8
   2505          sprintf(s, "%04X", nv_data); 
   \   000173                ; Setup parameters for call to function sprintf
   \   000173   85..82       MOV     DPL,?XSP + 0
   \   000176   85..83       MOV     DPH,?XSP + 1
   \   000179   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00017C   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   00017F   12....       LCALL   ?DEALLOC_XSTACK8
   2506          OLED_P8x16Str(88,0,s);//µÚÒ»ÐÐ -- 8x16µÄÏÔÊ¾µ¥ÔªÏÔÊ¾ASCIIÂë
   \   000182                ; Setup parameters for call to function OLED_P8x16Str
   \   000182   12....       LCALL   ?Subroutine18 & 0xFFFF
   2507          OLED_P8x16Str(0,2,"V2.45");
   2508          #if defined( CC2530_V30 )
   2509          OLED_P8x16Str(0,2,"V3.00");
   2510          #endif
   2511          sprintf(s, "%04X", NLME_GetCoordShortAddr()); 
   \                     ??CrossCallReturnLabel_26:
   \   000185   8A..         MOV     ?V0 + 2,R2
   \   000187   8B..         MOV     ?V0 + 3,R3
   \   000189   78..         MOV     R0,#?V0 + 2
   \   00018B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00018E   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   000191   12....       LCALL   ?DEALLOC_XSTACK8
   2512          OLED_P8x16Str(48,2,s);
   \   000194                ; Setup parameters for call to function OLED_P8x16Str
   \   000194   12....       LCALL   ?Subroutine21 & 0xFFFF
   2513          sprintf(s, "%04X", NLME_GetShortAddr());
   \                     ??CrossCallReturnLabel_31:
   \   000197   8A..         MOV     ?V0 + 2,R2
   \   000199   8B..         MOV     ?V0 + 3,R3
   \   00019B   78..         MOV     R0,#?V0 + 2
   \   00019D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001A0   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   0001A3   12....       LCALL   ?DEALLOC_XSTACK8
   2514          OLED_P8x16Str(88,2,s);
   \   0001A6                ; Setup parameters for call to function OLED_P8x16Str
   \   0001A6   12....       LCALL   ?Subroutine19 & 0xFFFF
   2515           byte * Send_d;
   2516            Send_d=NLME_GetExtAddr();
   2517          sprintf(s, "%02X%02X%02X%02X%02X%02X%02X%02X", *Send_d,*(Send_d+1),*(Send_d+2),*(Send_d+3),*(Send_d+4),*(Send_d+5),*(Send_d+6),*(Send_d+7));
   \                     ??CrossCallReturnLabel_28:
   \   0001A9   F5..         MOV     ?V0 + 2,A
   \   0001AB   75..00       MOV     ?V0 + 3,#0x0
   \   0001AE   78..         MOV     R0,#?V0 + 2
   \   0001B0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001B3   8A82         MOV     DPL,R2
   \   0001B5   8B83         MOV     DPH,R3
   \   0001B7   A3           INC     DPTR
   \   0001B8   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   0001BB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001BE   8A82         MOV     DPL,R2
   \   0001C0   8B83         MOV     DPH,R3
   \   0001C2   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   0001C5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001C8   8A82         MOV     DPL,R2
   \   0001CA   8B83         MOV     DPH,R3
   \   0001CC   12....       LCALL   ??Subroutine31_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   0001CF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001D2   8A82         MOV     DPL,R2
   \   0001D4   8B83         MOV     DPH,R3
   \   0001D6   12....       LCALL   ??Subroutine32_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   0001D9   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001DC   8A82         MOV     DPL,R2
   \   0001DE   8B83         MOV     DPH,R3
   \   0001E0   12....       LCALL   ??Subroutine33_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   0001E3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001E6   8A82         MOV     DPL,R2
   \   0001E8   8B83         MOV     DPH,R3
   \   0001EA   12....       LCALL   ??Subroutine34_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   0001ED   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001F0   8A82         MOV     DPL,R2
   \   0001F2   8B83         MOV     DPH,R3
   \   0001F4   12....       LCALL   ??Subroutine35_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   0001F7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001FA   7C..         MOV     R4,#(`?<Constant "%02X%02X%02X%02X%02X%...">` & 0xff)
   \   0001FC   7D..         MOV     R5,#((`?<Constant "%02X%02X%02X%02X%02X%...">` >> 8) & 0xff)
   \   0001FE   7A00         MOV     R2,#0x0
   \   000200   7B00         MOV     R3,#0x0
   \   000202   12....       LCALL   ??sprintf?relay
   \   000205   7410         MOV     A,#0x10
   \   000207   12....       LCALL   ?DEALLOC_XSTACK8
   2518          OLED_P8x16Str(0,4,s);
   \   00020A                ; Setup parameters for call to function OLED_P8x16Str
   \   00020A   7C00         MOV     R4,#0x0
   \   00020C   7D00         MOV     R5,#0x0
   \   00020E   7A04         MOV     R2,#0x4
   \   000210   7900         MOV     R1,#0x0
   \   000212   12....       LCALL   ??OLED_P8x16Str?relay
   2519           //////////////////////////////////////////////////////////////////////////////////////////// 
   2520                
   2521          #if !defined (SENSOR_TYPE_Coord)
   2522              ZigBee_C_R_E_Engineering_F();
   2523          #endif
   2524              }
   2525            }
   2526            else
   2527            {
   2528              if ( keys & HAL_KEY_SW_1 )
   2529              {
   2530                //HalLedSet ( HAL_LED_2, HAL_LED_MODE_ON );
   2531          
   2532                // Initiate an End Device Bind Request for the mandatory endpoint
   2533                dstAddr.addrMode = Addr16Bit;
   2534                dstAddr.addr.shortAddr = 0x0000; // Coordinator
   2535                ZDP_EndDeviceBindReq( &dstAddr, NLME_GetShortAddr(), 
   2536                                      GenericApp_epDesc.endPoint,
   2537                                      GENERICAPP_PROFID,
   2538                                      GENERICAPP_MAX_CLUSTERS, (cId_t *)GenericApp_ClusterList,
   2539                                      GENERICAPP_MAX_CLUSTERS, (cId_t *)GenericApp_ClusterList,
   2540                                      FALSE );
   2541              }
   2542          
   2543              if ( keys & HAL_KEY_SW_2 )
   2544              {
   2545                // Initiate a Match Description Request (Service Discovery)
   2546                dstAddr.addrMode = AddrBroadcast;
   2547                dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR;
   2548                ZDP_MatchDescReq( &dstAddr, NWK_BROADCAST_SHORTADDR,
   2549                                  GENERICAPP_PROFID,
   2550                                  GENERICAPP_MAX_CLUSTERS, (cId_t *)GenericApp_ClusterList,
   2551                                  GENERICAPP_MAX_CLUSTERS, (cId_t *)GenericApp_ClusterList,
   2552                                  FALSE );
   2553              }
   2554            }
   2555          }
   \                     ??GenericApp_HandleKeys_1:
   \   000215   7402         MOV     A,#0x2
   \   000217   12....       LCALL   ?DEALLOC_XSTACK8
   \   00021A   7F0C         MOV     R7,#0xc
   \   00021C   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   7C00         MOV     R4,#0x0
   \   000002   7D00         MOV     R5,#0x0
   \   000004   7A00         MOV     R2,#0x0
   \   000006   7910         MOV     R1,#0x10
   \   000008   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   7C00         MOV     R4,#0x0
   \   000002   7D00         MOV     R5,#0x0
   \   000004   7A02         MOV     R2,#0x2
   \   000006   7958         MOV     R1,#0x58
   \   000008   12....       LCALL   ??OLED_P8x16Str?relay
   \   00000B                ; Setup parameters for call to function NLME_GetExtAddr
   \   00000B                ; Setup parameters for call to function NLME_GetExtAddr
   \   00000B   12....       LCALL   ??NLME_GetExtAddr?relay
   \   00000E                ; Setup parameters for call to function sprintf
   \   00000E                ; Setup parameters for call to function sprintf
   \   00000E   8A82         MOV     DPL,R2
   \   000010   8B83         MOV     DPH,R3
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   7C00         MOV     R4,#0x0
   \   000002   7D00         MOV     R5,#0x0
   \   000004   7A00         MOV     R2,#0x0
   \   000006   7958         MOV     R1,#0x58
   \   000008   12....       LCALL   ??OLED_P8x16Str?relay
   \   00000B                ; Setup parameters for call to function OLED_P8x16Str
   \   00000B                ; Setup parameters for call to function OLED_P8x16Str
   \   00000B   7C..         MOV     R4,#(`?<Constant "V2.45">` & 0xff)
   \   00000D   7D..         MOV     R5,#((`?<Constant "V2.45">` >> 8) & 0xff)
   \   00000F   7A02         MOV     R2,#0x2
   \   000011   7900         MOV     R1,#0x0
   \   000013   12....       LCALL   ??OLED_P8x16Str?relay
   \   000016                ; Setup parameters for call to function sprintf
   \   000016                ; Setup parameters for call to function NLME_GetCoordShortAddr
   \   000016                ; Setup parameters for call to function sprintf
   \   000016                ; Setup parameters for call to function NLME_GetCoordShortAddr
   \   000016   12....       LCALL   ??NLME_GetCoordShortAddr?relay
   \   000019   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   12....       LCALL   ??OLED_Init?relay
   \   000003                ; Setup parameters for call to function OLED_P8x16Str
   \   000003                ; Setup parameters for call to function OLED_P8x16Str
   \   000003   7C..         MOV     R4,#(`?<Constant "R       ID:">` & 0xff)
   \   000005   7D..         MOV     R5,#((`?<Constant "R       ID:">` >> 8) & 0xff)
   \   000007   7A00         MOV     R2,#0x0
   \   000009   7900         MOV     R1,#0x0
   \   00000B   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL   ??OLED_P8x16Str?relay
   \   000003                ; Setup parameters for call to function osal_nv_read
   \   000003                ; Setup parameters for call to function osal_nv_read
   \   000003                ; Setup parameters for call to function osal_nv_read
   \   000003                ; Setup parameters for call to function osal_nv_read
   \   000003   85..82       MOV     DPL,?XSP + 0
   \   000006   85..83       MOV     DPH,?XSP + 1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine31_0
   \   000001                ; // Fall through to label ??Subroutine31_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine31_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine32_0
   \   000001                ; // Fall through to label ??Subroutine32_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine32_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine33_0
   \   000001                ; // Fall through to label ??Subroutine33_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine33_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine34_0
   \   000001                ; // Fall through to label ??Subroutine34_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine34_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine35_0
   \   000001                ; // Fall through to label ??Subroutine35_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine35_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 2,A
   \   000003   78..         MOV     R0,#?V0 + 2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine36_0
   \   000001                ; // Fall through to label ??Subroutine36_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine36_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine37_0
   \   000001                ; // Fall through to label ??Subroutine37_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine37_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine38_0
   \   000001                ; // Fall through to label ??Subroutine38_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine38_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine39_0
   \   000001                ; // Fall through to label ??Subroutine39_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine39_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine40_0
   \   000001                ; // Fall through to label ??Subroutine40_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine40_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 10,A
   \   000003   78..         MOV     R0,#?V0 + 10
   \   000005   22           RET
   2556          
   2557          /*********************************************************************
   2558           * LOCAL FUNCTIONS
   2559           */
   2560          
   2561          /*********************************************************************
   2562           * @fn      GenericApp_MessageMSGCB
   2563           *
   2564           * @brief   Data message processor callback.  This function processes
   2565           *          any incoming data - probably from other devices.  So, based
   2566           *          on cluster ID, perform the intended action.
   2567           *
   2568           * @param   none
   2569           *
   2570           * @return  none
   2571          
   2572           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2573          void GenericApp_MessageMSGCB( afIncomingMSGPacket_t *pkt )
   \                     GenericApp_MessageMSGCB:
   2574          { 
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2575          #if defined( SENSOR_TYPE_Coord )
   2576          #if(ZDO_COORDINATOR==2)  //ZIGBEE  ATÃüÁîÄ£Ê½ Í¸´«Ä£Ê½
   2577            
   2578             if(FT_AT==1) // Í¸´«Ä£Ê½
   2579             {HalUARTWrite(HAL_UART_PORT_0, (uint8*)pkt->cmd.Data,pkt->cmd.DataLength);
   2580             }
   2581           #else
   2582          #if defined( CC2530_V30 )
   2583            HalUARTWrite(HAL_UART_PORT_0, (uint8*)pkt->cmd.Data,pkt->cmd.Data[1]+11);
   2584          #else
   2585            HalUARTWrite(HAL_UART_PORT_0, (uint8*)pkt->cmd.Data,pkt->cmd.Data[1]+6);
   \   000004   EA           MOV     A,R2
   \   000005   2421         ADD     A,#0x21
   \   000007   F582         MOV     DPL,A
   \   000009   EB           MOV     A,R3
   \   00000A   3400         ADDC    A,#0x0
   \   00000C   F583         MOV     DPH,A
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   FA           MOV     R2,A
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   FB           MOV     R3,A
   \   000013                ; Setup parameters for call to function HalUARTWrite
   \   000013   8A82         MOV     DPL,R2
   \   000015   8B83         MOV     DPH,R3
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F8           MOV     R0,A
   \   00001A   7406         MOV     A,#0x6
   \   00001C   28           ADD     A,R0
   \   00001D   FC           MOV     R4,A
   \   00001E   E4           CLR     A
   \   00001F   3400         ADDC    A,#0x0
   \   000021   FD           MOV     R5,A
   \   000022   7900         MOV     R1,#0x0
   \   000024   12....       LCALL   ??HalUARTWrite?relay
   2586          #endif
   2587            
   2588          #endif
   2589             HalLedSet ( HAL_LED_1, HAL_LED_MODE_TOGGLE );
   \   000027                ; Setup parameters for call to function HalLedSet
   \   000027   7A08         MOV     R2,#0x8
   \   000029   7901         MOV     R1,#0x1
   \   00002B   12....       LCALL   ??HalLedSet?relay
   2590          #else
   2591          
   2592             
   2593          if((pkt->cmd.Data[6]==0x11)&&(pkt->cmd.Data[7]==0x22)&&(pkt->cmd.Data[8]==0x33)&&(pkt->cmd.Data[9]==0x44))
   2594          {if(pkt->cmd.Data[10]==0xCC){if(pkt->cmd.Data[12]==SENSOR_TYPE)openoff=pkt->cmd.Data[11];}
   2595              else
   2596              {
   2597                char GetExtAddr=0;
   2598            byte * Send_d;
   2599            Send_d=NLME_GetExtAddr();
   2600            for(int i=0;i<8;i++)
   2601            {
   2602            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   2603              GetExtAddr++;
   2604            }
   2605               if(GetExtAddr==8)openoff=pkt->cmd.Data[11]; 
   2606              }
   2607          }
   2608          #if((SENSOR_TYPE =='E')||(SENSOR_TYPE =='B')||(SENSOR_TYPE =='C')||(SENSOR_TYPE =='D')||(SENSOR_TYPE =='F')\
   2609            ||(SENSOR_TYPE =='U')||(SENSOR_TYPE ==0X10)||(SENSOR_TYPE ==0X21)||(SENSOR_TYPE ==0X11)\
   2610              ||(SENSOR_TYPE ==0X0F)||(SENSOR_TYPE ==0X13)||(SENSOR_TYPE ==0X14)||(SENSOR_TYPE ==0X17)\
   2611                ||(SENSOR_TYPE ==0X24)||(SENSOR_TYPE ==0X5A)||(SENSOR_TYPE ==0X5B)||(SENSOR_TYPE ==0X6A)||(SENSOR_TYPE =='A')\
   2612                  ||(SENSOR_TYPE =='J')||(SENSOR_TYPE =='L')||(SENSOR_TYPE =='M')||(SENSOR_TYPE =='N')\
   2613            ||(SENSOR_TYPE ==0X04)||(SENSOR_TYPE ==0X22)||(SENSOR_TYPE ==0X0C)||(SENSOR_TYPE ==0X16)||(SENSOR_TYPE ==0X19)\
   2614              ||(SENSOR_TYPE ==0X61)||(SENSOR_TYPE ==0X62)||(SENSOR_TYPE ==0X63)||(SENSOR_TYPE ==0X1A)||(SENSOR_TYPE ==0X33)\
   2615                ||(SENSOR_TYPE ==0X72) ||(SENSOR_TYPE ==0X34)||(SENSOR_TYPE ==0X35)||(SENSOR_TYPE ==0X36)||(SENSOR_TYPE ==0X37)\
   2616                  ||(SENSOR_TYPE ==0X38)||(SENSOR_TYPE ==0X39)||(SENSOR_TYPE ==0X3A)||(SENSOR_TYPE ==0X80)||(SENSOR_TYPE ==0X3D)\
   2617                    ||(SENSOR_TYPE ==0X81)||(SENSOR_TYPE ==0X82)||(SENSOR_TYPE ==0X3B)||(SENSOR_TYPE ==0X3C)||(SENSOR_TYPE ==0X3E)\
   2618                      ||(SENSOR_TYPE ==0X3F)||(SENSOR_TYPE ==0X84)||(SENSOR_TYPE ==0X85)||(SENSOR_TYPE ==0X75)||(SENSOR_TYPE ==0X78))
   2619          //¶¨Ê±3
   2620          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==0X00))
   2621                { 
   2622          //¶¨Ê±·¢ËÍÃüÁî
   2623                  if(pkt->cmd.Data[9]==0xAA)//¶¨Ê±·¢ËÍÃüÁî
   2624                  {
   2625                     if((pkt->cmd.Data[7]==0xFF)&&(pkt->cmd.Data[8]==0XFF))
   2626                     { if(pkt->cmd.Data[11]==0xAA)//
   2627                      {T_MGSbit&=~0X80; //0XXXX XXXX
   2628                        T_MGSbit|=0X60; //x11x xxx0 Ä¬ÈÏ¶¨Ê± Ó¦´ð Õý³£ ×´Ì¬Î»
   2629                        GenericApp_time=1;
   2630          #if defined( POWER_SAVING )
   2631                        GenericApp_time=25;
   2632          #endif
   2633                        
   2634                        
   2635                      }
   2636                      if(pkt->cmd.Data[11]==0xBB)//
   2637                      { T_MGSbit&=~0XC0;//00XX XXXX ¹Ø±Õ¶¨Ê± Ó¦´ð Õý³£ ×´Ì¬Î»
   2638                        TIMER3_RUN(FALSE);  //¹Ø±Õ¶¨Ê±
   2639                       GenericApp_time=0;;  
   2640                      }
   2641                     }
   2642                     else
   2643                     {
   2644                  #if defined( ZigBee_C_R_E_IEEE )
   2645                  char GetExtAddr=0;
   2646                  byte * Send_d;
   2647                  Send_d=NLME_GetExtAddr();
   2648                  for(int i=0;i<8;i++)
   2649                  {
   2650                  if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   2651                    GetExtAddr++;
   2652                  }
   2653                     if(GetExtAddr==8)
   2654                  #else
   2655                if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   2656                  #endif    
   2657                   { if(pkt->cmd.Data[11]==0xAA)//
   2658                      {T_MGSbit&=~0X40; //x0xx xxxx
   2659                        T_MGSbit|=0XA0; //1x1x xxx0 Éè¶¨¶¨Ê±  Ó¦´ð Õý³£ ×´Ì¬Î»
   2660                        /* Ê¹ÄÜ¶¨Ê±Æ÷3µÄÒç³öÖÐ¶Ï */
   2661                       TIMER34_INIT(3);
   2662                       if(pkt->cmd.Data[10]<2)
   2663                         pkt->cmd.Data[10]=1;
   2664                       halSetTimer3Period(100);  //100MS
   2665                       T3_t1Val=(10*pkt->cmd.Data[10]); //pkt->cmd.Data[10]Ãë
   2666                       IEN1 |= (0x01 << 3);             // Ê¹ÄÜTimer3µÄÖÐ¶ÏT3IE
   2667                       TIMER3_RUN(TRUE);  
   2668                       GenericApp_applicationbuf=60001;
   2669                       GenericApp_time=0;  
   2670                      }
   2671                      if(pkt->cmd.Data[11]==0xBB)//
   2672                      {T_MGSbit&=~0XC0;//00XX XXXX ¹Ø±Õ¶¨Ê± Ó¦´ð Õý³£ ×´Ì¬Î»
   2673                        T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   2674                        TIMER3_RUN(FALSE);  //¹Ø±Õ¶¨Ê±
   2675                       GenericApp_applicationbuf=60001;
   2676                       GenericApp_time=0;  
   2677                      }
   2678                    }
   2679                  } 
   2680                } 
   2681          //°´MACµØÖ·µ¥´ÎÈ¡Êý¾ÝÃüÁî (²É¼¯ÀàÐÍ)
   2682               if(pkt->cmd.Data[9]==0xA1)//°´MACµØÖ·µ¥´ÎÈ¡Êý¾ÝÃüÁî (²É¼¯ÀàÐÍ)
   2683                  {
   2684                  #if defined( ZigBee_C_R_E_IEEE )
   2685                  char GetExtAddr=0;
   2686                  byte * Send_d;
   2687                  Send_d=NLME_GetExtAddr();
   2688                  for(int i=0;i<8;i++)
   2689                  {
   2690                  if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   2691                    GetExtAddr++;
   2692                  }
   2693                     if(GetExtAddr==8)
   2694                  #else
   2695                if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   2696                  #endif    
   2697                   { T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   2698                       GenericApp_applicationbuf=60001;
   2699                   }
   2700                }
   2701            }
   2702          #endif 
   2703          //°´Àà±ð´¥·¢ÃüÁî
   2704          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   2705            {  
   2706              if((pkt->cmd.Data[2]==0XFF)&&(pkt->cmd.Data[3]==0XFF))
   2707                {T_MGSbit|=0X21; //xx1x xxx1 Ó¦´ð ´¥·¢ ×´Ì¬Î»
   2708                if(Send_datalend==0)Send_datalend=3;
   2709                 if(Send_datalend>0X20)Send_datalend=3;
   2710                 GenericApp_applicationbuf=0;
   2711                 GenericApp_SendTheMessage();
   2712                }
   2713            }
   2714          
   2715          
   2716          #if(SENSOR_TYPE =='S')
   2717          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   2718                {
   2719          #if defined( ZigBee_C_R_E_IEEE )
   2720            char GetExtAddr=0;
   2721            byte * Send_d;
   2722            Send_d=NLME_GetExtAddr();
   2723            for(int i=0;i<8;i++)
   2724            {
   2725            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   2726              GetExtAddr++;
   2727            }
   2728               if(GetExtAddr==8)
   2729          #else
   2730               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   2731          #endif    
   2732                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   2733                  if(pkt->cmd.Data[9]==0xAB)//µ÷¹â
   2734                   { if(pkt->cmd.Data[10]==0xA1)  
   2735                      {GenericApp_ON_OFF=pkt->cmd.Data[11];
   2736                        DimmingAppControl(GenericApp_ON_OFF,0x00);
   2737                      GenericApp_applicationbuf=1;
   2738                      }
   2739                     if(pkt->cmd.Data[10]==0xB2)  
   2740                      { GenericApp_ON_OFF=pkt->cmd.Data[11];
   2741                        DimmingAppControl(GenericApp_ON_OFF,0x01);
   2742                       GenericApp_applicationbuf=1;
   2743                      }
   2744                   }
   2745                 if(pkt->cmd.Data[9]==0xCC)//¼ì²âÉè±¸
   2746                   {
   2747                    GenericApp_applicationbuf=2;
   2748                   }
   2749                   GenericApp_SendTheMessage();
   2750                }
   2751                }
   2752          #endif
   2753          #if(SENSOR_TYPE =='Q')
   2754          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   2755                {
   2756          #if defined( ZigBee_C_R_E_IEEE )
   2757            char GetExtAddr=0;
   2758            byte * Send_d;
   2759            Send_d=NLME_GetExtAddr();
   2760            for(int i=0;i<8;i++)
   2761            {
   2762            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   2763              GetExtAddr++;
   2764            }
   2765               if(GetExtAddr==8)
   2766          #else
   2767               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   2768          #endif    
   2769                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   2770                  if(pkt->cmd.Data[9]==0xAB)//Ä¬ÈÏ
   2771                   { if(pkt->cmd.Data[10]==0xA1) //ÉèÖÃµç×Ó³ÓÏµÊý   50-150Ö®¼ä
   2772                      {if((pkt->cmd.Data[11]>49)&&(pkt->cmd.Data[11]<151))
   2773                        AD_SHINING=pkt->cmd.Data[11];
   2774                         uint16 nv_data=0X0000;
   2775                         nv_data=AD_SHINING;
   2776                      osal_nv_item_init( ZCD_NV_APP_AD_SHINING,sizeof(nv_data), &nv_data );
   2777                      osal_nv_write( ZCD_NV_APP_AD_SHINING, 0,sizeof(nv_data),&nv_data);
   2778                      Send_datalend=0x04;  
   2779                      Send_data[7]=0;//ÊýÖµÎª0
   2780                      Send_data[8]=AD_SHINING;//·µ»ØÉèÖÃÏµÊý
   2781                      Send_data[9]=(Send_data[6]+Send_data[7]+Send_data[8])%256;
   2782                      }
   2783                   }
   2784                   GenericApp_SendTheMessage();
   2785                }
   2786                }
   2787          #endif
   2788          
   2789          #if(SENSOR_TYPE ==0X29)
   2790          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   2791                { 
   2792                #if defined( ZigBee_C_R_E_IEEE )
   2793                  char GetExtAddr=0;
   2794                  byte * Send_d;
   2795                  Send_d=NLME_GetExtAddr();
   2796                  for(int i=0;i<8;i++)
   2797                  {
   2798                  if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   2799                    GetExtAddr++;
   2800                  }
   2801                     if(GetExtAddr==8)
   2802                #else
   2803                     if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   2804                #endif    
   2805                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   2806                  if(pkt->cmd.Data[9]==0xAF)//µãÕó¼Û¸ñÐÞ¸Ä
   2807                  {
   2808                    if(pkt->cmd.Data[10]<5)
   2809                       HalUARTWrite(HAL_UART_PORT_0,&pkt->cmd.Data[10],pkt->cmd.Data[10]+1); //03 05 06 bb // 02 05 BB
   2810                    else 
   2811                      HalUARTWrite(HAL_UART_PORT_0,&pkt->cmd.Data[10],3); //aa 05 bb
   2812                     GenericApp_applicationbuf=1;
   2813                  } 
   2814                  if(pkt->cmd.Data[9]==0xAD)//¼ì²âÉè±¸
   2815                  {
   2816                    GenericApp_applicationbuf=2;
   2817                  }
   2818                  GenericApp_SendTheMessage();
   2819                }
   2820                }  
   2821          #endif
   2822          #if(SENSOR_TYPE ==0X31)
   2823                if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   2824                { 
   2825                #if defined( ZigBee_C_R_E_IEEE )
   2826                  char GetExtAddr=0;
   2827                  byte * Send_d;
   2828                  Send_d=NLME_GetExtAddr();
   2829                  for(int i=0;i<8;i++)
   2830                  {
   2831                  if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   2832                    GetExtAddr++;
   2833                  }
   2834                     if(GetExtAddr==8)
   2835                #else
   2836                     if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   2837                #endif    
   2838                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   2839                  if(pkt->cmd.Data[9]==0xB4)//ÏòÐ¡³µ·¢ÃüÁî
   2840                  {
   2841                      HalUARTWrite(HAL_UART_PORT_0,&pkt->cmd.Data[10],3);
   2842                      //HalUARTWrite(HAL_UART_PORT_0,&pkt->cmd.Data[10],3);
   2843                      //GenericApp_applicationbuf=1;
   2844                  }
   2845                  if(pkt->cmd.Data[9]==0xED)//¹Ø±Õ¶Á¿¨×Ô¶¯Í£³µ
   2846                  {
   2847                     car_stata=0X01;//¹Ø±Õ¶Á¿¨×Ô¶¯Í£³µ
   2848                      GenericApp_applicationbuf=1;
   2849                      GenericApp_SendTheMessage();
   2850                  }
   2851                  
   2852                  if((pkt->cmd.Data[9]==0xEA)&&(pkt->cmd.Data[11]==0xEA))
   2853                  { HalUARTWrite(HAL_UART_PORT_0,&pkt->cmd.Data[9],3);
   2854                  }
   2855               //   GenericApp_SendTheMessage();
   2856                }
   2857                }  
   2858          #endif
   2859          
   2860          #if(SENSOR_TYPE ==0X67)
   2861          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   2862                {
   2863          #if defined( ZigBee_C_R_E_IEEE )
   2864            char GetExtAddr=0;
   2865            byte * Send_d;
   2866            Send_d=NLME_GetExtAddr();
   2867            for(int i=0;i<8;i++)
   2868            {
   2869            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   2870              GetExtAddr++;
   2871            }
   2872               if(GetExtAddr==8)
   2873          #else
   2874               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   2875          #endif    
   2876                { T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   2877                unsigned int dat16;
   2878                if(pkt->cmd.Data[9]==0xAA)//Õý×ª
   2879                   {  P0_4=1;P0_5=0;
   2880                      P1_0=1;P1_1=0;
   2881                      dat16=(pkt->cmd.Data[10])&0X0F;
   2882                      dat16=((dat16<<8)+pkt->cmd.Data[11]);
   2883                      DAchange(dat16);
   2884                      GenericApp_applicationbuf=1;
   2885                      }
   2886                     if(pkt->cmd.Data[9]==0xBB)  
   2887                      {P0_4=0;P0_5=1;
   2888                       P1_0=0;P1_1=1;
   2889                       dat16=(pkt->cmd.Data[10])&0X0F;
   2890                      dat16=((dat16<<8)+pkt->cmd.Data[11]);
   2891                      DAchange(dat16);
   2892                       GenericApp_applicationbuf=1;
   2893                      }
   2894                   if(pkt->cmd.Data[9]==0xCC)  
   2895                      {P0_4=0;P0_5=0;
   2896                       P1_0=0;P1_1=0;
   2897                      DAchange(0);
   2898                       GenericApp_applicationbuf=1;
   2899                      }
   2900                   GenericApp_SendTheMessage();
   2901                   }
   2902                }
   2903          #endif
   2904          
   2905          #if(SENSOR_TYPE ==0X6D)
   2906          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   2907          { 
   2908              // if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))  
   2909               if((pkt->cmd.Data[7]==0X01)&&(pkt->cmd.Data[8]==0X02))  
   2910                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   2911                  GenericApp_applicationbuf=1;
   2912                    HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[9]),pkt->cmd.Data[1]-3);
   2913                      GenericApp_SendTheMessage();
   2914                } 
   2915                }  
   2916          #endif
   2917          #if(SENSOR_TYPE ==0X30)
   2918           if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   2919                {
   2920          #if defined( ZigBee_C_R_E_IEEE )
   2921            char GetExtAddr=0;
   2922            byte * Send_d;
   2923            Send_d=NLME_GetExtAddr();
   2924            for(int i=0;i<8;i++)
   2925            {
   2926            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   2927              GetExtAddr++;
   2928            }
   2929               if(GetExtAddr==8)
   2930          #else
   2931               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   2932          #endif    
   2933                { T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   2934                if(pkt->cmd.Data[9]==0xAA)//2Ïò4Ïß²½½øµç»ú
   2935                   { if(pkt->cmd.Data[10]==0xAB) //Õý×ª
   2936                        {a68=0xAB;b68=pkt->cmd.Data[11];
   2937                        }
   2938                     if(pkt->cmd.Data[10]==0xBA) //·´×ª
   2939                        {a68=0xBA;b68=pkt->cmd.Data[11];
   2940                        }
   2941                      GenericApp_applicationbuf=1;
   2942                    }
   2943                  if(pkt->cmd.Data[9]==0xAF)//2Ïò4Ïß²½½øµç»ú´°Á±¿ªÆô¹Ø±Õ
   2944                   { 
   2945                     if(pkt->cmd.Data[10]==0xAB) //Õý×ª//´°Á±¿ªÆô
   2946                        {a68=0xAB;b68=250;
   2947                        }
   2948                     if(pkt->cmd.Data[10]==0xBA) //·´×ª//´°Á±¹Ø±Õ
   2949                        {a68=0xBA;b68=250;
   2950                        }
   2951                      GenericApp_applicationbuf=1;
   2952                    }
   2953                  if(pkt->cmd.Data[9]==0xB0)//2Ïò4Ïß²½½øµç»ú
   2954                   { if((pkt->cmd.Data[10]==0xAA)&&(pkt->cmd.Data[12]==0xBB)) //Õý×ª
   2955                        {
   2956                          if(pkt->cmd.Data[11]==0x01)//¹ØÕ¢
   2957                          {c68=0;if(a68!=0xab) {a68=0xab;b68=B01;}}
   2958                           if(pkt->cmd.Data[11]==0x02) //¿ªÕ¢
   2959                           {c68=150; if(a68!=0xba){a68=0xba;b68=B01;}}
   2960                        GenericApp_applicationbuf=1;
   2961                        } 
   2962                    }
   2963                   GenericApp_SendTheMessage();
   2964                   }
   2965          
   2966                }
   2967          #endif
   2968          #if(SENSOR_TYPE ==0X73)
   2969           if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   2970                {
   2971          #if defined( ZigBee_C_R_E_IEEE )
   2972            char GetExtAddr=0;
   2973            byte * Send_d;
   2974            Send_d=NLME_GetExtAddr();
   2975            for(int i=0;i<8;i++)
   2976            {
   2977            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   2978              GetExtAddr++;
   2979            }
   2980               if(GetExtAddr==8)
   2981          #else
   2982               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   2983          #endif    
   2984                { T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   2985                     if(pkt->cmd.Data[10]==0xA8)//8Â·¶Ñ¶â»ú
   2986                   {pkt->cmd.Data[9]=0x05;
   2987                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[9]),0X06);
   2988                    }
   2989                     if(pkt->cmd.Data[10]==0xAC)//´ÅÏß¿ØÖÆÆ÷
   2990                   {pkt->cmd.Data[9]=0x05;
   2991                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[9]),0X06);
   2992                    }
   2993                  if(pkt->cmd.Data[10]==0xA1)//¶Ñ¶â»ú
   2994                   { 
   2995                     if(pkt->cmd.Data[11]==0xAB) //Õý×ª//
   2996                        {
   2997                          a68=0xAB;b68=5000;
   2998                        b68=(((int)(pkt->cmd.Data[12])<<8)+(pkt->cmd.Data[13]));
   2999                        }
   3000                     if(pkt->cmd.Data[11]==0xBA) //·´×ª//
   3001                        {a68=0xba;b68=5000;
   3002                       b68=(((int)(pkt->cmd.Data[12])<<8)+(pkt->cmd.Data[13]));
   3003                        }
   3004                      GenericApp_applicationbuf=1;
   3005                     Send_data[10]=0X00;
   3006                   GenericApp_SendTheMessage();
   3007                    }
   3008                   }
   3009          
   3010                }
   3011          #endif
   3012          #if(SENSOR_TYPE ==0X6A)
   3013          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3014                {
   3015          #if defined( ZigBee_C_R_E_IEEE )
   3016            char GetExtAddr=0;
   3017            byte * Send_d;
   3018            Send_d=NLME_GetExtAddr();
   3019            for(int i=0;i<8;i++)
   3020            {
   3021            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3022              GetExtAddr++;
   3023            }
   3024               if(GetExtAddr==8)
   3025          #else
   3026               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3027          #endif    
   3028                { T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3029                  GenericApp_switch=1;
   3030                  Send_data[7]=pkt->cmd.Data[9];
   3031                   GenericApp_SendTheMessage();
   3032                   }
   3033                }
   3034          #endif
   3035          #if(SENSOR_TYPE ==0X6B)
   3036          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3037                {
   3038          #if defined( ZigBee_C_R_E_IEEE )
   3039            char GetExtAddr=0;
   3040            byte * Send_d;
   3041            Send_d=NLME_GetExtAddr();
   3042            for(int i=0;i<8;i++)
   3043            {
   3044            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3045              GetExtAddr++;
   3046            }
   3047               if(GetExtAddr==8)
   3048          #else
   3049               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3050          #endif    
   3051                { T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3052                  if(pkt->cmd.Data[9]==0xDD) //ledÆÁ
   3053                   {  uint8  hrx[4]={0X02,0x33,0x01,0X00};
   3054                 hrx[2]=pkt->cmd.Data[10];
   3055                 HalUARTWrite(HAL_UART_PORT_0,hrx,4);
   3056                      GenericApp_applicationbuf=1;
   3057                      }
   3058                  if(pkt->cmd.Data[9]==0xDE) //DE:A8¹ã¸æ»ú
   3059                   {  
   3060                 HalUARTWrite(HAL_UART_PORT_0,&pkt->cmd.Data[9],3);
   3061                      GenericApp_applicationbuf=1;
   3062                      }
   3063                    if(pkt->cmd.Data[9]==0xDC) //DC:×Ö¿âLED
   3064                   {  
   3065                 HalUARTWrite(HAL_UART_PORT_0,&pkt->cmd.Data[12],pkt->cmd.Data[13]+2);
   3066                      GenericApp_applicationbuf=1;
   3067                      }
   3068                  Send_data[7]=pkt->cmd.Data[9];
   3069                   GenericApp_SendTheMessage();
   3070                   }
   3071                }
   3072          #endif
   3073          #if(SENSOR_TYPE ==0X65)
   3074          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3075                {
   3076          #if defined( ZigBee_C_R_E_IEEE )
   3077            char GetExtAddr=0;
   3078            byte * Send_d;
   3079            Send_d=NLME_GetExtAddr();
   3080            for(int i=0;i<8;i++)
   3081            {
   3082            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3083              GetExtAddr++;
   3084            }
   3085               if(GetExtAddr==8)
   3086          #else
   3087               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3088          #endif    
   3089                { T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3090                  show_right_down(pkt->cmd.Data[10]);
   3091                  GenericApp_switch=1;
   3092                   GenericApp_SendTheMessage();
   3093                   }
   3094                }
   3095          #endif
   3096          #if(SENSOR_TYPE ==0X6C)
   3097          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3098                {
   3099          #if defined( ZigBee_C_R_E_IEEE )
   3100            char GetExtAddr=0;
   3101            byte * Send_d;
   3102            Send_d=NLME_GetExtAddr();
   3103            for(int i=0;i<8;i++)
   3104            {
   3105            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3106              GetExtAddr++;
   3107            }
   3108               if(GetExtAddr==8)
   3109          #else
   3110               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3111          #endif    
   3112                { T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3113                //  show_right_down(pkt->cmd.Data[10]);
   3114                  if(pkt->cmd.Data[10]==0x02)//
   3115               {switch(pkt->cmd.Data[11])
   3116                   {case 0x0B:P1_1=0; break;//11Â·
   3117                   case 0x16:P1_2=0; break;//22Â·
   3118                   case 0x37:P1_3=0; break;//55Â·
   3119                   case 0x58:P1_4=0; break;//88Â·
   3120                  default:break;
   3121                   }
   3122                }
   3123                lcd_txt_clr(); 
   3124                switch(pkt->cmd.Data[9])
   3125                   {case 0x01:txt_disp(str2,0x80,16); break;
   3126                   case 0x02:txt_disp(str3,0x80,16); break;
   3127                   case 0x03:txt_disp(str4,0x80,16); break;
   3128                   case 0x04:txt_disp(str5,0x80,16); break;
   3129                  default:break;
   3130                   }
   3131                    switch(pkt->cmd.Data[10])
   3132                   {case 0x01:hzkdis(1,tab1); break;
   3133                   case 0x02:hzkdis(1,tab2); break;
   3134                   case 0x03:hzkdis(1,tab3); break;
   3135                  default:break;
   3136                   }
   3137                 txt_disp(&str1[(pkt->cmd.Data[11]/10)*2],0x90,2);//80 90 88 98
   3138                 txt_disp(&str1[(pkt->cmd.Data[11]%10)*2],0x91,2);//80 90 88 98
   3139                  if(pkt->cmd.Data[10]==0x03)
   3140                  { txt_disp(&str1[(pkt->cmd.Data[12]/10)*2],0x8a,2);//80 90 88 98
   3141                 txt_disp(&str1[(pkt->cmd.Data[12]%10)*2],0x8b,2);//80 90 88 98
   3142                 txt_disp(&str1[((pkt->cmd.Data[12]*5)/10)*2],0x98,2);//80 90 88 98
   3143                 txt_disp(&str1[((pkt->cmd.Data[12]*5)%10)*2],0x99,2);//80 90 88 98
   3144                  }
   3145                   
   3146              P1|=0X1E;
   3147             
   3148                  GenericApp_switch=1;
   3149                   GenericApp_SendTheMessage();
   3150                }
   3151                }
   3152          #endif
   3153          #if(SENSOR_TYPE ==0X66)
   3154          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3155                {
   3156          #if defined( ZigBee_C_R_E_IEEE )
   3157            char GetExtAddr=0;
   3158            byte * Send_d;
   3159            Send_d=NLME_GetExtAddr();
   3160            for(int i=0;i<8;i++)
   3161            {
   3162            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3163              GetExtAddr++;
   3164            }
   3165               if(GetExtAddr==8)
   3166          #else
   3167               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3168          #endif    
   3169                { T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3170                  LedNumVal=pkt->cmd.Data[9];
   3171                  GenericApp_switch=1;
   3172                   GenericApp_SendTheMessage();
   3173                   }
   3174                }
   3175          #endif
   3176          #if(SENSOR_TYPE ==0X6E)
   3177          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3178                {
   3179          #if defined( ZigBee_C_R_E_IEEE )
   3180            char GetExtAddr=0;
   3181            byte * Send_d;
   3182            Send_d=NLME_GetExtAddr();
   3183            for(int i=0;i<8;i++)
   3184            {
   3185            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3186              GetExtAddr++;
   3187            }
   3188               if(GetExtAddr==8)
   3189          #else
   3190               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3191          #endif    
   3192                { T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3193                if(pkt->cmd.Data[9]==0X01)//16Â·¼ÌµçÆ÷¿ØÖÆ
   3194                {
   3195                  SendDataS(&(pkt->cmd.Data[11]),pkt->cmd.Data[10]);
   3196                  GenericApp_switch=1;
   3197                   GenericApp_SendTheMessage();
   3198                }
   3199                   }
   3200                }
   3201          #endif
   3202          #if(SENSOR_TYPE ==0XA3)
   3203          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3204                { 
   3205                #if defined( ZigBee_C_R_E_IEEE )
   3206                  char GetExtAddr=0;
   3207                  byte * Send_d;
   3208                  Send_d=NLME_GetExtAddr();
   3209                  for(int i=0;i<8;i++)
   3210                  {
   3211                  if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3212                    GetExtAddr++;
   3213                  }
   3214                     if(GetExtAddr==8)
   3215                #else
   3216                     if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3217                #endif    
   3218                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3219                  if(pkt->cmd.Data[9]==0xB5)//ÏòºìÂÌµÆ·¢ËÍÖ¸Áî
   3220                  {
   3221                      HalUARTWrite(HAL_UART_PORT_0,&pkt->cmd.Data[10],5);
   3222                      GenericApp_applicationbuf=0;
   3223                  } 
   3224                  if(pkt->cmd.Data[9]==0xAD)//¼ì²âÉè±¸
   3225                  {
   3226                    GenericApp_applicationbuf=2;
   3227                  }
   3228                  GenericApp_SendTheMessage();
   3229                }
   3230                }  
   3231          #endif
   3232          #if(SENSOR_TYPE ==0X05)
   3233          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3234                {
   3235          #if defined( ZigBee_C_R_E_IEEE )
   3236                  char GetExtAddr=0;
   3237            byte * Send_d;
   3238            Send_d=NLME_GetExtAddr();
   3239            for(int i=0;i<8;i++)
   3240            {
   3241            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3242              GetExtAddr++;
   3243            }
   3244               if(GetExtAddr==8)
   3245          #else
   3246               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3247          #endif    
   3248                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3249                  if(pkt->cmd.Data[9]==0xDD)//¿ØÖÆ220V¼ÌµçÆ÷
   3250                   {uint8 uartkey=0;
   3251                     if(pkt->cmd.Data[10]==0xA3)  
   3252                      {  GenericApp_applicationbuf=1;
   3253                        if(0xAA==(pkt->cmd.Data[11]))
   3254                        { P1_7=0;//Í£Ö¹
   3255                        uartkey=0x02;
   3256                       // HalUARTWrite(HAL_UART_PORT_0,&uartkey,1);//·¢ÉäÍ£ÃüÁî 02
   3257                         for(int i=0;i<30000;i++)
   3258                           for(int i=0;i<100;i++)
   3259                             asm("NOP");
   3260                          P1_6=1;//¿ª
   3261                          uartkey=0x01;
   3262                           HalUARTWrite(HAL_UART_PORT_0,&uartkey,1);//·¢Éä¿ªÃüÁî 01
   3263                    GenericApp_BX=200;
   3264                    GenericApp_ON_OFF=0XAA;
   3265                        }
   3266                        if(0xA1==(pkt->cmd.Data[11]))
   3267                        { if(GenericApp_ON_OFF==0XA2)
   3268                          {P1_6=0;//Í£Ö¹
   3269                         for(int i=0;i<30000;i++)
   3270                           for(int i=0;i<100;i++)
   3271                             asm("NOP");
   3272                          P1_7=1;//¿ª
   3273                         GenericApp_BX=50;
   3274                         GenericApp_ON_OFF=0XA1;
   3275                        }
   3276                        if(GenericApp_ON_OFF==0XAA)
   3277                          {P1_6=0;//Í£Ö¹
   3278                         for(int i=0;i<30000;i++)
   3279                           for(int i=0;i<100;i++)
   3280                             asm("NOP");
   3281                          P1_7=1;//¿ª
   3282                         GenericApp_BX=100;
   3283                         GenericApp_ON_OFF=0XA1;
   3284                        }
   3285                        if(GenericApp_ON_OFF==0XBB)
   3286                          {P1_7=0;//Í£Ö¹
   3287                         for(int i=0;i<30000;i++)
   3288                           for(int i=0;i<100;i++)
   3289                             asm("NOP");
   3290                          P1_6=1;//¿ª
   3291                         GenericApp_BX=50;
   3292                         GenericApp_ON_OFF=0XA1;
   3293                        }
   3294                        }
   3295                         if(0xA2==(pkt->cmd.Data[11]))
   3296                        { if(GenericApp_ON_OFF==0XA1)
   3297                          {P1_7=0;//Í£Ö¹
   3298                         for(int i=0;i<30000;i++)
   3299                           for(int i=0;i<100;i++)
   3300                             asm("NOP");
   3301                          P1_6=1;//¿ª
   3302                         GenericApp_BX=50;
   3303                         GenericApp_ON_OFF=0XA2;
   3304                        }
   3305                        if(GenericApp_ON_OFF==0XAA)
   3306                          {P1_6=0;//Í£Ö¹
   3307                         for(int i=0;i<30000;i++)
   3308                           for(int i=0;i<100;i++)
   3309                             asm("NOP");
   3310                          P1_7=1;//¿ª
   3311                         GenericApp_BX=50;
   3312                         GenericApp_ON_OFF=0XA2;
   3313                        }
   3314                         if(GenericApp_ON_OFF==0XBB)
   3315                          {P1_7=0;//Í£Ö¹
   3316                         for(int i=0;i<30000;i++)
   3317                           for(int i=0;i<100;i++)
   3318                             asm("NOP");
   3319                          P1_6=1;//¿ª
   3320                         GenericApp_BX=100;
   3321                         GenericApp_ON_OFF=0XA2;
   3322                        }
   3323                        }
   3324                        if((pkt->cmd.Data[11])==0xBB)
   3325                        { uartkey=0x02;
   3326                          // HalUARTWrite(HAL_UART_PORT_0,&uartkey,1);//·¢ÉäÍ£ÃüÁî 02
   3327                          P1_6=0; //Í£Ö¹
   3328                            for(int i=0;i<30000;i++)
   3329                              for(int i=0;i<100;i++)
   3330                             asm("NOP");
   3331                          P1_7=1;   //¹Ø
   3332                          uartkey=0x03;
   3333                           HalUARTWrite(HAL_UART_PORT_0,&uartkey,1);//·¢Éä¹ÜÃüÁî 03
   3334                          GenericApp_BX=200;
   3335                       GenericApp_ON_OFF=0XBB;
   3336                        }
   3337                         if((pkt->cmd.Data[11])==0xCC)
   3338                         {uartkey=0x02;
   3339                           HalUARTWrite(HAL_UART_PORT_0,&uartkey,1);//·¢ÉäÍ£ÃüÁî 02
   3340                           P1_7=0;   //Í£Ö¹
   3341                          P1_6=0;  //Í£Ö¹
   3342                         }
   3343                      }
   3344                   }
   3345                  GenericApp_SendTheMessage();
   3346                } 
   3347                }  
   3348          #endif
   3349          #if(SENSOR_TYPE ==0X06)
   3350              uint8 DD[3]={0x00,0X00,0x00};
   3351          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3352                {OSAL_SET_CPU_INTO_SLEEP=1;
   3353          #if defined( ZigBee_C_R_E_IEEE )
   3354                  char GetExtAddr=0;
   3355            byte * Send_d;
   3356            Send_d=NLME_GetExtAddr();
   3357            for(int i=0;i<8;i++)
   3358            {
   3359            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3360              GetExtAddr++;
   3361            }
   3362               if(GetExtAddr==8)
   3363          #else
   3364               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3365          #endif    
   3366                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3367                  if(pkt->cmd.Data[9]==0xDD)//ÖÇÄÜÐ¡³µ
   3368                   {
   3369                     DD[0]=pkt->cmd.Data[10];
   3370                     if(!DD[0])DD[0]=0XBB;  //ÒÔÇ°ÊÇ·¢ËÍ 0x00 Ð¡³µÍ£Ö¹ ÏÖÔÚÇ¿ÖÆ¸ÄÎª 0xBBÐ¡³µÍ£Ö¹
   3371                     HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,1);
   3372                      GenericApp_applicationbuf=1;
   3373                       GenericApp_SendTheMessage();
   3374                   }
   3375                  if((pkt->cmd.Data[9]==0xEA)&&(pkt->cmd.Data[11]==0xEA))//²É¼¯ÎÂ¶ÈÃüÁî
   3376                  {uint8 hr[15]={0};
   3377                   for(int i=0;i<(pkt->cmd.Data[10]+3);i++)
   3378                     hr[i]=pkt->cmd.Data[9+i];
   3379                     unsigned int  data;						    
   3380                     float Temperature;
   3381                     Temperature = ReadTemperature();             //·µ»Ø16Î»¶þ½øÖÆÊý
   3382                     Temperature *= CelsiurPerLSB;		//×ª»»³É¸¡µãÐÍÎÂ¶ÈÖµ(ÉãÊÏ¶È)
   3383                     data=(unsigned int)(100*Temperature);   
   3384                     hr[2]=(uint8)(data/ 100);
   3385                      if(hr[2]>0x30)
   3386                      { Temperature = ReadTemperature();             //·µ»Ø16Î»¶þ½øÖÆÊý
   3387                     Temperature *= CelsiurPerLSB;		//×ª»»³É¸¡µãÐÍÎÂ¶ÈÖµ(ÉãÊÏ¶È)
   3388                     data=(unsigned int)(100*Temperature);   
   3389                     hr[2]=(uint8)(data/ 100);
   3390                      }
   3391                      hr[1]=pkt->cmd.Data[10];
   3392                     if(hr[2]<0x30)
   3393                     {
   3394                     if((pkt->cmd.Data[10]))
   3395                     HalUARTWrite(HAL_UART_PORT_0, (uint8*)hr,(pkt->cmd.Data[10]+3));
   3396                     GenericApp_applicationbuf=2; 
   3397                     Send_data[8]=hr[2];
   3398                     GenericApp_SendTheMessage();
   3399                     }
   3400                   }
   3401                } 
   3402                   OSAL_SET_CPU_INTO_SLEEP=0;
   3403                }
   3404          #endif
   3405          #if(SENSOR_TYPE ==0X07)
   3406          
   3407          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3408                {OSAL_SET_CPU_INTO_SLEEP=1;
   3409          #if defined( ZigBee_C_R_E_IEEE )
   3410                  char GetExtAddr=0;
   3411            byte * Send_d;
   3412            Send_d=NLME_GetExtAddr();
   3413            for(int i=0;i<8;i++)
   3414            {
   3415            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3416              GetExtAddr++;
   3417            }
   3418               if(GetExtAddr==8)
   3419          #else
   3420               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3421          #endif    
   3422                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3423                  if(pkt->cmd.Data[9]==0xA1)
   3424                   { AB=0X0B;
   3425                     HalUARTWrite(HAL_UART_PORT_0, &pkt->cmd.Data[11],pkt->cmd.Data[10]);
   3426                   }
   3427                } 
   3428                }
   3429          #endif
   3430          #if(SENSOR_TYPE ==0X09)
   3431              char DD[3]={0x00,0X00,0x00};
   3432          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3433                {OSAL_SET_CPU_INTO_SLEEP=1;
   3434          #if defined( ZigBee_C_R_E_IEEE )
   3435                  char GetExtAddr=0;
   3436            byte * Send_d;
   3437            Send_d=NLME_GetExtAddr();
   3438            for(int i=0;i<8;i++)
   3439            {
   3440            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3441              GetExtAddr++;
   3442            }
   3443               if(GetExtAddr==8)
   3444          #else
   3445               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3446          #endif    
   3447                {  T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3448                  //¿ª¹ØÁ¿                  //ÊýÂë¹Ü                  //²½½øµç»ú
   3449                  if((pkt->cmd.Data[9]==0xDD)||(pkt->cmd.Data[9]==0xEA)||(pkt->cmd.Data[9]==0xEB))
   3450                   {
   3451                     DD[0]=pkt->cmd.Data[9];
   3452                     DD[1]=pkt->cmd.Data[10];
   3453                     DD[2]=pkt->cmd.Data[11];
   3454                     HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,3);
   3455                      GenericApp_applicationbuf=1;
   3456                       GenericApp_SendTheMessage();
   3457                   }
   3458                } 
   3459                   OSAL_SET_CPU_INTO_SLEEP=0;
   3460                }
   3461          #endif
   3462          #if(SENSOR_TYPE ==0X13)
   3463          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3464                { 
   3465          #if defined( ZigBee_C_R_E_IEEE )
   3466            char GetExtAddr=0;
   3467            byte * Send_d;
   3468            Send_d=NLME_GetExtAddr();
   3469            for(int i=0;i<8;i++)
   3470            {
   3471            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3472              GetExtAddr++;
   3473            }
   3474               if(GetExtAddr==8)
   3475          #else
   3476               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3477          #endif    
   3478                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3479                  if((pkt->cmd.Data[9]==0X43)&&(pkt->cmd.Data[10]==0XC3)&&(pkt->cmd.Data[11]==0X6F))//¶ÁÓÐ¹¦µç×ÜÁ¿
   3480                   {
   3481                     GenericApp_applicationbuf=60001;
   3482                      GenericApp_time=0;
   3483                   }
   3484                }
   3485                }  
   3486          #endif  
   3487          
   3488          #if(SENSOR_TYPE ==0XF0)
   3489          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3490                { 
   3491          #if defined( ZigBee_C_R_E_IEEE )
   3492            char GetExtAddr=0;
   3493            byte * Send_d;
   3494            Send_d=NLME_GetExtAddr();
   3495            for(int i=0;i<8;i++)
   3496            {
   3497            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3498              GetExtAddr++;
   3499            }
   3500               if(GetExtAddr==8)
   3501          #else
   3502               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3503          #endif    
   3504                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3505                  HalUARTWrite(HAL_UART_PORT_0,&pkt->cmd.Data[9],1);
   3506                  GenericApp_applicationbuf=1;
   3507                  GenericApp_SendTheMessage();
   3508                }
   3509                }  
   3510          #endif  
   3511          #if(SENSOR_TYPE ==0X70)
   3512          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3513                { 
   3514          #if defined( ZigBee_C_R_E_IEEE )
   3515            char GetExtAddr=0;
   3516            byte * Send_d;
   3517            Send_d=NLME_GetExtAddr();
   3518            for(int i=0;i<8;i++)
   3519            {
   3520            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3521              GetExtAddr++;
   3522            }
   3523               if(GetExtAddr==8)
   3524          #else
   3525               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3526          #endif    
   3527                   {
   3528                  T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3529                  GenericApp_applicationdata=0;
   3530                  P1_0=1; 
   3531                  GenericApp_uart_485=0;
   3532                   if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0F))
   3533                {
   3534                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3535                  // Send_datalend=14;for(char i=0;i<11;i++)Send_data[8+i]=pkt->cmd.Data[10+i];
   3536                 //   Send_data[8]=0XF1; Send_data[12]=((Send_data[12]&0XF0)|0X0A);
   3537                   // GenericApp_SendTheMessage();
   3538                }
   3539                if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0E))
   3540                {
   3541                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3542                   // Send_datalend=14;for(char i=0;i<11;i++)Send_data[8+i]=pkt->cmd.Data[10+i];
   3543                   // Send_data[8]=0XF1; Send_data[12]=((Send_data[12]&0XF0)|0X0A);
   3544                  //  GenericApp_SendTheMessage();
   3545                }
   3546                } 
   3547                }  
   3548          #endif  
   3549          #if(SENSOR_TYPE ==0X74)
   3550          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3551                { 
   3552          #if defined( ZigBee_C_R_E_IEEE )
   3553            char GetExtAddr=0;
   3554            byte * Send_d;
   3555            Send_d=NLME_GetExtAddr();
   3556            for(int i=0;i<8;i++)
   3557            {
   3558             if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3559              GetExtAddr++;
   3560            }
   3561               if(GetExtAddr==8)
   3562          #else
   3563               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3564          #endif    
   3565                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3566                  if((pkt->cmd.Data[9]==0X01)&&(pkt->cmd.Data[11]<=0X10))
   3567                   {GenericApp_applicationbuf=60001;//Ó¦´ð
   3568                    HalUARTWrite(HAL_UART_PORT_0, &pkt->cmd.Data[12],pkt->cmd.Data[11]);
   3569                   }
   3570                }
   3571                }  
   3572          #endif  
   3573          #if(SENSOR_TYPE ==0X14)
   3574          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3575                { 
   3576          #if defined( ZigBee_C_R_E_IEEE )
   3577            char GetExtAddr=0;
   3578            byte * Send_d;
   3579            Send_d=NLME_GetExtAddr();
   3580            for(int i=0;i<8;i++)
   3581            {
   3582             if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3583              GetExtAddr++;
   3584            }
   3585               if(GetExtAddr==8)
   3586          #else
   3587               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3588          #endif    
   3589                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3590                  if((pkt->cmd.Data[9]==0X01)&&(pkt->cmd.Data[10]==0X03)&&(pkt->cmd.Data[11]==0X0C))//¶ÁÓÐ¹¦µç×ÜÁ¿
   3591                   {     GenericApp_applicationbuf=60001;
   3592                          GenericApp_time=0;
   3593          
   3594                   //uint8  hr[8]={0x01,0x03,0x00,0x00,0x00,0x0C,0xA5,0xE2};
   3595                        //  HalUARTWrite(HAL_UART_PORT_0, hr,8);
   3596                   }
   3597                }
   3598                }  
   3599          #endif  
   3600          
   3601          #if(SENSOR_TYPE ==0X15)
   3602          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3603                { 
   3604          #if defined( ZigBee_C_R_E_IEEE )
   3605            char GetExtAddr=0;
   3606            byte * Send_d;
   3607            Send_d=NLME_GetExtAddr();
   3608            for(int i=0;i<8;i++)
   3609            {
   3610            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3611              GetExtAddr++;
   3612            }
   3613               if(GetExtAddr==8)
   3614          #else
   3615               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3616          #endif    
   3617                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3618                  if(pkt->cmd.Data[9]==0xDD)//
   3619                   {GenericApp_applicationbuf=1;
   3620                     if(pkt->cmd.Data[10]==0x01)  
   3621                      {
   3622                        P1_1=0;  
   3623                      }
   3624                     if(pkt->cmd.Data[10]==0x02)  
   3625                      {
   3626                        P1_2=0;  
   3627                      }
   3628                     if(pkt->cmd.Data[10]==0x03)  
   3629                      {
   3630                        P1_3=0;  
   3631                      }
   3632                      if(pkt->cmd.Data[10]==0x04)  
   3633                      {
   3634                        P1_4=0;  
   3635                      }
   3636                     GenericApp_SendTheMessage();
   3637                   }
   3638                  
   3639                }
   3640                }  
   3641          #endif  
   3642             
   3643          #if(SENSOR_TYPE =='H')
   3644          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3645                {
   3646          #if defined( ZigBee_C_R_E_IEEE )
   3647                  char GetExtAddr=0;
   3648            byte * Send_d;
   3649            Send_d=NLME_GetExtAddr();
   3650            for(int i=0;i<8;i++)
   3651            {
   3652            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3653              GetExtAddr++;
   3654            }
   3655               if(GetExtAddr==8)
   3656          #else
   3657               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3658          #endif    
   3659                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3660                  if(pkt->cmd.Data[9]==0xDD)//¿ØÖÆ220V¼ÌµçÆ÷
   3661                   {GenericApp_applicationbuf=1;
   3662                     if(pkt->cmd.Data[10]==0x01)  
   3663                      {
   3664                        if(0xAA==pkt->cmd.Data[11])
   3665                        { P1_0=0;   //¿ª¼ÌµçÆ÷
   3666                        }if(pkt->cmd.Data[11]==0xBB)
   3667                        P1_0=1;   //¹Ø¼ÌµçÆ÷
   3668                      }
   3669                     if(pkt->cmd.Data[10]==0xC0)  
   3670                      {  
   3671                        if(0xAA==pkt->cmd.Data[11])
   3672                        { P1_7=1;   P1_6=0;}   //´°Á±¿ª
   3673                        if(pkt->cmd.Data[11]==0xBB)
   3674                        {  P1_6=1; P1_7=0;}   //´°Á±¹Ø
   3675                      }
   3676                   }
   3677                 if(pkt->cmd.Data[9]==0xCC)//¼ì²âÉè±¸
   3678                   {
   3679                    GenericApp_applicationbuf=2;
   3680                   }
   3681                   GenericApp_SendTheMessage();
   3682                } 
   3683                }  
   3684          #endif
   3685          #if(SENSOR_TYPE ==0X7C)
   3686          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3687                { 
   3688          #if defined( ZigBee_C_R_E_IEEE )
   3689                  char GetExtAddr=0;
   3690            byte * Send_d;
   3691            Send_d=NLME_GetExtAddr();
   3692            for(int i=0;i<8;i++)
   3693            {
   3694            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3695              GetExtAddr++;
   3696            }
   3697               if(GetExtAddr==8)
   3698          #else
   3699               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3700          #endif    
   3701                { //uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   3702                  T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3703                  GenericApp_applicationdata=0;
   3704                   if((pkt->cmd.Data[11]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[12]==0X0F))
   3705                {
   3706                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[11]),pkt->cmd.Data[12]+2);
   3707                }
   3708                if((pkt->cmd.Data[11]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[12]==0X0E))
   3709                {
   3710                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[11]),pkt->cmd.Data[12]+2);
   3711                }
   3712                } 
   3713          }  
   3714          #endif
   3715          #if(SENSOR_TYPE ==0X25)
   3716          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3717                { 
   3718          #if defined( ZigBee_C_R_E_IEEE )
   3719                  char GetExtAddr=0;
   3720            byte * Send_d;
   3721            Send_d=NLME_GetExtAddr();
   3722            for(int i=0;i<8;i++)
   3723            {
   3724            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3725              GetExtAddr++;
   3726            }
   3727               if(GetExtAddr==8)
   3728          #else
   3729               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3730          #endif    
   3731                { //uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   3732                  T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3733                  GenericApp_applicationdata=0;
   3734                   if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0F))
   3735                {
   3736                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3737                }
   3738                if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0E))
   3739                {
   3740                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3741                }
   3742                } 
   3743          }  
   3744          #endif
   3745          
   3746          #if(SENSOR_TYPE ==0X7B)
   3747          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3748                { 
   3749          #if defined( ZigBee_C_R_E_IEEE )
   3750                  char GetExtAddr=0;
   3751            byte * Send_d;
   3752            Send_d=NLME_GetExtAddr();
   3753            for(int i=0;i<8;i++)
   3754            {
   3755            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3756              GetExtAddr++;
   3757            }
   3758               if(GetExtAddr==8)
   3759          #else
   3760               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3761          #endif    
   3762                { //uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   3763                  T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3764                  GenericApp_applicationdata=0;
   3765                   if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0F))
   3766                {
   3767                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3768                }
   3769                if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0E))
   3770                {
   3771                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3772                }
   3773                } 
   3774          }  
   3775          #endif
   3776          #if(SENSOR_TYPE ==0X71)
   3777          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3778                { 
   3779          #if defined( ZigBee_C_R_E_IEEE )
   3780                  char GetExtAddr=0;
   3781            byte * Send_d;
   3782            Send_d=NLME_GetExtAddr();
   3783            for(int i=0;i<8;i++)
   3784            {
   3785            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3786              GetExtAddr++;
   3787            }
   3788               if(GetExtAddr==8)
   3789          #else
   3790               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3791          #endif    
   3792                { //uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   3793                  T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3794                  GenericApp_applicationdata=0;
   3795                   if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0F))
   3796                { if((pkt->cmd.Data[12]==0xAA)||(pkt->cmd.Data[12]==0xBB))
   3797                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3798                  else
   3799                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[14]),1);
   3800                  //HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3801                }
   3802                if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0E))
   3803                {if((pkt->cmd.Data[12]==0xAA)||(pkt->cmd.Data[12]==0xBB))
   3804                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3805                  else
   3806                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[14]),1);
   3807                  //HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3808                }
   3809                } 
   3810          }  
   3811          #endif
   3812          
   3813          #if(SENSOR_TYPE ==0X0A)
   3814          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3815                { 
   3816          #if defined( ZigBee_C_R_E_IEEE )
   3817                  char GetExtAddr=0;
   3818            byte * Send_d;
   3819            Send_d=NLME_GetExtAddr();
   3820            for(int i=0;i<8;i++)
   3821            {
   3822            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3823              GetExtAddr++;
   3824            }
   3825               if(GetExtAddr==8)
   3826          #else
   3827               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3828          #endif    
   3829                { //uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   3830                 // T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3831                  GenericApp_applicationdata=0;
   3832                 if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0F))
   3833                {   HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3834                }
   3835                if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0E))
   3836                {   HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3837                }
   3838                } 
   3839          }  
   3840          #endif
   3841          #if(SENSOR_TYPE ==0X86)
   3842          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3843                { 
   3844          #if defined( ZigBee_C_R_E_IEEE )
   3845                  char GetExtAddr=0;
   3846            byte * Send_d;
   3847            Send_d=NLME_GetExtAddr();
   3848            for(int i=0;i<8;i++)
   3849            {
   3850            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3851              GetExtAddr++;
   3852            }
   3853               if(GetExtAddr==8)
   3854          #else
   3855               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3856          #endif    
   3857                { //uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   3858                  T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3859                  GenericApp_applicationdata=0;
   3860                 if((pkt->cmd.Data[11]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[10]==0X0D))
   3861                {
   3862                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[10]+1);
   3863                }
   3864                if((pkt->cmd.Data[11]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[10]==0X0E))
   3865                {
   3866                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[10]+1);
   3867                }
   3868                } 
   3869          }  
   3870          #endif
   3871          #if(SENSOR_TYPE ==0X87)
   3872          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3873                { 
   3874          #if defined( ZigBee_C_R_E_IEEE )
   3875                  char GetExtAddr=0;
   3876            byte * Send_d;
   3877            Send_d=NLME_GetExtAddr();
   3878            for(int i=0;i<8;i++)
   3879            {
   3880            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3881              GetExtAddr++;
   3882            }
   3883               if(GetExtAddr==8)
   3884          #else
   3885               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3886          #endif    
   3887                { //uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   3888                  T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3889                  GenericApp_applicationdata=0;
   3890                  if((pkt->cmd.Data[12]=='{')&&((pkt->cmd.Data[1]-pkt->cmd.Data[11])==0X0E))//07H {M1:00}
   3891                {
   3892                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[12]),pkt->cmd.Data[11]);
   3893                }
   3894                if((pkt->cmd.Data[12]=='{')&&((pkt->cmd.Data[1]-pkt->cmd.Data[11])==0X0F))
   3895                {
   3896                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[12]),pkt->cmd.Data[11]);
   3897                }
   3898                } 
   3899          }  
   3900          #endif
   3901          #if(SENSOR_TYPE ==0X26)
   3902          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3903                { 
   3904          #if defined( ZigBee_C_R_E_IEEE )
   3905                  char GetExtAddr=0;
   3906            byte * Send_d;
   3907            Send_d=NLME_GetExtAddr();
   3908            for(int i=0;i<8;i++)
   3909            {
   3910            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3911              GetExtAddr++;
   3912            }
   3913               if(GetExtAddr==8)
   3914          #else
   3915               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3916          #endif    
   3917                { //uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   3918                  T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3919                  GenericApp_applicationdata=0;
   3920                   if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0F))
   3921                {
   3922                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3923                }
   3924                if((pkt->cmd.Data[10]==0xF7)&&(pkt->cmd.Data[1]-pkt->cmd.Data[11]==0X0E))
   3925                {
   3926                  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3927                }
   3928                } 
   3929          }  
   3930          #endif
   3931          #if(SENSOR_TYPE ==0X27)
   3932          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3933                { 
   3934          #if defined( ZigBee_C_R_E_IEEE )
   3935                  char GetExtAddr=0;
   3936            byte * Send_d;
   3937            Send_d=NLME_GetExtAddr();
   3938            for(int i=0;i<8;i++)
   3939            {
   3940            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3941              GetExtAddr++;
   3942            }
   3943               if(GetExtAddr==8)
   3944          #else
   3945               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3946          #endif    
   3947                { //uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   3948                  T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3949                  GenericApp_applicationdata=0;
   3950                  SYN_FrameInfo(0,pkt->cmd.Data[11],&pkt->cmd.Data[12],pkt->cmd.Data[1]-0X0E) ;
   3951                //  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   3952                  
   3953                } 
   3954          }  
   3955          #endif
   3956          
   3957          #if(SENSOR_TYPE ==0X28)
   3958          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3959                { 
   3960          #if defined( ZigBee_C_R_E_IEEE )
   3961                  char GetExtAddr=0;
   3962            byte * Send_d;
   3963            Send_d=NLME_GetExtAddr();
   3964            for(int i=0;i<8;i++)
   3965            {
   3966            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3967              GetExtAddr++;
   3968            }
   3969               if(GetExtAddr==8)
   3970          #else
   3971               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   3972          #endif    
   3973                { //uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   3974                  T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   3975          
   3976                   if((pkt->cmd.Data[9])==0XA1)
   3977                   {LCD_Init();   // LCD³õÊ¼»¯
   3978                    LCD_Clear();  // LCDÇåÆÁ
   3979                    /* ÏÔÊ¾ÐÅÏ¢ */
   3980                    LCD_WriteStringL(0,pkt->cmd.Data[11],&pkt->cmd.Data[12],pkt->cmd.Data[1]-14);
   3981                   }
   3982                 
   3983                  GenericApp_switch=1;
   3984                  GenericApp_SendTheMessage();
   3985                } 
   3986          }  
   3987          #endif
   3988          #if(SENSOR_TYPE ==0X6F)
   3989          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   3990                { 
   3991          #if defined( ZigBee_C_R_E_IEEE )
   3992                  char GetExtAddr=0;
   3993            byte * Send_d;
   3994            Send_d=NLME_GetExtAddr();
   3995            for(int i=0;i<8;i++)
   3996            {
   3997            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   3998              GetExtAddr++;
   3999            }
   4000               if(GetExtAddr==8)
   4001          #else
   4002               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   4003          #endif    
   4004                { //uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   4005                  T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   4006                   if(((pkt->cmd.Data[10])&0x0F)==0X00)
   4007                   { lcd_txt_clr(); 
   4008                   hzkdis_b(0,&pkt->cmd.Data[12],(pkt->cmd.Data[1]-0X0E)<64? (pkt->cmd.Data[1]-0X0E):64);
   4009                   }
   4010                   if(((pkt->cmd.Data[10])&0x0F)==0X01)
   4011                   { hzkdis_b(1,"                                                2",48);
   4012                   hzkdis_b(1,&pkt->cmd.Data[12],(pkt->cmd.Data[1]-0X0E)<48? (pkt->cmd.Data[1]-0X0E):48);
   4013                   }
   4014                  if(((pkt->cmd.Data[10])&0x0F)==0X02)
   4015                  {hzkdis_b(1,"                                 2",32);
   4016                    hzkdis_b(2,&pkt->cmd.Data[12],(pkt->cmd.Data[1]-0X0E)<32? (pkt->cmd.Data[1]-0X0E):32);
   4017                  }
   4018                  if(((pkt->cmd.Data[10])&0x0F)==0X03)
   4019                  {hzkdis_b(1,"                  2",16);
   4020                    hzkdis_b(3,&pkt->cmd.Data[12],(pkt->cmd.Data[1]-0X0E)<16? (pkt->cmd.Data[1]-0X0E):16);
   4021                  }
   4022                  if(((pkt->cmd.Data[10])&0xF0)==0XA0)
   4023                  SYN_FrameInfo(0,pkt->cmd.Data[11],&pkt->cmd.Data[12],pkt->cmd.Data[1]-0X0E) ;
   4024                //  HalUARTWrite(HAL_UART_PORT_0, &(pkt->cmd.Data[10]),pkt->cmd.Data[11]+2);
   4025                  GenericApp_switch=1;
   4026                  GenericApp_SendTheMessage();
   4027                } 
   4028          }  
   4029          #endif
   4030          #if(SENSOR_TYPE =='P')
   4031              uint8  hr[8]={0X01,0x03,0x06,0X80,0X00,0X89,0X0D,0X0A};
   4032          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   4033                { 
   4034          #if defined( ZigBee_C_R_E_IEEE )
   4035                  char GetExtAddr=0;
   4036            byte * Send_d;
   4037            Send_d=NLME_GetExtAddr();
   4038            for(int i=0;i<8;i++)
   4039            {
   4040            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   4041              GetExtAddr++;
   4042            }
   4043               if(GetExtAddr==8)
   4044          #else
   4045               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   4046          #endif    
   4047                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   4048                  GenericApp_applicationbuf=1;
   4049                   hr[3]=pkt->cmd.Data[9];
   4050                    hr[4]=pkt->cmd.Data[10];
   4051                    hr[5]=0x09+hr[3]+hr[4];
   4052                     HalUARTWrite(HAL_UART_PORT_0, hr,8);
   4053                     GenericApp_SendTheMessage();
   4054                } 
   4055                }  
   4056          #endif
   4057          #if(SENSOR_TYPE ==0X02)
   4058              uint8  hr[2]={0XFF,0x10};
   4059          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   4060                { 
   4061          #if defined( ZigBee_C_R_E_IEEE )
   4062                  char GetExtAddr=0;
   4063            byte * Send_d;
   4064            Send_d=NLME_GetExtAddr();
   4065            for(int i=0;i<8;i++)
   4066            {
   4067            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   4068              GetExtAddr++;
   4069            }
   4070               if(GetExtAddr==8)
   4071          #else
   4072               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   4073          #endif    
   4074                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   4075                  if(pkt->cmd.Data[9]==0XDC)
   4076                  { GenericApp_applicationbuf=1;
   4077                   //hr[0]=pkt->cmd.Data[9];
   4078                    hr[0]=pkt->cmd.Data[10];
   4079                    hr[1]=pkt->cmd.Data[11];
   4080                     HalUARTWrite(HAL_UART_PORT_0, hr,1);
   4081                   }
   4082                  GenericApp_SendTheMessage();
   4083                }  
   4084                }  
   4085          #endif
   4086          #if(SENSOR_TYPE =='K')
   4087          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   4088                { 
   4089          #if defined( ZigBee_C_R_E_IEEE )
   4090            char GetExtAddr=0;
   4091            byte * Send_d;
   4092            Send_d=NLME_GetExtAddr();
   4093            for(int i=0;i<8;i++)
   4094            {
   4095            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   4096              GetExtAddr++;
   4097            }
   4098               if(GetExtAddr==8)
   4099          #else
   4100               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   4101          #endif    
   4102                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   4103                  if(pkt->cmd.Data[9]==0xDD)//¿ØÖÆ220V¼ÌµçÆ÷
   4104                   {GenericApp_applicationbuf=1;
   4105                     if(pkt->cmd.Data[10]==0x01)  
   4106                      {if(pkt->cmd.Data[11]==0xAA)
   4107                      {P1_0=0;T_MG=0X01; }   //¿ª¼ÌµçÆ÷
   4108                       if(pkt->cmd.Data[11]==0xBB)
   4109                       {P1_0=1; T_MG=0X00; }  //¹Ø¼ÌµçÆ÷
   4110                        if(pkt->cmd.Data[11]==0xCC)
   4111                       {P1_0=0; T_MG=0X75; }  //¹Ø¼ÌµçÆ÷¿ª 0X75  10Ãë¹Ø±Õ
   4112                      }
   4113                   }
   4114                  if(pkt->cmd.Data[9]==0xEF)//¿ØÖÆ220V¼ÌµçÆ÷
   4115                   {GenericApp_applicationbuf=1;
   4116                     if(pkt->cmd.Data[11]<=0x01)  
   4117                        T_MG=0x0A; //¹Ø¼ÌµçÆ÷¿ª  1Ãë¹Ø±Õ
   4118                     else T_MG=pkt->cmd.Data[11]; //¹Ø¼ÌµçÆ÷¿ª  T_MG*80ms¹Ø±Õ
   4119                   if(pkt->cmd.Data[10]==0x01)  
   4120                     P1_0=0; 
   4121                   }
   4122                 if(pkt->cmd.Data[9]==0xCC)//¼ì²âÉè±¸
   4123                   {
   4124                    GenericApp_applicationbuf=2;
   4125                   }
   4126                  GenericApp_SendTheMessage();
   4127                }
   4128                }  
   4129          #endif  
   4130          #if(SENSOR_TYPE ==0X79)
   4131          
   4132          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   4133                { 
   4134          #if defined( ZigBee_C_R_E_IEEE )
   4135            char GetExtAddr=0;
   4136            byte * Send_d;
   4137            Send_d=NLME_GetExtAddr();
   4138            for(int i=0;i<8;i++)
   4139            {
   4140            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   4141              GetExtAddr++;
   4142            }
   4143               if(GetExtAddr==8)
   4144          #else
   4145               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   4146          #endif    
   4147                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   4148                  if(pkt->cmd.Data[10]==0xDD)//¿ØÖÆ
   4149                   {
   4150                     if(pkt->cmd.Data[11]>0)  
   4151                      {
   4152                        switch (pkt->cmd.Data[11]) 
   4153              { case 0X01:if((pkt->cmd.Data[12])&0X01)P1_0=0;else P1_0=1;
   4154                          break;
   4155                case 0X02:if((pkt->cmd.Data[12])&0X02)P1_5=0;else P1_5=1;
   4156                          break;
   4157                case 0X03:if((pkt->cmd.Data[12])&0X01)P1_0=0;else P1_0=1;if((pkt->cmd.Data[12])&0X02)P1_5=0;else P1_5=1;
   4158                          break;
   4159                 default: break;
   4160              }
   4161                      }
   4162                    Send_data[7]=0X02;
   4163                    Send_data[8]=0XDD;
   4164                    Send_data[9]=P1_5;
   4165                     Send_data[9]=~((((Send_data[9]<<1)+P1_0)&0X03)|0XFC);
   4166                    Send_datalend=0x04;
   4167                    GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   4168                   }
   4169                   if(pkt->cmd.Data[10]==0xD1)//ÎÂÊª¶È
   4170                   {PDI=0XD1;
   4171                   }
   4172                   if(pkt->cmd.Data[10]==0xD2)//AD²É¼¯
   4173                   {PDI=0XD2;
   4174                   }
   4175                 // GenericApp_SendTheMessage();
   4176                }
   4177                }  
   4178          #endif  
   4179          #if(SENSOR_TYPE ==0X83)
   4180          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   4181                { 
   4182          #if defined( ZigBee_C_R_E_IEEE )
   4183            char GetExtAddr=0;
   4184            byte * Send_d;
   4185            Send_d=NLME_GetExtAddr();
   4186            for(int i=0;i<8;i++)
   4187            {
   4188            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   4189              GetExtAddr++;
   4190            }
   4191               if(GetExtAddr==8)
   4192          #else
   4193               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   4194          #endif    
   4195                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   4196                  if(pkt->cmd.Data[10]==0xDD)//¿ØÖÆ220V¼ÌµçÆ÷
   4197                   {GenericApp_applicationbuf=1;
   4198                     if(pkt->cmd.Data[11]>0)  
   4199                      {
   4200                        PDI=((P1&(~(pkt->cmd.Data[11])))|((~((pkt->cmd.Data[11])&(pkt->cmd.Data[12]))))&(pkt->cmd.Data[11]));
   4201                        P1=PDI;
   4202                      }
   4203                   }
   4204                  GenericApp_SendTheMessage();
   4205                }
   4206                }  
   4207          #endif  
   4208          #if(SENSOR_TYPE ==0X40)
   4209          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   4210                { 
   4211          #if defined( ZigBee_C_R_E_IEEE )
   4212            char GetExtAddr=0;
   4213            byte * Send_d;
   4214            Send_d=NLME_GetExtAddr();
   4215            for(int i=0;i<8;i++)
   4216            { 
   4217            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   4218              GetExtAddr++;
   4219            }
   4220               if(GetExtAddr==8)
   4221          #else
   4222               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   4223          #endif    
   4224                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   4225                  if(pkt->cmd.Data[9]==0xDD)//
   4226                   {GenericApp_applicationbuf=1;
   4227                   if(pkt->cmd.Data[10]!=0XB1)T_MG=0X00;
   4228                switch (pkt->cmd.Data[10]) 
   4229              { case 0XA1:if(pkt->cmd.Data[11]==0xAA){ P1_3=0; P1_4=1;  }  //LED1 ºìÉ« µãÁÁ
   4230                          if(pkt->cmd.Data[11]==0xBB){P1_3=1;P1_4=0;  }  //LED1 ºìÉ« Ï¨Ãð
   4231                          break;
   4232                case 0XA2:if(pkt->cmd.Data[11]==0xAA){P1_2=0; P1_7=1; }   //LED2 À¶É« µãÁÁ
   4233                          if(pkt->cmd.Data[11]==0xBB){P1_2=1;P1_7=0;}   //LED2 À¶É« Ï¨Ãð
   4234                          break;
   4235                case 0XA3: if(pkt->cmd.Data[11]==0xAA){T_MG=0X01;P1_2=1;P1_7=0;}   //LED2Ï¨Ãð LED1ÉÁË¸¹¦ÄÜ
   4236                          if(pkt->cmd.Data[11]==0xBB){T_MG=0X00;P1_3=1;P1_4=0;}   //LED1Í£Ö¹ÉÁË¸Ï¨Ãð
   4237                          break;
   4238                case 0XA4:if(pkt->cmd.Data[11]==0xAA){P1_2=1; P1_7=0; P1_3=0; P1_4=1; } //LED1´ò¿ª£¬LED2¹Ø±Õ¹¦ÄÜ
   4239                          if(pkt->cmd.Data[11]==0xBB){P1_2=1; P1_7=0; P1_3=1; P1_4=0;}//LED1£¬LED2¹Ø±Õ   
   4240                          break;
   4241                case 0XA5:if(pkt->cmd.Data[11]==0xAA){P1_2=0; P1_7=1; P1_3=1; P1_4=0; } //LED2´ò¿ª£¬LED1¹Ø±Õ¹¦ÄÜ
   4242                          if(pkt->cmd.Data[11]==0xBB){P1_2=1; P1_7=0; P1_3=1; P1_4=0;}//LED1£¬LED2¹Ø±Õ   
   4243                          break;
   4244                case 0XB1:if(pkt->cmd.Data[11]==0xAA){ P1_1=0; P1_0=1;  }   //¿ª·äÃùÆ÷
   4245                            if(pkt->cmd.Data[11]==0xBB){ P1_1=1;P1_0=0;}   //¹Ø·äÃùÆ÷
   4246                          break;
   4247                 default: break;}GenericApp_SendTheMessage();
   4248                   } 
   4249                }
   4250          }  
   4251          #endif  
   4252          #if(SENSOR_TYPE ==0X23)
   4253          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   4254                {
   4255          #if defined( ZigBee_C_R_E_IEEE )
   4256                  char GetExtAddr=0;
   4257            byte * Send_d;
   4258            Send_d=NLME_GetExtAddr();
   4259            for(int i=0;i<8;i++)
   4260            {
   4261            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   4262              GetExtAddr++;
   4263            }
   4264               if(GetExtAddr==8)
   4265          #else
   4266               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   4267          #endif    
   4268                {  T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   4269                  if(pkt->cmd.Data[9]==0xAA)//Â¼Èë
   4270                   { SFG_R30XA[0]=0X01;
   4271                     SFG_R30XA[1]=pkt->cmd.Data[10];  SFG_R30XA[2]=pkt->cmd.Data[11]; 
   4272                     SFG_R30X=1;
   4273                   }
   4274                   if(pkt->cmd.Data[9]==0xBB)//ËÑË÷
   4275                   {  SFG_R30XA[0]=0XA1;SFG_R30X=1;
   4276                    }
   4277                    if(pkt->cmd.Data[9]==0xCC)//É¾³ý
   4278                   {  SFG_R30XA[0]=0X21;
   4279                    SFG_R30XA[1]=pkt->cmd.Data[10];  SFG_R30XA[2]=pkt->cmd.Data[11]; 
   4280                   SFG_R30X=1;
   4281                   }
   4282                }
   4283                }
   4284          #endif
   4285          #if(SENSOR_TYPE ==0X12)
   4286          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   4287                { 
   4288          #if defined( ZigBee_C_R_E_IEEE )
   4289            char GetExtAddr=0;
   4290            byte * Send_d;
   4291            Send_d=NLME_GetExtAddr();
   4292            for(int i=0;i<8;i++)
   4293            {
   4294            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   4295              GetExtAddr++;
   4296            }
   4297               if(GetExtAddr==8)
   4298          #else
   4299               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   4300          #endif    
   4301                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   4302                  if(pkt->cmd.Data[9]==0xDD)//
   4303                   {GenericApp_applicationbuf=1;
   4304                     if(pkt->cmd.Data[10]==0x01)  
   4305                      {if(pkt->cmd.Data[11]==0xAA)
   4306                         P1_0=0;   //¿ª¼ÌµçÆ÷
   4307                       if(pkt->cmd.Data[11]==0xDD)
   4308                          GenericApp_applicationbuf=6001;
   4309                         
   4310                        P1_7=1;
   4311                        P1_6=0;   //´°Á±¿ª
   4312                         GenericApp_BX=0;
   4313                         GenericApp_ON_OFF=0;
   4314                      }
   4315                   }
   4316                  GenericApp_SendTheMessage();
   4317                }
   4318                }  
   4319          #endif  
   4320          #if(SENSOR_TYPE ==0X18)
   4321          if((pkt->cmd.Data[0]==0xFD)&&(pkt->cmd.Data[6]==SENSOR_TYPE))
   4322                { 
   4323          #if defined( ZigBee_C_R_E_IEEE )
   4324            char GetExtAddr=0;
   4325            byte * Send_d;
   4326            Send_d=NLME_GetExtAddr();
   4327            for(int i=0;i<8;i++)
   4328            {
   4329            if(pkt->cmd.Data[i+pkt->cmd.Data[1]-2]==(*Send_d++))
   4330              GetExtAddr++;
   4331            }
   4332               if(GetExtAddr==8)
   4333          #else
   4334               if((pkt->cmd.Data[7]==Send_data[4])&&(pkt->cmd.Data[8]==Send_data[5]))
   4335          #endif    
   4336                {T_MGSbit|=0X20; //xx1x xxx0 Ó¦´ð Õý³£ ×´Ì¬Î»
   4337                  if(pkt->cmd.Data[9]==0xDD)//
   4338                   {GenericApp_applicationbuf=1;
   4339                     if(pkt->cmd.Data[10]==0x01)  
   4340                      {if(pkt->cmd.Data[11]==0xAA)
   4341                          GenericApp_applicationbuf=6001;
   4342                      }
   4343                   }
   4344                 // GenericApp_SendTheMessage();
   4345                }
   4346           
   4347                }  
   4348          #endif 
   4349          #endif  
   4350          }
   \   00002E   02....       LJMP    ?Subroutine1 & 0xFFFF
   4351          /*********************************************************************
   4352           * @fn      GenericApp_SendTheMessage
   4353           *
   4354           * @brief   Send "the" message.
   4355           *
   4356           * @param   none
   4357           *
   4358           * @return  none
   4359           */
   4360          #if(ZDO_COORDINATOR==2)  //ZIGBEE  ATÃüÁîÄ£Ê½ Í¸´«Ä£Ê½
   4361          void GenericApp_SendFT( void ) 
   4362          {HalLedSet ( HAL_LED_1, HAL_LED_MODE_ON );
   4363          HalLedSet ( HAL_LED_2, HAL_LED_MODE_ON );
   4364          GenericApp_DstAddr.addr.shortAddr=0XFFFF;
   4365          
   4366            if ( AF_DataRequest( &GenericApp_DstAddr, &GenericApp_epDesc,
   4367                                 GENERICAPP_CLUSTERID,
   4368                                 Send_datalend,
   4369                                 Send_data, 
   4370                                 &GenericApp_TransID,
   4371                                 AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
   4372            {HalLedSet ( HAL_LED_1, HAL_LED_MODE_OFF );
   4373              HalLedSet ( HAL_LED_2, HAL_LED_MODE_OFF );
   4374            }
   4375            
   4376          }
   4377          
   4378          #endif
   4379          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4380          void GenericApp_SendTheMessage( void ) 
   \                     GenericApp_SendTheMessage:
   4381          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   4382            HalLedSet ( HAL_LED_1, HAL_LED_MODE_ON );
   \   000005                ; Setup parameters for call to function HalLedSet
   \   000005   7A01         MOV     R2,#0x1
   \   000007   7901         MOV     R1,#0x1
   \   000009   12....       LCALL   ??HalLedSet?relay
   4383          HalLedSet ( HAL_LED_2, HAL_LED_MODE_ON );
   \   00000C                ; Setup parameters for call to function HalLedSet
   \   00000C   7A01         MOV     R2,#0x1
   \   00000E   7902         MOV     R1,#0x2
   \   000010   12....       LCALL   ??HalLedSet?relay
   4384          #if defined( SENSOR_TYPE_Coord )
   4385          #if defined( ZigBee_C_R_E_Engineering )
   4386          Send_data[4]=NLME_GetShortAddr()/256;
   \   000013                ; Setup parameters for call to function NLME_GetShortAddr
   \   000013   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000016   EB           MOV     A,R3
   \   000017   90....       MOV     DPTR,#(Send_data + 4)
   \   00001A   F0           MOVX    @DPTR,A
   4387          Send_data[5]=NLME_GetShortAddr()%256;
   \   00001B                ; Setup parameters for call to function NLME_GetShortAddr
   \   00001B   12....       LCALL   ??NLME_GetShortAddr?relay
   \   00001E   EA           MOV     A,R2
   \   00001F   90....       MOV     DPTR,#(Send_data + 5)
   \   000022   12....       LCALL   ?Subroutine22 & 0xFFFF
   4388          #endif 
   4389          #if defined( ZigBee_C_R_E_Transparent )
   4390          GenericApp_DstAddr.addr.shortAddr=0XFFFF;
   4391          #else 
   4392          GenericApp_DstAddr.addrMode = (afAddrMode_t)Addr16Bit;
   4393          GenericApp_DstAddr.addr.shortAddr=(Send_data[2]<<8)+Send_data[3];
   4394          #endif
   4395          Send_data[1]=Send_datalend;
   \                     ??CrossCallReturnLabel_33:
   \   000025   90....       MOV     DPTR,#Send_datalend
   \   000028   E0           MOVX    A,@DPTR
   \   000029   90....       MOV     DPTR,#(Send_data + 1)
   \   00002C   F0           MOVX    @DPTR,A
   4396          
   4397            if ( AF_DataRequest( &GenericApp_DstAddr, &GenericApp_epDesc,
   4398                                 GENERICAPP_CLUSTERID,
   4399                                 Send_data[1]+6,
   4400                                 Send_data, 
   4401                                 &GenericApp_TransID,
   4402                                 AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
   \   00002D                ; Setup parameters for call to function AF_DataRequest
   \   00002D   75..1E       MOV     ?V0 + 0,#0x1e
   \   000030   78..         MOV     R0,#?V0 + 0
   \   000032   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000035   75....       MOV     ?V0 + 0,#(GenericApp_TransID & 0xff)
   \   000038   75....       MOV     ?V0 + 1,#((GenericApp_TransID >> 8) & 0xff)
   \   00003B   78..         MOV     R0,#?V0 + 0
   \   00003D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000040   75....       MOV     ?V0 + 0,#(Send_data & 0xff)
   \   000043   75....       MOV     ?V0 + 1,#((Send_data >> 8) & 0xff)
   \   000046   78..         MOV     R0,#?V0 + 0
   \   000048   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004B   90....       MOV     DPTR,#(Send_data + 1)
   \   00004E   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000051   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000054   75..01       MOV     ?V0 + 0,#0x1
   \   000057   75..00       MOV     ?V0 + 1,#0x0
   \   00005A   78..         MOV     R0,#?V0 + 0
   \   00005C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005F   7920         MOV     R1,#0x20
   \   000061   7C..         MOV     R4,#(GenericApp_epDesc & 0xff)
   \   000063   7D..         MOV     R5,#((GenericApp_epDesc >> 8) & 0xff)
   \   000065   7A..         MOV     R2,#(GenericApp_DstAddr & 0xff)
   \   000067   7B..         MOV     R3,#((GenericApp_DstAddr >> 8) & 0xff)
   \   000069   12....       LCALL   ??AF_DataRequest?relay
   \   00006C   7409         MOV     A,#0x9
   \   00006E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000071   E9           MOV     A,R1
   \   000072   7004         JNZ     ??GenericApp_SendTheMessage_0
   4403               { 
   4404               AF_OK=1;
   \   000074   7401         MOV     A,#0x1
   \   000076   8001         SJMP    ??GenericApp_SendTheMessage_1
   4405             }
   4406             else  //Ê§°Ü
   4407             { AF_OK=0;
   \                     ??GenericApp_SendTheMessage_0:
   \   000078   E4           CLR     A
   \                     ??GenericApp_SendTheMessage_1:
   \   000079   90....       MOV     DPTR,#AF_OK
   \   00007C   F0           MOVX    @DPTR,A
   4408             }
   4409          
   4410            //HalUARTWrite(HAL_UART_PORT_0, Send_data,Send_data[1]+6);
   4411          #else
   4412          int datase = NLME_GetShortAddr();
   4413           // char theMessageData[] = NLME_GetShortAddr();
   4414          
   4415          #if defined( ZigBee_C_R_E_Transparent )
   4416          GenericApp_DstAddr.addr.shortAddr=0XFFFC; //R C
   4417          #else 
   4418           GenericApp_DstAddr.addr.shortAddr =NWK_BROADCAST_SHORTADDR_AABB;
   4419          #endif
   4420           Send_data[2]=NLME_GetCoordShortAddr()/256; //¸¸½ÚµãµØÖ·
   4421           Send_data[3]=NLME_GetCoordShortAddr()%256; //¸¸½ÚµãµØÖ·
   4422          //Send_data[4]= NLME_GetShortAddr()/256;
   4423          //Send_data[5]= NLME_GetShortAddr()%256;
   4424          #if(SENSOR_TYPE =='R')
   4425          Send_datalend=0x03;
   4426          Send_data[6]='R';
   4427          Send_data[7]=0X00;
   4428          Send_data[8]=(Send_data[6]+Send_data[7])%256;
   4429          GenericApp_DstAddr.addrMode = (afAddrMode_t)Addr16Bit;
   4430          GenericApp_DstAddr.addr.shortAddr=0X0000;
   4431          #endif  
   4432          #if((SENSOR_TYPE =='H')||(SENSOR_TYPE ==0X12)||(SENSOR_TYPE ==0X18)||(SENSOR_TYPE ==0X15))
   4433           Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ 
   4434           if(GenericApp_applicationbuf==0)
   4435           {Send_data[7]=Send_data[8]=Send_data[9]=0XAA;}
   4436            if(GenericApp_applicationbuf==1)
   4437           {Send_data[7]=Send_data[8]=Send_data[9]=0XBB;}
   4438           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4439            GenericApp_applicationbuf=0;
   4440               halMcuWaitMs(280);
   4441          #if(SENSOR_TYPE =='H') 
   4442            P1_6=1;P1_7=1;
   4443          #endif
   4444          #if(SENSOR_TYPE ==0X12) 
   4445            P1_6=1;P1_7=1;
   4446          #endif
   4447            #if(SENSOR_TYPE ==0X15) 
   4448            P1=0X1E;
   4449          #endif
   4450          #endif  
   4451          #if(SENSOR_TYPE ==0X23)
   4452           Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ 
   4453           if(GenericApp_applicationbuf==0)
   4454           {Send_data[7]=Send_data[8]=Send_data[9]=0XAA;}
   4455           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4456            GenericApp_applicationbuf=0;
   4457          #endif 
   4458            #if(SENSOR_TYPE ==0XA3)
   4459            Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ 
   4460            if(GenericApp_applicationbuf==0)
   4461            {Send_datalend=0x05;Send_data[7]=Send_data[8]=Send_data[9]=0XAA;
   4462            Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256; }
   4463            if(GenericApp_applicationbuf==1)
   4464            {Send_datalend=0x05;Send_data[7]=Send_data[8]=Send_data[9]=0XBB;
   4465            Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256; }
   4466            if(GenericApp_applicationbuf==2)
   4467            {Send_datalend=0x05;Send_data[7]=0XCC;Send_data[8]=0X03;Send_data[9]=GenericApp_ON_OFF;
   4468            Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256; }
   4469            if(GenericApp_applicationbuf==3)
   4470            {Send_datalend=0x06;
   4471            Send_data[11]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10])%256; }
   4472            GenericApp_applicationbuf=0;
   4473          #endif    
   4474          #if(SENSOR_TYPE ==0X79)
   4475            Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ 
   4476          #endif  
   4477          #if((SENSOR_TYPE =='K')||(SENSOR_TYPE ==0X83))
   4478           Send_datalend=0x06;  
   4479           Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ 
   4480           if(GenericApp_applicationbuf==0)
   4481           {Send_data[7]=Send_data[8]=Send_data[9]=0XAA;}
   4482            if(GenericApp_applicationbuf==1)
   4483           {Send_data[7]=Send_data[8]=Send_data[9]=0XBB;}
   4484              if(GenericApp_applicationbuf==2)
   4485            {Send_data[7]=0XCC;Send_data[8]=0X03;Send_data[9]=GenericApp_ON_OFF;}
   4486          #if(SENSOR_TYPE =='K')
   4487           Send_data[10]=T_MG;
   4488          #endif 
   4489          #if(SENSOR_TYPE ==0X83)
   4490           Send_data[10]=~P1;
   4491          #endif 
   4492           Send_data[11]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10])%256;
   4493            GenericApp_applicationbuf=0;
   4494          #endif  
   4495          #if(SENSOR_TYPE ==0X73)
   4496           Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ 
   4497            if(GenericApp_applicationbuf!=3)
   4498            {
   4499           Send_datalend=0x06;  
   4500           if(GenericApp_applicationbuf==0)
   4501           {Send_data[7]=Send_data[8]=Send_data[9]=0XAA;}
   4502            if(GenericApp_applicationbuf==1)
   4503           {Send_data[7]=Send_data[8]=Send_data[9]=0XBB;}
   4504           Send_data[11]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10])%256;
   4505            }
   4506             GenericApp_applicationbuf=0;
   4507          #endif 
   4508          #if((SENSOR_TYPE =='S')||(SENSOR_TYPE ==0X02)||(SENSOR_TYPE ==0X05)||(SENSOR_TYPE ==0X40)||\
   4509            (SENSOR_TYPE ==0X06)||(SENSOR_TYPE ==0X09)||(SENSOR_TYPE ==0X67)||(SENSOR_TYPE ==0X30)||(SENSOR_TYPE ==0X29))
   4510           Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ 
   4511           Send_datalend=0x05;  
   4512           if(GenericApp_applicationbuf==0)
   4513           {Send_data[7]=Send_data[8]=Send_data[9]=0XAA;}
   4514            if(GenericApp_applicationbuf==1)
   4515           {Send_data[7]=Send_data[8]=Send_data[9]=0XBB;}
   4516            if(GenericApp_applicationbuf==2)
   4517           {Send_data[7]=Send_data[9]=0XBB;}
   4518           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4519            GenericApp_applicationbuf=0;
   4520          #endif 
   4521          #if((SENSOR_TYPE ==0X65)||(SENSOR_TYPE ==0X66)||(SENSOR_TYPE ==0X6C)||(SENSOR_TYPE ==0X6E))
   4522            Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ 
   4523           if(GenericApp_switch==0)
   4524           {Send_data[7]=Send_data[8]=Send_data[9]=0XAA;}
   4525            if(GenericApp_switch==1)
   4526           {Send_data[7]=Send_data[8]=Send_data[9]=0XBB;}
   4527           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4528            GenericApp_switch=0;
   4529          #endif 
   4530            
   4531          #if(SENSOR_TYPE ==0X76)
   4532            Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ 
   4533            
   4534          Send_data[7]=0X00;
   4535           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4536          #endif 
   4537          #if((SENSOR_TYPE ==0X6F)||(SENSOR_TYPE ==0X28))
   4538            Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ 
   4539           if(GenericApp_switch==0)
   4540           {Send_data[7]=Send_data[8]=Send_data[9]=0XAA;}
   4541            if(GenericApp_switch==1)
   4542           {Send_data[7]=Send_data[8]=Send_data[9]=0XBB;}
   4543           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4544            GenericApp_switch=0;
   4545          #endif 
   4546          #if(SENSOR_TYPE ==0X6A)
   4547            Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ 
   4548           if(GenericApp_switch==0)
   4549           {Send_data[7]=Send_data[8]=Send_data[9]=0XAA;}
   4550           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4551            GenericApp_switch=0;
   4552          #endif 
   4553          #if((SENSOR_TYPE =='P')||(SENSOR_TYPE ==0X6D))
   4554          Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4555          Send_datalend=0x05;
   4556           if(GenericApp_applicationbuf==0)
   4557           {Send_data[7]=Send_data[8]=Send_data[9]=0XAA;}
   4558            if(GenericApp_applicationbuf==1)
   4559           {Send_data[7]=Send_data[8]=Send_data[9]=0XBB;}
   4560          
   4561           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4562            GenericApp_applicationbuf=0;
   4563          #endif
   4564           #if((SENSOR_TYPE ==0XF0))
   4565          Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4566          Send_datalend=0x05;
   4567           if(GenericApp_applicationbuf==0)
   4568           {Send_data[7]=Send_data[8]=Send_data[9]=0XAA;}
   4569            if(GenericApp_applicationbuf==1)
   4570           {Send_data[7]=Send_data[8]=Send_data[9]=0XBB;}
   4571          
   4572           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4573            GenericApp_applicationbuf=0;
   4574          #endif
   4575          #if(SENSOR_TYPE ==0X6B)
   4576          Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4577          Send_datalend=0x05;
   4578           if(GenericApp_applicationbuf==0)
   4579           {Send_data[7]=Send_data[8]=Send_data[9]=0XAA;}
   4580            if(GenericApp_applicationbuf==1)
   4581           {Send_data[8]=Send_data[9]=0XBB;}
   4582          #if defined(LEDA8)
   4583               Send_data[7]=0XDE;
   4584          #endif
   4585           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4586            GenericApp_applicationbuf=0;
   4587          #endif
   4588          #if(SENSOR_TYPE ==0X25)
   4589          Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4590           Send_data[7]=0X01;
   4591           Send_data[Send_datalend+6]=0X0F;//Ð£ÑéºÍ
   4592           Send_datalend+=1;  //+Ð£ÑéºÍ
   4593          #endif
   4594           #if(SENSOR_TYPE ==0X7C)
   4595          Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4596          #endif
   4597          #if(SENSOR_TYPE ==0X7B)
   4598          Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4599           //Send_data[7]=0X00;
   4600           Send_data[12]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11])%256;
   4601          #endif
   4602           #if(SENSOR_TYPE ==0X71)
   4603          Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4604           Send_data[7]=0X01;
   4605           Send_data[Send_datalend+6]=0X0F;//Ð£ÑéºÍ
   4606           Send_datalend+=1;  //+Ð£ÑéºÍ
   4607          #endif
   4608           #if(SENSOR_TYPE ==0X70)
   4609          Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4610           Send_data[7]=0X01;
   4611           Send_data[Send_datalend+6]=0X0F;//Ð£ÑéºÍ
   4612           Send_datalend+=1;  //+Ð£ÑéºÍ
   4613          #endif
   4614           #if(SENSOR_TYPE ==0X86)
   4615          Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4616           Send_data[7]=0X01;
   4617           Send_data[Send_datalend+6]=0X0F;//Ð£ÑéºÍ
   4618          #endif
   4619           #if(SENSOR_TYPE ==0X87)
   4620          Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4621           Send_data[7]=0X01; Send_data[8]=0X01;
   4622           Send_data[Send_datalend+6]=0X0F;//Ð£ÑéºÍ
   4623          #endif
   4624          #if(SENSOR_TYPE ==0X26)
   4625          Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4626           Send_data[7]=0X01;
   4627           Send_data[Send_datalend+6]=0X0F;//Ð£ÑéºÍ
   4628           Send_datalend+=1;
   4629          #endif
   4630           #if(SENSOR_TYPE ==0X27)
   4631          Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4632           Send_data[8]=0X0F;//Ð£ÑéºÍ
   4633          #endif
   4634          #if(SENSOR_TYPE ==0X07)  
   4635          Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4636          #if defined(UHF)
   4637          Send_data[7]=0x01; //UHF-  01:ÃüÁî¶Á¿¨¡£B1:Ö÷¶¯ÉÏ´«
   4638          if(AB==0X0B)
   4639          Send_data[7]=0xB1; //01:ÃüÁî¶Á¿¨¡£B1:Ö÷¶¯ÉÏ´«
   4640          //AB=0X0A;
   4641          #endif
   4642          #if defined(RLM100)
   4643          Send_data[7]=0x02; //RLM100-  02:ÃüÁî¶Á¿¨¡£B2:Ö÷¶¯ÉÏ´«
   4644          #if defined(AB)
   4645          Send_data[7]=0xB2; //02:ÃüÁî¶Á¿¨¡£B2:Ö÷¶¯ÉÏ´«
   4646          #endif
   4647          #endif
   4648          //Send_data[13]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11]+Send_data[12])%256;
   4649          #endif
   4650          
   4651          #if(SENSOR_TYPE ==0X0E)  
   4652          Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4653          
   4654          //Send_data[13]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11]+Send_data[12])%256;
   4655          #endif
   4656          #if(SENSOR_TYPE ==0X08)  
   4657          Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4658          //Send_data[7]=0X01;
   4659          //Send_data[13]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11]+Send_data[12])%256;
   4660          #endif
   4661          #if(SENSOR_TYPE ==0X0D)  
   4662          Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4663          #endif
   4664          #if((SENSOR_TYPE ==0X0A)||(SENSOR_TYPE ==0X0B)||(SENSOR_TYPE ==0X12)||(SENSOR_TYPE ==0X18)\
   4665            ||(SENSOR_TYPE ==0X14)||(SENSOR_TYPE ==0X74))
   4666          Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4667          #endif
   4668          #if(SENSOR_TYPE ==0X13)
   4669          #if defined(HUABANG) 
   4670           // Send_data[15]=0;
   4671          float datieee754=0;
   4672          long dat=0;
   4673            datieee754=ieee754()*100;
   4674            dat= (long) datieee754;
   4675            Send_data[15]=dat>>24;Send_data[16]=dat>>16;Send_data[17]=dat>>8;Send_data[18]=dat;
   4676             Send_data[8]=Send_data[9]=Send_data[10]=Send_data[11]=Send_data[12]=0;
   4677             Send_data[13]=Send_data[7];
   4678             Send_data[7]=0XAA;Send_data[14]=0XBB;
   4679          #endif
   4680          Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4681          #endif
   4682          
   4683          
   4684          #if(SENSOR_TYPE =='G')  
   4685          Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4686          Send_data[13]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11]+Send_data[12])%256;
   4687          #endif
   4688          
   4689          #if((SENSOR_TYPE =='I')||(SENSOR_TYPE ==0X64)||(SENSOR_TYPE ==0X77))
   4690          Send_data[7]=GenericApp_appIO;
   4691           Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4692           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4693          
   4694          #endif
   4695          #if((SENSOR_TYPE ==0X10)||(SENSOR_TYPE ==0X0F)||(SENSOR_TYPE ==0X17)||(SENSOR_TYPE ==0X21)||(SENSOR_TYPE ==0X16))
   4696           Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4697           Send_data[8]=(Send_data[6]+Send_data[7])%256;
   4698          #endif
   4699           #if((SENSOR_TYPE ==0X11)||(SENSOR_TYPE ==0X1A))
   4700           Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4701           Send_data[9]=(Send_data[6]+Send_data[7]+Send_data[8])%256;
   4702          #endif
   4703          #if(SENSOR_TYPE ==0X20)
   4704           Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4705           Send_data[7]=Send_data[8];
   4706           Send_data[8]=(Send_data[10]*10+Send_data[11]);
   4707           Send_data[9]=Send_data[12];
   4708           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4709          #endif
   4710          #if(SENSOR_TYPE ==0X24)
   4711            Send_data[6]=SENSOR_TYPE;
   4712             Send_data[7]=0xa1;
   4713            Send_data[8]=CSB_Len_H;
   4714            Send_data[9]=CSB_Len_L;
   4715            Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4716          #endif
   4717            #if(SENSOR_TYPE ==0X80)
   4718            Send_data[6]=SENSOR_TYPE;
   4719             Send_data[7]=0xA1;
   4720            Send_data[8]=0xA2;
   4721            Send_data[9]=0xA3;
   4722             Send_data[10]=CSB_Len_H;
   4723            Send_data[11]=CSB_Len_L;
   4724            Send_data[12]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11])%256;
   4725          #endif
   4726          #if(SENSOR_TYPE ==0X31)
   4727            Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ 
   4728            if(GenericApp_applicationbuf==0)
   4729            {Send_datalend=0x05;Send_data[7]=Send_data[8]=Send_data[9]=0XAA;
   4730            Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256; }
   4731            if(GenericApp_applicationbuf==1)
   4732            {Send_datalend=0x05;Send_data[7]=Send_data[8]=Send_data[9]=0XBB;
   4733            Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256; }
   4734            if(GenericApp_applicationbuf==2)
   4735            {Send_datalend=0x09;Send_data[8]=Uart_Rev_Buff_1[0];Send_data[9]=Uart_Rev_Buff_1[1];Send_data[10]=Uart_Rev_Buff_1[2];
   4736           Send_data[11]=Uart_Rev_Buff_1[3];Send_data[12]=Uart_Rev_Buff_1[4];Send_data[13]=Uart_Rev_Buff_1[5];
   4737            Send_data[14]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11]+Send_data[12]+Send_data[13])%256; }
   4738            if(GenericApp_applicationbuf==3)
   4739            {Send_datalend=0x05;
   4740            Send_data[10]=(Send_data[7]+Send_data[8]+Send_data[9])%256; }
   4741            if(GenericApp_applicationbuf==4)
   4742            {Send_datalend=0x09;
   4743            Send_data[14]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11]+Send_data[12]+Send_data[13])%256; }
   4744            GenericApp_applicationbuf=0;
   4745          #endif  
   4746            
   4747           #if(SENSOR_TYPE ==0X03)
   4748           Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4749           
   4750            Send_data[7]=GenericApp_appIO;
   4751           Send_data[7]=(Send_data[7]|0XA0);
   4752           Send_data[8]=(Send_data[6]+Send_data[7])%256;
   4753          #endif
   4754          #if(SENSOR_TYPE =='T')
   4755            Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4756          //²»ÒªÐ£ÑéºÍ Send_data[14]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11]+Send_data[12]+Send_data[13])%256;
   4757          #endif
   4758          #if(SENSOR_TYPE =='O')
   4759           Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4760           Send_data[14]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11]+Send_data[12]+Send_data[13])%256;
   4761          #endif
   4762          #if(SENSOR_TYPE =='D')
   4763                  float OUTRGB = 0.0;
   4764                  unsigned int RGBTEM;
   4765                          OUTRGB=TCS3200(1);
   4766          		//RGBTEM=(uint)(OUTR*OUTRGB);			//×ª»»R	
   4767                          RGBTEM=(uint)(0.1795*OUTRGB);			//×ª»»R	
   4768                          Send_data[7]=RGBTEM;
   4769          //-------------------------------------
   4770          		OUTRGB=TCS3200(2);
   4771          		//RGBTEM= (uint)(OUTG*OUTRGB);
   4772                         RGBTEM= (uint)(0.2614*OUTRGB);
   4773                          Send_data[8]=RGBTEM;
   4774          //--------------------------------
   4775          		OUTRGB=TCS3200(3);
   4776          		//RGBTEM= (uint)(OUTB*OUTRGB);
   4777                          RGBTEM= (uint)(0.1097*OUTRGB);
   4778                          Send_data[9]=RGBTEM;
   4779                          Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4780                          Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4781                          P1_3=0;
   4782          #endif
   4783          #if(SENSOR_TYPE =='Q')
   4784            Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4785          #endif
   4786          
   4787          #if(SENSOR_TYPE =='U')
   4788           unsigned int  data;						    
   4789              float Temperature;
   4790                  Temperature = ReadTemperature();        //·µ»Ø16Î»¶þ½øÖÆÊý
   4791                  Temperature *= CelsiurPerLSB;		//×ª»»³É¸¡µãÐÍÎÂ¶ÈÖµ(ÉãÊÏ¶È)
   4792          Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4793           data=(unsigned int)(100*Temperature);   
   4794           Send_data[7]=(uint8)(data/ 100);
   4795           Send_data[8]=(uint8)(data % 100);
   4796           Send_data[9]=(Send_data[6]+Send_data[7]+Send_data[8])%256;
   4797          #endif
   4798           
   4799           #if(SENSOR_TYPE =='C')
   4800           Single_Write_(write_1710 ,power_on );
   4801           Single_Write_(write_1710 ,0x52 );
   4802           Single_Write_(write_1710 ,0x78 );
   4803           Single_Write_(write_1710 ,h_resolution_mod );
   4804           halMcuWaitMs(500); //ÑÓÊ±
   4805           Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4806           Send_data[7]=Single_Read_(read_1710);
   4807           //Send_data[8]=Single_Read_(read_1710+1);
   4808           Send_data[8]=(Send_data[6]+Send_data[7])%256;
   4809          halMcuWaitMs(50);//ÑÓÊ±
   4810           //data1[0]*256+data1[1];
   4811           Single_Write_(write_1710 ,reset );
   4812           WrToROM(power_down,write_1710,1);
   4813          #endif
   4814          #if(SENSOR_TYPE ==0X33)
   4815           Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4816            Send_data[7]=0xD1;
   4817           Send_datalend=0x07;
   4818          //B_LUX30_Multiple_read(0X00,&Send_data[8],4);
   4819          Send_data[12]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11])%256;
   4820          #endif
   4821           
   4822           #if(SENSOR_TYPE =='B')
   4823           for(char i=0;i<RawDataLength;i++)
   4824            {
   4825            MMA7660_XYZ_Read_and_Filter();
   4826            }
   4827          Send_data[7]=Xavg8;
   4828          Send_data[8]=Yavg8;
   4829          Send_data[9]=Zavg8;
   4830          mma_delay(30000);
   4831           for(char i=0;i<RawDataLength;i++)
   4832            {
   4833            MMA7660_XYZ_Read_and_Filter();
   4834            }
   4835            if((Send_data[7]-Xavg8>5)||(Send_data[7]-Xavg8<-5))
   4836               Send_data[7]=0;
   4837            if((Send_data[8]-Yavg8>5)||(Send_data[8]-Yavg8<-5))
   4838           Send_data[8]=0;
   4839            if((Send_data[9]-Zavg8>5)||(Send_data[9]-Zavg8<-5))
   4840           Send_data[9]=0;
   4841          
   4842          //Xavg8>0x1f (Õý¸º)     
   4843          //(Xavg8&0x1f) (´óÐ¡)   
   4844          //3(Xavg8&0x1f)/62 (¼ÓËÙ¶È) 
   4845          //6(Xavg8&0x1f)/62 (¸ß¶È)  
   4846          //6(Xavg8&0x1f)/62 (½Ç¶Èsin)
   4847          Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4848           Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4849          #endif
   4850          #if(SENSOR_TYPE =='F')
   4851           #if defined(BMP085) 
   4852                float temperature=0;
   4853          	float pressure=0;
   4854                  unsigned int data;
   4855          
   4856                XCLR=1; 
   4857                 mDelay(50); //ÑÓÊ±
   4858                 BMP085_sample(0);
   4859                temperature=T;
   4860          	pressure=p;
   4861          	temperature=temperature/10;	//µ¥Î»£ºÉãÊÏ¶È
   4862          	pressure=pressure/1000;		//µ¥Î»£ºkPa    //30 ... 110KPa£¨º£°Î9000Ã×...-500Ã×£©
   4863          	mDelay(50); //ÑÓÊ±
   4864            Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4865            data=(uint)(100*temperature);     
   4866            Send_data[7]=(uint8)(data/100);
   4867            Send_data[8]=(uint8)(data%100);
   4868            
   4869            data=(uint)(100*pressure);      
   4870          
   4871            Send_data[9]=(uint8)(data/ 100);
   4872            Send_data[10]=(uint8)(data % 100);
   4873            Send_data[11]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10])%256;
   4874          #endif
   4875            
   4876          #if defined(BMP180) 
   4877                  uint16_t data=0;
   4878            Multiple_Read_BMP180();
   4879             Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ  
   4880            Send_data[7]=(uint8)(temperature/0x0a);;
   4881            Send_data[8]=(uint8)(temperature%0x0a);
   4882            data=(pressure/0x0a);
   4883            Send_data[9]=(uint8)(data/0x64);
   4884            Send_data[10]=(uint8)(data%0x64);
   4885            Send_data[11]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10])%256;
   4886          #endif
   4887          #endif
   4888          #if(SENSOR_TYPE =='E')
   4889            Send_data[11]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10])%256;
   4890          #endif
   4891          #if(SENSOR_TYPE ==0X85)
   4892            Send_datalend=0x07;
   4893            Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4894              Send_data[12]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11])%256;
   4895          #endif
   4896          #if(SENSOR_TYPE ==0X82)
   4897              Send_datalend=0x09;  
   4898             Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4899            Send_data[14]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11]+Send_data[12]+Send_data[13])%256;
   4900          #endif
   4901          #if((SENSOR_TYPE =='A')||(SENSOR_TYPE =='J')||(SENSOR_TYPE =='L')||(SENSOR_TYPE =='M')\
   4902            ||(SENSOR_TYPE =='N')||(SENSOR_TYPE ==0X0C)||(SENSOR_TYPE ==0X19)\
   4903            ||(SENSOR_TYPE ==0X62)||(SENSOR_TYPE ==0X63) ||(SENSOR_TYPE ==0X34)||(SENSOR_TYPE ==0X35)\
   4904              ||(SENSOR_TYPE ==0X36)||(SENSOR_TYPE ==0X37)||(SENSOR_TYPE ==0X38)||(SENSOR_TYPE ==0X39)\
   4905                ||(SENSOR_TYPE ==0X3A)||(SENSOR_TYPE ==0X3E)||(SENSOR_TYPE ==0X3F)||(SENSOR_TYPE ==0X75))
   4906          
   4907           Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4908           Send_data[9]=(Send_data[6]+Send_data[7]+Send_data[8])%256;
   4909          #endif
   4910           
   4911          #if((SENSOR_TYPE ==0X22)||(SENSOR_TYPE ==0X22))
   4912          Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4913           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4914          #endif
   4915           
   4916           #if((SENSOR_TYPE ==0X61)||(SENSOR_TYPE ==0X3C))
   4917            Send_datalend=0x04;   
   4918           Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4919           Send_data[9]=(Send_data[6]+Send_data[7]+Send_data[8])%256;
   4920          #endif
   4921          #if(SENSOR_TYPE ==0X84)
   4922            Send_datalend=0x05;   
   4923           Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4924           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4925          #endif
   4926           #if(SENSOR_TYPE ==0X3B)
   4927             Send_datalend=0x05;   
   4928           Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4929           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   4930          #endif
   4931          #if(SENSOR_TYPE ==0X78)
   4932           Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4933          #endif
   4934          #if((SENSOR_TYPE ==0X72)||(SENSOR_TYPE ==0X81)||(SENSOR_TYPE ==0X3D))
   4935           Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4936          #if defined( SDS011 )
   4937           Send_data[13]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11]+Send_data[12])%256;
   4938          #else
   4939           Send_data[11]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10])%256;
   4940          #endif
   4941           
   4942          #endif
   4943          #if((SENSOR_TYPE ==0X04))
   4944           Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   4945           Send_data[8]=(Send_data[6]+Send_data[7])%256;
   4946           GenericApp_BX=0;
   4947          #endif
   4948          
   4949          #if defined( ZigBee_C_R_E_IEEE )
   4950          ZigBee_C_R_E_Engineering_H();
   4951          #else
   4952          Send_data[1]=Send_datalend;
   4953          #endif
   4954          #if defined( CC2530_V30 )
   4955          for(char i=(Send_data[1]+7);i>5;i--)
   4956          Send_data[i+5]=Send_data[i];
   4957          Send_data[6]=Send_data[7]=Send_data[8]=Send_data[9]=0x0f;
   4958          Send_data[10]=T_MGSbit;
   4959          T_MGSbit&=~0X21; //xx0x xxx0 Ö÷¶¯  Õý³£ ×´Ì¬Î»
   4960             if ( AF_DataRequest( &GenericApp_DstAddr, &GenericApp_epDesc,
   4961                                 GENERICAPP_CLUSTERID,
   4962                                 (Send_data[1]+11),
   4963                                 Send_data,
   4964                                 &GenericApp_TransID,
   4965                                 AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
   4966               { 
   4967               AF_OK=1;
   4968             }
   4969             else  //Ê§°Ü
   4970             { AF_OK=0;
   4971             }
   4972          #else
   4973             if ( AF_DataRequest( &GenericApp_DstAddr, &GenericApp_epDesc,
   4974                                 GENERICAPP_CLUSTERID,
   4975                                 (Send_data[1]+6),
   4976                                 Send_data,
   4977                                 &GenericApp_TransID,
   4978                                 AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
   4979             { 
   4980               AF_OK=1;
   4981             }
   4982             else  //Ê§°Ü
   4983             { AF_OK=0;
   4984             }
   4985          
   4986          #endif
   4987          #if defined( CC2530_RF_433M )  
   4988             Send_data[(Send_data[1]+6)]=0x0D;  Send_data[(Send_data[1]+6+1)]=0x0A;
   4989              HalUARTWrite(HAL_UART_PORT_0, Send_data,(Send_data[1]+6+2));
   4990          #endif
   4991          #endif
   4992            HalLedSet ( HAL_LED_1, HAL_LED_MODE_OFF );
   \   00007D                ; Setup parameters for call to function HalLedSet
   \   00007D   7A00         MOV     R2,#0x0
   \   00007F   7901         MOV     R1,#0x1
   \   000081   12....       LCALL   ??HalLedSet?relay
   4993            HalLedSet ( HAL_LED_2, HAL_LED_MODE_OFF );
   \   000084                ; Setup parameters for call to function HalLedSet
   \   000084   7A00         MOV     R2,#0x0
   \   000086   7902         MOV     R1,#0x2
   \   000088   12....       LCALL   ??HalLedSet?relay
   4994          }
   \   00008B                REQUIRE ?Subroutine3
   \   00008B                ; // Fall through to label ?Subroutine3

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   7406         MOV     A,#0x6
   \   000004   28           ADD     A,R0
   \   000005   F5..         MOV     ?V0 + 0,A
   \   000007   E4           CLR     A
   \   000008   3400         ADDC    A,#0x0
   \   00000A   F5..         MOV     ?V0 + 1,A
   \   00000C   78..         MOV     R0,#?V0 + 0
   \   00000E   22           RET
   4995          /*********************************************************************
   4996          *********************************************************************/
   4997          #if defined( SENSOR_TYPE_Coord )
   4998          void GenericAppCoordEB(); //C ÊÂ¼þ´¦Àí

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4999          void GenericAppCoordEB() //C ÊÂ¼þ´¦Àí
   \                     GenericAppCoordEB:
   5000          {if(AF_RFn)
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   90....       MOV     DPTR,#AF_RFn
   \   000008   E0           MOVX    A,@DPTR
   \   000009   7003         JNZ     $+5
   \   00000B   02....       LJMP    ??GenericAppCoordEB_0 & 0xFFFF
   5001          {  
   5002               if(GenericApp_ON_OFF>0)GenericApp_ON_OFF--;
   \   00000E   90....       MOV     DPTR,#GenericApp_ON_OFF
   \   000011   E0           MOVX    A,@DPTR
   \   000012   7002         JNZ     ??GenericAppCoordEB_1
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \                     ??GenericAppCoordEB_1:
   \   000016   6017         JZ      ??GenericAppCoordEB_2
   5003                   if(GenericApp_ON_OFF<1)
   \   000018   90....       MOV     DPTR,#GenericApp_ON_OFF
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   24FF         ADD     A,#-0x1
   \   00001E   F0           MOVX    @DPTR,A
   \   00001F   F8           MOV     R0,A
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   34FF         ADDC    A,#-0x1
   \   000024   F0           MOVX    @DPTR,A
   \   000025   F9           MOV     R1,A
   \   000026   E8           MOV     A,R0
   \   000027   7001         JNZ     ??GenericAppCoordEB_3
   \   000029   E9           MOV     A,R1
   \                     ??GenericAppCoordEB_3:
   \   00002A   6003         JZ      $+5
   \   00002C   02....       LJMP    ??GenericAppCoordEB_4 & 0xFFFF
   5004                   {  
   5005                   GenericApp_DstAddr.addr.shortAddr=0XFFFF;
   \                     ??GenericAppCoordEB_2:
   \   00002F   90....       MOV     DPTR,#GenericApp_DstAddr
   \   000032   74FF         MOV     A,#-0x1
   \   000034   F0           MOVX    @DPTR,A
   \   000035   A3           INC     DPTR
   \   000036   F0           MOVX    @DPTR,A
   5006                  if ( AF_DataRequest( &GenericApp_DstAddr, &GenericApp_epDesc,
   5007                                 GENERICAPP_CLUSTERID,
   5008                                 chnnd[AF_RFnd][2]+6,
   5009                                 &chnnd[AF_RFnd][1], 
   5010                                 &GenericApp_TransID,
   5011                                 AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
   \   000037   90....       MOV     DPTR,#AF_RFnd
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   75F078       MOV     B,#0x78
   \   00003E   A4           MUL     AB
   \   00003F   24..         ADD     A,#(chnnd & 0xff)
   \   000041   F8           MOV     R0,A
   \   000042   E5F0         MOV     A,B
   \   000044   34..         ADDC    A,#((chnnd >> 8) & 0xff)
   \   000046   F9           MOV     R1,A
   \   000047   E8           MOV     A,R0
   \   000048   FA           MOV     R2,A
   \   000049   E9           MOV     A,R1
   \   00004A   FB           MOV     R3,A
   \   00004B                ; Setup parameters for call to function AF_DataRequest
   \   00004B   75..1E       MOV     ?V0 + 0,#0x1e
   \   00004E   78..         MOV     R0,#?V0 + 0
   \   000050   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000053   75....       MOV     ?V0 + 0,#(GenericApp_TransID & 0xff)
   \   000056   75....       MOV     ?V0 + 1,#((GenericApp_TransID >> 8) & 0xff)
   \   000059   78..         MOV     R0,#?V0 + 0
   \   00005B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005E   8A82         MOV     DPL,R2
   \   000060   8B83         MOV     DPH,R3
   \   000062   A3           INC     DPTR
   \   000063   8582..       MOV     ?V0 + 0,DPL
   \   000066   8583..       MOV     ?V0 + 1,DPH
   \   000069   78..         MOV     R0,#?V0 + 0
   \   00006B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006E   8A82         MOV     DPL,R2
   \   000070   8B83         MOV     DPH,R3
   \   000072   A3           INC     DPTR
   \   000073   A3           INC     DPTR
   \   000074   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   000077   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007A   75..01       MOV     ?V0 + 0,#0x1
   \   00007D   75..00       MOV     ?V0 + 1,#0x0
   \   000080   78..         MOV     R0,#?V0 + 0
   \   000082   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000085   7920         MOV     R1,#0x20
   \   000087   7C..         MOV     R4,#(GenericApp_epDesc & 0xff)
   \   000089   7D..         MOV     R5,#((GenericApp_epDesc >> 8) & 0xff)
   \   00008B   7A..         MOV     R2,#(GenericApp_DstAddr & 0xff)
   \   00008D   7B..         MOV     R3,#((GenericApp_DstAddr >> 8) & 0xff)
   \   00008F   12....       LCALL   ??AF_DataRequest?relay
   \   000092   7409         MOV     A,#0x9
   \   000094   12....       LCALL   ?DEALLOC_XSTACK8
   \   000097   E9           MOV     A,R1
   \   000098   700A         JNZ     ??GenericAppCoordEB_5
   5012                        {
   5013                          //AF_RFn+=16;              
   5014                         // HalUARTWrite(HAL_UART_PORT_0,  &chnnd[AF_RFnd][1],chnnd[AF_RFnd][2]+6);
   5015                          //HalUARTWrite(HAL_UART_PORT_0,  &AF_RFn,1);
   5016                          
   5017                          
   5018                         AF_RFn=0;
   \   00009A   E4           CLR     A
   \   00009B   90....       MOV     DPTR,#AF_RFn
   \   00009E   F0           MOVX    @DPTR,A
   5019                          chnnd[AF_RFnd][0]=0;
   \   00009F   12....       LCALL   ?Subroutine13 & 0xFFFF
   5020                          
   5021                         // AF_RFn--; 
   5022                       //  if(AF_RFn==0){ chnnd[AF_RFnd][0]=0;}//10´ÎÈ«²¿Ê§°Ü
   5023                        //  HalUARTWrite(HAL_UART_PORT_0,  &chnnd[AF_RFnd][1],chnnd[AF_RFnd][2]+6);
   5024                        // GenericApp_ON_OFF=(4+(10-AF_RFn)*2);
   5025                         
   5026                         // if(AF_RFnds>0)AF_RFnds+1;
   5027                          }
   \                     ??CrossCallReturnLabel_14:
   \   0000A2   8034         SJMP    ??GenericAppCoordEB_0
   5028                     else//Ê§°Ü
   5029                     {AF_RFn--; 
   5030                     if(AF_RFn==0){ chnnd[AF_RFnd][0]=0;}//10´ÎÈ«²¿Ê§°Ü
   \                     ??GenericAppCoordEB_5:
   \   0000A4   90....       MOV     DPTR,#AF_RFn
   \   0000A7   E0           MOVX    A,@DPTR
   \   0000A8   14           DEC     A
   \   0000A9   F0           MOVX    @DPTR,A
   \   0000AA   7003         JNZ     ??CrossCallReturnLabel_15
   \   0000AC   12....       LCALL   ?Subroutine13 & 0xFFFF
   5031                      // HalUARTWrite(HAL_UART_PORT_0,  &AF_RFn,1);
   5032                    // halMcuWaitMs(1000+((10-AF_RF)*50));
   5033                       // HalUARTWrite(HAL_UART_PORT_0,  &chnnd[AF_RFnd][1],chnnd[AF_RFnd][2]+6);
   5034                      GenericApp_ON_OFF=(5+(10-AF_RFn)*2);
   \                     ??CrossCallReturnLabel_15:
   \   0000AF   90....       MOV     DPTR,#AF_RFn
   \   0000B2   E0           MOVX    A,@DPTR
   \   0000B3   F8           MOV     R0,A
   \   0000B4   C3           CLR     C
   \   0000B5   E4           CLR     A
   \   0000B6   98           SUBB    A,R0
   \   0000B7   F8           MOV     R0,A
   \   0000B8   E4           CLR     A
   \   0000B9   9400         SUBB    A,#0x0
   \   0000BB   F9           MOV     R1,A
   \   0000BC   E8           MOV     A,R0
   \   0000BD   C3           CLR     C
   \   0000BE   33           RLC     A
   \   0000BF   F8           MOV     R0,A
   \   0000C0   E9           MOV     A,R1
   \   0000C1   33           RLC     A
   \   0000C2   F9           MOV     R1,A
   \   0000C3   7419         MOV     A,#0x19
   \   0000C5   28           ADD     A,R0
   \   0000C6   F8           MOV     R0,A
   \   0000C7   E4           CLR     A
   \   0000C8   39           ADDC    A,R1
   \   0000C9   F9           MOV     R1,A
   \   0000CA   90....       MOV     DPTR,#GenericApp_ON_OFF
   \   0000CD   E8           MOV     A,R0
   \   0000CE   F0           MOVX    @DPTR,A
   \   0000CF   A3           INC     DPTR
   \   0000D0   E9           MOV     A,R1
   \   0000D1   F0           MOVX    @DPTR,A
   5035                     }
   5036                   }
   5037          }
   5038          if( AF_RFn==0)
   \   0000D2   90....       MOV     DPTR,#AF_RFn
   \   0000D5   E0           MOVX    A,@DPTR
   \   0000D6   707F         JNZ     ??GenericAppCoordEB_4
   5039          {
   5040                       AF_RFnds=0;
   \                     ??GenericAppCoordEB_0:
   \   0000D8   E4           CLR     A
   \   0000D9   90....       MOV     DPTR,#AF_RFnds
   \   0000DC   F0           MOVX    @DPTR,A
   5041                     if(chnnd[1][0]||chnnd[2][0]||chnnd[3][0]||chnnd[4][0])
   \   0000DD   90....       MOV     DPTR,#(chnnd + 240)
   \   0000E0   E0           MOVX    A,@DPTR
   \   0000E1   FA           MOV     R2,A
   \   0000E2   90....       MOV     DPTR,#(chnnd + 360)
   \   0000E5   E0           MOVX    A,@DPTR
   \   0000E6   FB           MOV     R3,A
   \   0000E7   90....       MOV     DPTR,#(chnnd + 480)
   \   0000EA   E0           MOVX    A,@DPTR
   \   0000EB   FC           MOV     R4,A
   \   0000EC   90....       MOV     DPTR,#(chnnd + 120)
   \   0000EF   E0           MOVX    A,@DPTR
   \   0000F0   FD           MOV     R5,A
   \   0000F1   7012         JNZ     ??GenericAppCoordEB_6
   \   0000F3   90....       MOV     DPTR,#(chnnd + 240)
   \   0000F6   E0           MOVX    A,@DPTR
   \   0000F7   700C         JNZ     ??GenericAppCoordEB_6
   \   0000F9   90....       MOV     DPTR,#(chnnd + 360)
   \   0000FC   E0           MOVX    A,@DPTR
   \   0000FD   7006         JNZ     ??GenericAppCoordEB_6
   \   0000FF   90....       MOV     DPTR,#(chnnd + 480)
   \   000102   E0           MOVX    A,@DPTR
   \   000103   601B         JZ      ??GenericAppCoordEB_7
   5042                       {  if(chnnd[4][0])
   \                     ??GenericAppCoordEB_6:
   \   000105   EC           MOV     A,R4
   \   000106   6018         JZ      ??GenericAppCoordEB_7
   5043                          {AF_RFnds=4;
   \   000108   7404         MOV     A,#0x4
   \   00010A   90....       MOV     DPTR,#AF_RFnds
   \   00010D   F0           MOVX    @DPTR,A
   5044                           if(chnnd[3][0])
   \   00010E   EB           MOV     A,R3
   \   00010F   600F         JZ      ??GenericAppCoordEB_7
   5045                             {AF_RFnds=3;
   \   000111   7403         MOV     A,#0x3
   \   000113   F0           MOVX    @DPTR,A
   5046                              if(chnnd[2][0])
   \   000114   EA           MOV     A,R2
   \   000115   6009         JZ      ??GenericAppCoordEB_7
   5047                             {AF_RFnds=2;
   \   000117   7402         MOV     A,#0x2
   \   000119   F0           MOVX    @DPTR,A
   5048                               if(chnnd[1][0])
   \   00011A   ED           MOV     A,R5
   \   00011B   6003         JZ      ??GenericAppCoordEB_7
   5049                                {AF_RFnds=1;}
   \   00011D   7401         MOV     A,#0x1
   \   00011F   F0           MOVX    @DPTR,A
   5050                             }
   5051                             }
   5052                          }
   5053                       }
   5054          
   5055            
   5056           if(chnnd[0][0])
   \                     ??GenericAppCoordEB_7:
   \   000120   90....       MOV     DPTR,#chnnd
   \   000123   E0           MOVX    A,@DPTR
   \   000124   600D         JZ      ??GenericAppCoordEB_8
   5057           {  AF_RFnd=0;
   \   000126   E4           CLR     A
   \   000127   90....       MOV     DPTR,#AF_RFnd
   \   00012A   F0           MOVX    @DPTR,A
   5058            if(AF_RFnds!=0)AF_RFnd=AF_RFnds;
   \   00012B   90....       MOV     DPTR,#AF_RFnds
   \   00012E   E0           MOVX    A,@DPTR
   \   00012F   6020         JZ      ??GenericAppCoordEB_9
   \   000131   801A         SJMP    ??GenericAppCoordEB_10
   5059            AF_RFn=10;//·¢ËÍ10´Î
   5060           }
   5061           else
   5062           { if(chnnd[1][0])
   \                     ??GenericAppCoordEB_8:
   \   000133   ED           MOV     A,R5
   \   000134   6004         JZ      ??GenericAppCoordEB_11
   5063              {  AF_RFnd=1; AF_RFn=10;//·¢ËÍ5´Î
   \   000136   7401         MOV     A,#0x1
   \   000138   8013         SJMP    ??GenericAppCoordEB_10
   5064              }
   5065              else
   5066              { if(chnnd[2][0])
   \                     ??GenericAppCoordEB_11:
   \   00013A   EA           MOV     A,R2
   \   00013B   6004         JZ      ??GenericAppCoordEB_12
   5067                  {  AF_RFnd=2; AF_RFn=10;//·¢ËÍ5´Î
   \   00013D   7402         MOV     A,#0x2
   \   00013F   800C         SJMP    ??GenericAppCoordEB_10
   5068                  }
   5069                  else
   5070                  { if(chnnd[3][0])
   \                     ??GenericAppCoordEB_12:
   \   000141   EB           MOV     A,R3
   \   000142   6004         JZ      ??GenericAppCoordEB_13
   5071                    {  AF_RFnd=3; AF_RFn=10;//·¢ËÍ5´Î
   \   000144   7403         MOV     A,#0x3
   \   000146   8005         SJMP    ??GenericAppCoordEB_10
   5072                    }
   5073                    else
   5074                    { if(chnnd[4][0])
   \                     ??GenericAppCoordEB_13:
   \   000148   EC           MOV     A,R4
   \   000149   600C         JZ      ??GenericAppCoordEB_4
   5075                      {  AF_RFnd=4; AF_RFn=10;//·¢ËÍ5´Î
   \   00014B   7404         MOV     A,#0x4
   \                     ??GenericAppCoordEB_10:
   \   00014D   90....       MOV     DPTR,#AF_RFnd
   \   000150   F0           MOVX    @DPTR,A
   \                     ??GenericAppCoordEB_9:
   \   000151   740A         MOV     A,#0xa
   \   000153   90....       MOV     DPTR,#AF_RFn
   \   000156   F0           MOVX    @DPTR,A
   5076                      }
   5077                    }
   5078                  }
   5079              }
   5080           }
   5081          }
   5082             if(AF_RF==1)//Ê§°Ü±êÖ¾´æ´¢Ê§°ÜÊý¾Ý
   \                     ??GenericAppCoordEB_4:
   \   000157   90....       MOV     DPTR,#AF_RF
   \   00015A   E0           MOVX    A,@DPTR
   \   00015B   6401         XRL     A,#0x1
   \   00015D   6003         JZ      $+5
   \   00015F   02....       LJMP    ??GenericAppCoordEB_14 & 0xFFFF
   5083             {AF_RF=0;//ÒÔ¿ªÊ¼´æ´¢£¬Çå0
   \   000162   E4           CLR     A
   \   000163   F0           MOVX    @DPTR,A
   5084           
   5085                   if(!chnnd[0][0])
   \   000164   90....       MOV     DPTR,#(Send_data + 1)
   \   000167   E0           MOVX    A,@DPTR
   \   000168   F8           MOV     R0,A
   \   000169   7406         MOV     A,#0x6
   \   00016B   28           ADD     A,R0
   \   00016C   F8           MOV     R0,A
   \   00016D   E4           CLR     A
   \   00016E   3400         ADDC    A,#0x0
   \   000170   F9           MOV     R1,A
   \   000171   90....       MOV     DPTR,#chnnd
   \   000174   E0           MOVX    A,@DPTR
   \   000175   7020         JNZ     ??GenericAppCoordEB_15
   5086                    {chnnd[0][0]=1;
   \   000177   7401         MOV     A,#0x1
   \   000179   F0           MOVX    @DPTR,A
   5087                     for(char i=0;i<(Send_data[1]+6);i++)
   \   00017A   7C00         MOV     R4,#0x0
   5088                       {chnnd[0][1+i]=Send_data[i];
   \                     ??GenericAppCoordEB_16:
   \   00017C   12....       LCALL   ?Subroutine24 & 0xFFFF
   5089                       } 
   5090                    }
   \                     ??CrossCallReturnLabel_36:
   \   00017F   C0E0         PUSH    A
   \   000181   EA           MOV     A,R2
   \   000182   24..         ADD     A,#((chnnd + 1) & 0xff)
   \   000184   F582         MOV     DPL,A
   \   000186   E4           CLR     A
   \   000187   34..         ADDC    A,#(((chnnd + 1) >> 8) & 0xff)
   \   000189   F583         MOV     DPH,A
   \   00018B   D0E0         POP     A
   \   00018D   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000190   4003         JC      $+5
   \   000192   02....       LJMP    ??GenericAppCoordEB_14 & 0xFFFF
   \   000195   80E5         SJMP    ??GenericAppCoordEB_16
   5091                   else
   5092                   {if(!chnnd[1][0])
   \                     ??GenericAppCoordEB_15:
   \   000197   90....       MOV     DPTR,#(chnnd + 120)
   \   00019A   E0           MOVX    A,@DPTR
   \   00019B   701D         JNZ     ??GenericAppCoordEB_17
   5093                     {chnnd[1][0]=1;
   \   00019D   7401         MOV     A,#0x1
   \   00019F   F0           MOVX    @DPTR,A
   5094                     for(char i=0;i<(Send_data[1]+6);i++)
   \   0001A0   7C00         MOV     R4,#0x0
   5095                       {chnnd[1][1+i]=Send_data[i];
   \                     ??GenericAppCoordEB_18:
   \   0001A2   12....       LCALL   ?Subroutine24 & 0xFFFF
   5096                       } 
   5097                    }
   \                     ??CrossCallReturnLabel_37:
   \   0001A5   C0E0         PUSH    A
   \   0001A7   EA           MOV     A,R2
   \   0001A8   24..         ADD     A,#((chnnd + 121) & 0xff)
   \   0001AA   F582         MOV     DPL,A
   \   0001AC   E4           CLR     A
   \   0001AD   34..         ADDC    A,#(((chnnd + 121) >> 8) & 0xff)
   \   0001AF   F583         MOV     DPH,A
   \   0001B1   D0E0         POP     A
   \   0001B3   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   0001B6   5069         JNC     ??GenericAppCoordEB_14
   \   0001B8   80E8         SJMP    ??GenericAppCoordEB_18
   5098                    else
   5099                    {if(!chnnd[2][0])
   \                     ??GenericAppCoordEB_17:
   \   0001BA   90....       MOV     DPTR,#(chnnd + 240)
   \   0001BD   E0           MOVX    A,@DPTR
   \   0001BE   701D         JNZ     ??GenericAppCoordEB_19
   5100                     {chnnd[2][0]=1;
   \   0001C0   7401         MOV     A,#0x1
   \   0001C2   F0           MOVX    @DPTR,A
   5101                     for(char i=0;i<(Send_data[1]+6);i++)
   \   0001C3   7C00         MOV     R4,#0x0
   5102                       {chnnd[2][1+i]=Send_data[i];
   \                     ??GenericAppCoordEB_20:
   \   0001C5   12....       LCALL   ?Subroutine24 & 0xFFFF
   5103                       } 
   5104                    }
   \                     ??CrossCallReturnLabel_38:
   \   0001C8   C0E0         PUSH    A
   \   0001CA   EA           MOV     A,R2
   \   0001CB   24..         ADD     A,#((chnnd + 241) & 0xff)
   \   0001CD   F582         MOV     DPL,A
   \   0001CF   E4           CLR     A
   \   0001D0   34..         ADDC    A,#(((chnnd + 241) >> 8) & 0xff)
   \   0001D2   F583         MOV     DPH,A
   \   0001D4   D0E0         POP     A
   \   0001D6   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   0001D9   5046         JNC     ??GenericAppCoordEB_14
   \   0001DB   80E8         SJMP    ??GenericAppCoordEB_20
   5105                     else
   5106                     {if(!chnnd[3][0])
   \                     ??GenericAppCoordEB_19:
   \   0001DD   90....       MOV     DPTR,#(chnnd + 360)
   \   0001E0   E0           MOVX    A,@DPTR
   \   0001E1   701D         JNZ     ??GenericAppCoordEB_21
   5107                       {chnnd[3][0]=1;
   \   0001E3   7401         MOV     A,#0x1
   \   0001E5   F0           MOVX    @DPTR,A
   5108                     for(char i=0;i<(Send_data[1]+6);i++)
   \   0001E6   7C00         MOV     R4,#0x0
   5109                       {chnnd[3][1+i]=Send_data[i];
   \                     ??GenericAppCoordEB_22:
   \   0001E8   12....       LCALL   ?Subroutine24 & 0xFFFF
   5110                       } 
   5111                    }
   \                     ??CrossCallReturnLabel_39:
   \   0001EB   C0E0         PUSH    A
   \   0001ED   EA           MOV     A,R2
   \   0001EE   24..         ADD     A,#((chnnd + 105) & 0xff)
   \   0001F0   F582         MOV     DPL,A
   \   0001F2   E4           CLR     A
   \   0001F3   34..         ADDC    A,#(((chnnd + 361) >> 8) & 0xff)
   \   0001F5   F583         MOV     DPH,A
   \   0001F7   D0E0         POP     A
   \   0001F9   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   0001FC   5023         JNC     ??GenericAppCoordEB_14
   \   0001FE   80E8         SJMP    ??GenericAppCoordEB_22
   5112                      else
   5113                      {if(!chnnd[4][0])
   \                     ??GenericAppCoordEB_21:
   \   000200   90....       MOV     DPTR,#(chnnd + 480)
   \   000203   E0           MOVX    A,@DPTR
   \   000204   701B         JNZ     ??GenericAppCoordEB_14
   5114                        {chnnd[4][0]=1;
   \   000206   7401         MOV     A,#0x1
   \   000208   F0           MOVX    @DPTR,A
   5115                     for(char i=0;i<(Send_data[1]+6);i++)
   \   000209   7C00         MOV     R4,#0x0
   5116                       {chnnd[4][1+i]=Send_data[i];
   \                     ??GenericAppCoordEB_23:
   \   00020B   12....       LCALL   ?Subroutine24 & 0xFFFF
   5117                       } 
   5118                    }
   5119                       else
   5120                        {//²»Àí»á 
   5121                        }
   5122                      }
   5123                      
   5124                     }
   5125                    }
   5126                   }
   5127           }
   \                     ??CrossCallReturnLabel_40:
   \   00020E   C0E0         PUSH    A
   \   000210   EA           MOV     A,R2
   \   000211   24..         ADD     A,#((chnnd + 225) & 0xff)
   \   000213   F582         MOV     DPL,A
   \   000215   E4           CLR     A
   \   000216   34..         ADDC    A,#(((chnnd + 481) >> 8) & 0xff)
   \   000218   F583         MOV     DPH,A
   \   00021A   D0E0         POP     A
   \   00021C   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   00021F   40EA         JC      ??GenericAppCoordEB_23
   5128          }
   \                     ??GenericAppCoordEB_14:
   \   000221   02....       LJMP    ?Subroutine3 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   8C82         MOV     DPL,R4
   \   000002   AA82         MOV     R2,DPL
   \   000004   EA           MOV     A,R2
   \   000005   24..         ADD     A,#(Send_data & 0xff)
   \   000007   F582         MOV     DPL,A
   \   000009   E4           CLR     A
   \   00000A   34..         ADDC    A,#((Send_data >> 8) & 0xff)
   \   00000C   F583         MOV     DPH,A
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   0C           INC     R4
   \   000002   C3           CLR     C
   \   000003   EC           MOV     A,R4
   \   000004   98           SUBB    A,R0
   \   000005   E4           CLR     A
   \   000006   99           SUBB    A,R1
   \   000007   C3           CLR     C
   \   000008   65D0         XRL     A,PSW
   \   00000A   33           RLC     A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   90....       MOV     DPTR,#AF_RFnd
   \   000003   E0           MOVX    A,@DPTR
   \   000004   75F078       MOV     B,#0x78
   \   000007   A4           MUL     AB
   \   000008   24..         ADD     A,#(chnnd & 0xff)
   \   00000A   F582         MOV     DPL,A
   \   00000C   E5F0         MOV     A,B
   \   00000E   34..         ADDC    A,#((chnnd >> 8) & 0xff)
   \   000010   F583         MOV     DPH,A
   \   000012   E4           CLR     A
   \   000013   F0           MOVX    @DPTR,A
   \   000014   22           RET
   5129          
   5130          #endif
   5131          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   5132          void GenericAppEndDeviceEB(void) //100MS
   \                     GenericAppEndDeviceEB:
   5133          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   5134            if(openoff==0xaa)
   5135            {
   5136          #if((SENSOR_TYPE =='E')||(SENSOR_TYPE =='B')||(SENSOR_TYPE =='C')||(SENSOR_TYPE =='D')||(SENSOR_TYPE =='F')\
   5137            ||(SENSOR_TYPE =='U')||(SENSOR_TYPE ==0X10)||(SENSOR_TYPE ==0X21)||(SENSOR_TYPE ==0X11)\
   5138              ||(SENSOR_TYPE ==0X0F)||(SENSOR_TYPE ==0X13)||(SENSOR_TYPE ==0X14)||(SENSOR_TYPE ==0X17)\
   5139                ||(SENSOR_TYPE ==0X24)||(SENSOR_TYPE ==0X5A)||(SENSOR_TYPE ==0X5B)||(SENSOR_TYPE ==0X6A)||(SENSOR_TYPE =='A')\
   5140                  ||(SENSOR_TYPE =='J')||(SENSOR_TYPE =='L')||(SENSOR_TYPE =='M')||(SENSOR_TYPE =='N')\
   5141            ||(SENSOR_TYPE ==0X04)||(SENSOR_TYPE ==0X22)||(SENSOR_TYPE ==0X0C)||(SENSOR_TYPE ==0X16)||(SENSOR_TYPE ==0X19)\
   5142              ||(SENSOR_TYPE ==0X61)||(SENSOR_TYPE ==0X62)||(SENSOR_TYPE ==0X63)||(SENSOR_TYPE ==0X1A)||(SENSOR_TYPE ==0X33)\
   5143                ||(SENSOR_TYPE ==0X72) ||(SENSOR_TYPE ==0X34)||(SENSOR_TYPE ==0X35)||(SENSOR_TYPE ==0X36)||(SENSOR_TYPE ==0X37)\
   5144                  ||(SENSOR_TYPE ==0X38)||(SENSOR_TYPE ==0X39)||(SENSOR_TYPE ==0X3A)||(SENSOR_TYPE ==0X80)||(SENSOR_TYPE ==0X3D)\
   5145                    ||(SENSOR_TYPE ==0X81)||(SENSOR_TYPE ==0X82)||(SENSOR_TYPE ==0X3B)||(SENSOR_TYPE ==0X3C)||(SENSOR_TYPE ==0X3E)\
   5146                      ||(SENSOR_TYPE ==0X3F)||(SENSOR_TYPE ==0X84)||(SENSOR_TYPE ==0X85)||(SENSOR_TYPE ==0X75)||(SENSOR_TYPE ==0X78))
   5147          
   5148          #if defined( POWER_SAVING ) //ÖÕ¶ËÊ¹ÓÃ¼ÆÊý
   5149              GenericApp_applicationbuf+=GenericApp_time; 
   5150          #else
   5151                 if(GenericApp_time==1) //Â·ÓÉÆô¶¯¶¨Ê±
   5152                  {/* Ê¹ÄÜ¶¨Ê±Æ÷3µÄÒç³öÖÐ¶Ï */
   5153                  TIMER34_INIT(3);
   5154                   halSetTimer3Period(100);  //100MS
   5155                       T3_t1Val=(10*25);//25s //¶¨Ê±3
   5156                  IEN1 |= (0x01 << 3);             // Ê¹ÄÜTimer3µÄÖÐ¶ÏT3IE
   5157                  TIMER3_RUN(TRUE); 
   5158                  GenericApp_time=0;
   5159                  }
   5160          #endif 
   5161          #endif   
   5162             
   5163                     
   5164          #if(SENSOR_TYPE ==0XA3)  
   5165                if(AF_RF)
   5166                 {AF_RF=0;Send_data[1]=Send_datalend+8; Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ 
   5167                  for(char i=0;i<(Send_data[1]+6);i++)
   5168                       {chnndr[i]=Send_data[i];
   5169                       } 
   5170                  AF_RFn=10;//·¢ËÍ10´Î
   5171                  
   5172                 }
   5173                 if(AF_RFn)
   5174                 { 
   5175                 if(GenericApp_ON_OFF>0)GenericApp_ON_OFF--;
   5176                   if(GenericApp_ON_OFF<1)
   5177                   {
   5178                    GenericApp_DstAddr.addr.shortAddr=0XFFFF;
   5179                if ( AF_DataRequest( &GenericApp_DstAddr, &GenericApp_epDesc,
   5180                                 GENERICAPP_CLUSTERID,
   5181                                 (chnndr[1]+6),
   5182                                 chnndr, 
   5183                                 &GenericApp_TransID,
   5184                                 AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
   5185                    { AF_RFn=0; 
   5186                     // HalUARTWrite(HAL_UART_PORT_0, "0K",2);
   5187                    }
   5188                    else
   5189                     {AF_RFn--; 
   5190                     //HalUARTWrite(HAL_UART_PORT_0, chnndr,chnndr[1]+6);
   5191                      GenericApp_ON_OFF=(6+(10-AF_RFn)*3);
   5192                     }
   5193                   }
   5194                 }   
   5195                 
   5196                 
   5197                 
   5198          #endif 
   5199                 
   5200          #if(SENSOR_TYPE ==0X31) 
   5201                  if(AF_RF)
   5202                 {AF_RF=0;Send_data[1]=Send_datalend+8; Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ 
   5203                  for(char i=0;i<(Send_data[1]+6);i++)
   5204                       {chnndr[i]=Send_data[i];
   5205                       } 
   5206                  AF_RFn=10;//·¢ËÍ10´Î
   5207                  
   5208                 }
   5209                 if(AF_RFn)
   5210                 { 
   5211                 if(GenericApp_ON_OFF>0)GenericApp_ON_OFF--;
   5212                   if(GenericApp_ON_OFF<1)
   5213                   {
   5214                    GenericApp_DstAddr.addr.shortAddr=0XFFFF;
   5215                if ( AF_DataRequest( &GenericApp_DstAddr, &GenericApp_epDesc,
   5216                                 GENERICAPP_CLUSTERID,
   5217                                 (chnndr[1]+6),
   5218                                 chnndr, 
   5219                                 &GenericApp_TransID,
   5220                                 AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
   5221                    { AF_RFn=0; 
   5222                     // HalUARTWrite(HAL_UART_PORT_0, chnndr,chnndr[1]+6);
   5223                    }
   5224                    else
   5225                     {AF_RFn--; 
   5226                    // HalUARTWrite(HAL_UART_PORT_0, chnndr,chnndr[1]+6);
   5227                      GenericApp_ON_OFF=(6+(10-AF_RFn)*3);
   5228                     }
   5229                   }
   5230                 }
   5231                
   5232          #endif 
   5233                 
   5234          #if(SENSOR_TYPE ==0X05)
   5235          if(GenericApp_BX>1)
   5236            GenericApp_BX--;
   5237             else
   5238             {P1_6=0;
   5239              P1_7=0;
   5240             }
   5241          #endif  
   5242          
   5243          #if(SENSOR_TYPE ==0X40)
   5244          if(T_MG==0X01)
   5245          {LED_START++;
   5246          if(LED_START==5){P1_3=0; P1_4=1; }//LED1 ºìÉ« µãÁÁ
   5247          if(LED_START>10){LED_START=0;P1_3=1; P1_4=0; } //LED1 ºìÉ« Ï¨Ãð
   5248          }
   5249          #endif   
   5250          #if(SENSOR_TYPE ==0X12)
   5251          if(GenericApp_ON_OFF>20)
   5252             {GenericApp_BX++;
   5253             GenericApp_ON_OFF=0;
   5254             }
   5255             else GenericApp_ON_OFF++;
   5256             if(GenericApp_BX>5)
   5257             { P1_0=1;
   5258               P1_6=1;
   5259              P1_7=0;
   5260              halMcuWaitMs(280);
   5261              P1_6=1;
   5262              P1_7=1;
   5263             }
   5264          #endif 
   5265          #if(SENSOR_TYPE ==0X07)
   5266          if(AB==0x0A)
   5267          {
   5268          #if defined(UHF)
   5269          if(GenericApp_ON_OFF>2)
   5270            { //uint8  hr[6]={0XA5,0XFF,0X03,0X92,0X06,0XC0};
   5271              // uint8  hr[6]={0XA5,0XFF,0X03,0XC1,0X04,0X93};
   5272                uint8  hr[6]={0XA5,0XFF,0X03,0XC1,0X06,0X91};
   5273             GenericApp_ON_OFF=0;
   5274             GenericApp_applicationdata=0;
   5275               HalUARTWrite(HAL_UART_PORT_0, hr,6);
   5276             } 
   5277             else GenericApp_ON_OFF++;
   5278          #endif
   5279          #if defined(RLM100)
   5280          if(GenericApp_ON_OFF>0)
   5281            { uint8  hr[11]={0XAA,0X09,0X20,0X00,0X00,0X00,0X00,0X02,0x00,0x04,0x55};
   5282             GenericApp_ON_OFF=0;
   5283             GenericApp_applicationdata=0;
   5284               HalUARTWrite(HAL_UART_PORT_0, hr,11);
   5285             } 
   5286             else GenericApp_ON_OFF++;
   5287          #endif
   5288          }
   5289          #endif
   5290          #if(SENSOR_TYPE ==0X31)
   5291             if(car_op>1) ////¿ÉÁ¬Ðø¶Á3´ÎÊ±£¬¿ªÊ¼ÀÛ¼Æ¼ÆÊý
   5292             {car_op++;
   5293             if(car_op>50)//7Ãëºó¡£ÇåÁã£¬¿É¼ÌÐø¶Á¿¨
   5294               car_op=0;
   5295             } 
   5296             if((holzer==0)&&(P1_0==0))holzer=1; //×ö»ô¶û¶¨Î»±êÖ¾
   5297             if((holzer==2)&&(P1_0==0))//µÚ¶þ´Î¼ì²âµ½¶¨Î»±êÖ¾
   5298               {holzer=3; 
   5299                uint8 Car_Stop_Buff[3]={0xAA,0x2B,0xBB};
   5300               HalUARTWrite(HAL_UART_PORT_0,Car_Stop_Buff,3);
   5301               }
   5302              if((holzer==3)&&(P1_0==1))//µÚ¶þ´Î¼ì²âµ½¶¨Î»±êÖ¾½áÊø
   5303              { holzer=0;}
   5304          #endif
   5305          #if(SENSOR_TYPE ==0X16)
   5306            if(GenericApp_ON_OFF>50)
   5307             {  GenericApp_ON_OFF=0;
   5308             if((Send_data[7]-GenericApp_appIO>0)||(GenericApp_appIO-Send_data[7]>0)||((GenericApp_appIO==0)&&(Send_data[7])))
   5309             { Send_data[7]=GenericApp_appIO;
   5310              GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   5311             }GenericApp_appIO=0;
   5312             } 
   5313             else GenericApp_ON_OFF++;
   5314          #endif
   5315          #if(SENSOR_TYPE ==0X08)
   5316             #if defined(TRF7970A) 
   5317              if(GenericApp_ON_OFF==20)
   5318              printf("010A0003041001210000\n"); 
   5319          #endif
   5320             if(GenericApp_ON_OFF==23)
   5321             printf("010C00030410002101060000\n"); //ÉèÖÃ 15693¿¨
   5322             
   5323              if(GenericApp_ON_OFF>30)
   5324              { GenericApp_ON_OFF=25;
   5325             if(GenericApp_BX)
   5326                  printf("0109000304A0010000\n"); //¶Á¿¨ 14443A
   5327              else
   5328                printf("010B000304140701000000\n"); //¶Á¿¨  15693 
   5329              GenericApp_applicationdata=0;
   5330               //printf("010C00030410002101090000\n"); //ÉèÖÃ 14443A¿¨
   5331              // printf("0109000304A0010000\n"); //¶Á¿¨
   5332              }
   5333           GenericApp_ON_OFF++;
   5334          #endif
   5335          #if(SENSOR_TYPE ==0X0D)
   5336          #if defined(TGRD15693) 
   5337           
   5338              if(GenericApp_ON_OFF>5)
   5339             {if(!GenericApp_appIO)
   5340             {GenericApp_appIO=1;
   5341             printf(":1601020027EE43\n"); //ÉèÖÃ 15693¿¨
   5342             }
   5343             GenericApp_ON_OFF=0;
   5344             if(GenericApp_BX)
   5345                  printf(":1601020027EE43\n"); //¶Á¿¨ 14443A
   5346              else
   5347                printf(":1601020027EE43\n"); //¶Á¿¨  15693 
   5348              GenericApp_applicationdata=0;
   5349             } 
   5350             else GenericApp_ON_OFF++;
   5351          #endif
   5352          #if defined(PN532) 
   5353          if(GenericApp_ON_OFF>5)
   5354             {uint8  hr[24]={0X55, 0X55,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0Xff,0X03,0Xfd,0Xd4,0X14,0X01,0X17,0}; 
   5355              uint8 hr1[11]={0,0,0XFF,0X04,0XFC,0XD4,0X4A,0X02,0,0XE0,0};
   5356               if(!GenericApp_appIO)
   5357               {
   5358               GenericApp_appIO=1;
   5359             HalUARTWrite(HAL_UART_PORT_0, hr,24);//³õÊ¼»¯PN532µ½normal×´Ì¬
   5360             HalUARTWrite(HAL_UART_PORT_0, hr,24);//³õÊ¼»¯PN532µ½normal×´Ì¬
   5361             }
   5362               GenericApp_ON_OFF=0;
   5363               //  HalUARTWrite(HAL_UART_PORT_0, hr,24);//³õÊ¼»¯PN532µ½normal×´Ì¬
   5364                HalUARTWrite(HAL_UART_PORT_0, hr1,11); //¶Á¿¨  M1
   5365              GenericApp_applicationdata=0;
   5366             } 
   5367             else GenericApp_ON_OFF++;
   5368          #endif
   5369          #endif
   5370          #if(SENSOR_TYPE ==0X0B)
   5371             if(GenericApp_ON_OFF>5)
   5372             { uint8  hr[4]={0XF6,0XB9,0X16,0XFE};
   5373             GenericApp_ON_OFF=0;
   5374             GenericApp_applicationdata=0;
   5375               HalUARTWrite(HAL_UART_PORT_0, hr,4);
   5376             } 
   5377             else GenericApp_ON_OFF++;
   5378          #endif
   5379          #if(SENSOR_TYPE ==0X78)
   5380             
   5381          if(GenericApp_applicationbuf>6000)  
   5382           { GenericApp_applicationbuf=0;
   5383           GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   5384          }
   5385          #endif
   5386          #if(SENSOR_TYPE ==0X72)
   5387           if(((Send_data[8]-T_MUMPT1)>0X05)||((T_MUMPT1-Send_data[8])>0X05)||((Send_data[8]==0)&&(T_MUMPT1!=0)))
   5388            {T_MUMPT1=Send_data[8];
   5389             GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   5390            }
   5391          
   5392          if(GenericApp_applicationbuf>6000)  
   5393           { GenericApp_applicationbuf=0;
   5394           GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   5395          }
   5396          #endif
   5397          
   5398          #if((SENSOR_TYPE =='A')||(SENSOR_TYPE =='J')||(SENSOR_TYPE =='L')||(SENSOR_TYPE =='M')||(SENSOR_TYPE =='N')\
   5399            ||(SENSOR_TYPE ==0X22)||(SENSOR_TYPE ==0X0C)||(SENSOR_TYPE ==0X19)\
   5400              ||(SENSOR_TYPE ==0X62)||(SENSOR_TYPE ==0X63) ||(SENSOR_TYPE ==0X34)||(SENSOR_TYPE ==0X35)||(SENSOR_TYPE ==0X36)\
   5401                ||(SENSOR_TYPE ==0X37)||(SENSOR_TYPE ==0X38)||(SENSOR_TYPE ==0X39)||(SENSOR_TYPE ==0X3A)||(SENSOR_TYPE ==0X3E)\
   5402                  ||(SENSOR_TYPE ==0X3F)||(SENSOR_TYPE ==0X75))//¿ª¹ØÁ¿¶¨Ê±·´À¡
   5403          if(GenericApp_ON_OFF>10)
   5404           { GenericApp_ON_OFF=0;
   5405           Send_data[8]=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5406           #if((SENSOR_TYPE =='J') ||(SENSOR_TYPE ==0X34)||(SENSOR_TYPE ==0X35)||(SENSOR_TYPE ==0X36)||(SENSOR_TYPE ==0X37)\
   5407             ||(SENSOR_TYPE ==0X38)||(SENSOR_TYPE ==0X39)||(SENSOR_TYPE ==0X3A)||(SENSOR_TYPE ==0X3E)||(SENSOR_TYPE ==0X75))
   5408            if(Send_data[8]<0X0F)
   5409              Send_data[8]=0;
   5410            else
   5411            if(Send_data[8]<0X15)
   5412              Send_data[8]-=0X0D;
   5413           #endif
   5414            
   5415          #if(SENSOR_TYPE ==0X22)
   5416            //  if(Send_data[8]> T_MUMPTZ1)
   5417             //   T_MUMPTZ1=Send_data[8];
   5418            // Send_data[8]= T_MUMPTZ1-Send_data[8];
   5419          #endif
   5420          #if(SENSOR_TYPE ==0X3F)
   5421           //if(((Send_data[8]-T_MUMPT1)>0X04)||((T_MUMPT1-Send_data[8])>0X04)||((Send_data[8]==0)&&(T_MUMPT1!=0)))
   5422          if((((Send_data[8]>T_MUMPT1)? Send_data[8]-T_MUMPT1:T_MUMPT1-Send_data[8])>0X04) ||((Send_data[8]==0)&&(T_MUMPT1!=0)))
   5423            {T_MUMPT1=Send_data[8];
   5424             GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   5425            }
   5426          #endif
   5427          #if((SENSOR_TYPE =='J')||(SENSOR_TYPE ==0X62)||(SENSOR_TYPE ==0X63) ||(SENSOR_TYPE ==0X34)\
   5428            ||(SENSOR_TYPE ==0X35)||(SENSOR_TYPE ==0X36)||(SENSOR_TYPE ==0X37)||(SENSOR_TYPE ==0X38)||(SENSOR_TYPE ==0X39)\
   5429              ||(SENSOR_TYPE ==0X3A)||(SENSOR_TYPE ==0X3E)||(SENSOR_TYPE ==0X0C)||(SENSOR_TYPE ==0X75))//¿ª¹ØÁ¿¶¨Ê±·´À¡
   5430          //  if(((Send_data[8]>T_MUMPT1)? Send_data[8]-T_MUMPT1:T_MUMPT1-Send_data[8])>0X04) ||((Send_data[8]==0)&&(T_MUMPT1!=0)))
   5431            if((((Send_data[8]>T_MUMPT1)? Send_data[8]-T_MUMPT1:T_MUMPT1-Send_data[8])>0X0A)||((Send_data[8]==0)&&(T_MUMPT1!=0)))
   5432            {T_MUMPT1=Send_data[8];
   5433             GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   5434            }
   5435          #endif
   5436          #if((SENSOR_TYPE ==0X22))//¿ª¹ØÁ¿¶¨Ê±·´À¡
   5437           if((((Send_data[8]>T_MUMPT1)? Send_data[8]-T_MUMPT1:T_MUMPT1-Send_data[8])>0X0A)||((Send_data[8]==0)&&(T_MUMPT1!=0)))
   5438            {T_MUMPT1=Send_data[8];
   5439            T_MUMPTS=T_MUMPT1;
   5440             T_MUMPTS=498+(T_MUMPTS*199);
   5441            Send_data[8]=(T_MUMPTS/256);
   5442            Send_data[9]=(T_MUMPTS%256);
   5443            
   5444             GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   5445            }
   5446          #endif
   5447          
   5448          
   5449           if( GenericApp_sbum!=P2_0)
   5450            {
   5451              GenericApp_sbum=P2_0;
   5452              //Send_data[8]=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5453            if(GenericApp_sbum)Send_data[7]=1;
   5454            else Send_data[7]=0;
   5455             Send_data[8]=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5456            T_MUMPTS=Send_data[8];
   5457              T_MUMPTS=498+(T_MUMPTS*199);
   5458            Send_data[8]=(T_MUMPTS/256);
   5459            Send_data[9]=(T_MUMPTS%256);
   5460            GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   5461           //  halMcuWaitMs(1000);  //ÑÓÊ± 1000ms
   5462            }
   5463           }else GenericApp_ON_OFF++; 
   5464          if(GenericApp_applicationbuf>6000)  
   5465           { GenericApp_applicationbuf=0;
   5466              if(P2_0)
   5467                Send_data[7]=1;
   5468                else Send_data[7]=0;
   5469           Send_data[8]=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5470            T_MUMPTS=Send_data[8];
   5471               T_MUMPTS=498+(T_MUMPTS*199);
   5472            Send_data[8]=(T_MUMPTS/256);
   5473            Send_data[9]=(T_MUMPTS%256);
   5474           GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   5475          }
   5476          
   5477          #endif
   5478          
   5479          #if((SENSOR_TYPE ==0X61))//¿ª¹ØÁ¿¶¨Ê±·´À¡
   5480          if(LMOUT)
   5481          { if(T_MUMPT1<2) GenericApp_applicationbuf=6001;
   5482          GenericApp_ON_OFF=2;
   5483           Send_data[7]=1; 
   5484          T_MUMPT1=2;
   5485          }
   5486          else 
   5487          if(GenericApp_ON_OFF!=2)
   5488            {GenericApp_ON_OFF=0;}
   5489          
   5490          if(GenericApp_sbum>200)
   5491           { GenericApp_sbum=0;
   5492           if((GenericApp_ON_OFF==0)&&(T_MUMPT1>0))
   5493           { GenericApp_applicationbuf=6001;
   5494             Send_data[7]=0; 
   5495             if(T_MUMPT1>0)T_MUMPT1--;
   5496           }
   5497           if(GenericApp_ON_OFF==2)
   5498           { GenericApp_applicationbuf=6001;
   5499             Send_data[7]=1; 
   5500             GenericApp_ON_OFF=0;
   5501           }
   5502           }else GenericApp_sbum++;
   5503          if(GenericApp_applicationbuf>6000)  
   5504           { GenericApp_applicationbuf=0;
   5505           GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   5506          }
   5507          #endif
   5508          #if((SENSOR_TYPE ==0X04))
   5509            if( GenericApp_sbum!=P2_0)
   5510            {
   5511              GenericApp_sbum=P2_0; 
   5512              GenericApp_BX++;
   5513            } else
   5514                {
   5515                  if(GenericApp_applicationbuf>0)
   5516                  {GenericApp_applicationbuf+=100;
   5517                  }
   5518                }
   5519            if(GenericApp_BX>5)
   5520            { Send_data[7]=1; 
   5521             GenericApp_applicationbuf=1;
   5522            GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   5523            }
   5524          if(GenericApp_applicationbuf>6000)  
   5525           { GenericApp_applicationbuf=0;
   5526             Send_data[7]=0; 
   5527           GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   5528          }
   5529          #endif 
   5530          #if(SENSOR_TYPE ==0X77)
   5531          if(P1_0!=GenericApp_applicationdata)
   5532          {GenericApp_applicationdata=P1_0;
   5533              GenericApp_appIO=0X01;
   5534          }
   5535            if(GenericApp_appIO!=0)
   5536            {
   5537              GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   5538              GenericApp_appIO=0;
   5539            }
   5540          #endif 
   5541          #if(SENSOR_TYPE =='I')
   5542          unsigned int key=0;
   5543          key=((key+P1)<<4);
   5544          key+=((P0>>1)&0X08);
   5545          key+=(P2&0X07);
   5546          if(key!=GenericApp_applicationdata)
   5547          {GenericApp_applicationdata=key;
   5548              if(P1_0==0)
   5549              GenericApp_appIO=0X03;
   5550              if(P1_1==0)
   5551              GenericApp_appIO=0X0a;
   5552              if(P1_2==0)
   5553              GenericApp_appIO=0X05;
   5554              if(P1_3==0)
   5555              GenericApp_appIO=0X06;
   5556              if(P1_4==0)
   5557              GenericApp_appIO=0X07;
   5558              if(P1_5==0)
   5559              GenericApp_appIO=0X08;
   5560              if(P1_6==0)
   5561              GenericApp_appIO=0X09;
   5562              if(P1_7==0)
   5563              GenericApp_appIO=0X04;
   5564              if(P2_0==0)
   5565              GenericApp_appIO=0X0b;
   5566              if(P2_1==0)
   5567              GenericApp_appIO=0X0c;
   5568              if(P2_2==0)
   5569              GenericApp_appIO=0X0d;
   5570              if(P0_4==0)
   5571              GenericApp_appIO=0X0e;
   5572            } 
   5573              Send_data[8]=0;
   5574              Send_data[8]+=(P1_0+P1_1+P1_2+P1_3+P1_4+P1_5);
   5575            if((GenericApp_appIO!=0)||( Send_data[8]!=Send_data[9]))
   5576            { //ÈËÁ÷Á¿Í³¼ÆÊýÁ¿
   5577              Send_data[9]= Send_data[8];
   5578              //ÈËÁ÷Á¿Í³¼ÆÊýÁ¿
   5579              GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   5580              GenericApp_appIO=0;
   5581            }
   5582          #endif
   5583          #if(SENSOR_TYPE ==0X24)
   5584          if(GenericApp_applicationbuf>6000)
   5585          {GenericApp_applicationbuf=0;
   5586            uint8 h=0,l=0,cs,flag=0; //¶¨Òå±äÁ¿
   5587            float timer=0,len=0;
   5588            for(cs=0;cs<5;cs++) //Á¬Ðø²âÎå´Î
   5589            {timer=0;h=0;l=0;len=0;flag=0;       //³õÊ¼»¯±äÁ¿
   5590              P1_2=1;           //À­¸ß´¥·¢Î»
   5591              halMcuWaitUs(20);  //ÑÓÊ± 20us
   5592              P1_2=0;           //À­µÍ´¥·¢Î»´ËÊ±ÒÑ¾­·¢³ö²âÊÔ²¨
   5593              IRCON=0;         //³õÊ¼»¯T1¶¨Ê±Æ÷
   5594              T1CNTH=0;
   5595              T1CNTL=0;          //Ð´ÈëÈÎÒâÖµ  H L ÇåÁã 0x0000
   5596              while(P1_1==0);  //µÈ´ý»ØÏìÐÅºÅ
   5597              while(P1_1==1)  //ÊÕµ½»ØÏìÐÅºÅÊ±¿ªÆô¶¨Ê±Æ÷
   5598              { if(flag==0)
   5599                {  flag=1;
   5600                  T1CTL = 0x0D;    //ÉèÖÃ¶¨Ê±Æ÷¼ÆÊý  1/128·ÖÆµ   0X0000-0XFFFFÑ­»·¼ÆÊý
   5601                  T1CNTH=0;
   5602                  T1CNTL=0;
   5603                 // T1STAT = 0x21;
   5604                }}
   5605              h=T1CNTH; //»ØÏìÐÅºÅ½áÊøÊ±È¡³ö¶¨Ê±Æ÷µÄÖµ
   5606              l=T1CNTL; //¶ÁÈ¡ H Ö®Ç°±ØÐë¶ÁÈ¡ L ; 
   5607              timer+=(h*256); 
   5608              timer+=l;
   5609              len=(timer*128/(58*2*16))*10; //ºÁÃ×Îªµ¥Î»  ¼ÆËã¾àÀë
   5610              halMcuWaitMs(60); //Ã¿´Î²âÁ¿ÐèÒª¼ä¸ô60ms
   5611            } 
   5612            CSB_Len_H=(uint8)(len/256);
   5613            CSB_Len_L=(uint8)((uint16)len%256); 
   5614              GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   5615            }
   5616          #endif 
   5617          #if(SENSOR_TYPE ==0X80)
   5618          if(P2_0==0)
   5619          {      int pVc=0;
   5620                 pVc=0;
   5621                  IRCON=0;         //³õÊ¼»¯T1¶¨Ê±Æ÷
   5622                  T1CTL = 0x05;    //ÉèÖÃ¶¨Ê±Æ÷¼ÆÊý  1/8   0X0000-0XFFFF   Ò»¸öÑ­»· 16ms   1/128=262ms
   5623                  T1CNTL=0;
   5624                  CSB_Len_L=0;  
   5625              while((pVc<400)&&(CSB_Len_L==0))  //²âËÙ½áÊø   ²âÊÔÊ±¼ä³¬¹ý6s ÍË³ö
   5626             {  if(T1IF)
   5627                {pVc++;T1IF=0;}
   5628                 if(P2_0==1)CSB_Len_L=0X01;
   5629             };
   5630             if(pVc<400)  //²âÊÔÊ±¼ä³¬¹ý6s ÍË³ö
   5631             {
   5632             pVc=16*pVc;  //µ¥Î» ms
   5633              CSB_Len_H=(uint8)(pVc/256);
   5634              CSB_Len_L=(uint8)((uint16)pVc%256); 
   5635              ////////////////////////////////////////////////////////////////////////////////////////////
   5636          //OLEDÆÁÏÔÊ¾ÄÚÈÝ
   5637          //OLED_Init(); //OLED³õÊ¼»¯ 
   5638          char *s=0;
   5639          sprintf(s, "%05d", pVc); 
   5640          OLED_P8x16Str(0,6,s);//µÚËÄÐÐ -- 8x16µÄÏÔÊ¾µ¥ÔªÏÔÊ¾ASCIIÂë
   5641          OLED_P8x16Str(40,6,"mS");//µÚËÄÐÐ -- 8x16µÄÏÔÊ¾µ¥ÔªÏÔÊ¾ASCIIÂë
   5642              GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   5643             }
   5644          }
   5645          if(GenericApp_applicationbuf>6000)
   5646          {GenericApp_applicationbuf=0;
   5647          GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   5648          }
   5649          #endif 
   5650          #if(SENSOR_TYPE ==0X64) 
   5651          P1_0=0;P1_2=1;P1_4=1;P1_6=1;
   5652          if(P1_1==0){while(P1_1==0);GenericApp_applicationdata=0X01;}
   5653          if(P1_3==0){while(P1_3==0);GenericApp_applicationdata=0X02;}
   5654          if(P1_5==0){while(P1_5==0);GenericApp_applicationdata=0X03;}
   5655          if(P1_7==0){while(P1_7==0);GenericApp_applicationdata=0X04;}
   5656          P1_0=1;P1_2=0;P1_4=1;P1_6=1;
   5657          if(P1_1==0){while(P1_1==0);GenericApp_applicationdata=0X05;}
   5658          if(P1_3==0){while(P1_3==0);GenericApp_applicationdata=0X06;}
   5659          if(P1_5==0){while(P1_5==0);GenericApp_applicationdata=0X07;}
   5660          if(P1_7==0){while(P1_7==0);GenericApp_applicationdata=0X08;}
   5661          P1_0=1;P1_2=1;P1_4=0;P1_6=1;
   5662          if(P1_1==0){while(P1_1==0);GenericApp_applicationdata=0X09;}
   5663          if(P1_3==0){while(P1_3==0);GenericApp_applicationdata=0X0A;}
   5664          if(P1_5==0){while(P1_5==0);GenericApp_applicationdata=0X0B;}
   5665          if(P1_7==0){while(P1_7==0);GenericApp_applicationdata=0X0C;}
   5666          P1_0=1;P1_2=1;P1_4=1;P1_6=0;
   5667          P1_1=1;
   5668          if(P1_1==0){while(P1_1==0);GenericApp_applicationdata=0X0D;}
   5669          if(P1_3==0){while(P1_3==0);GenericApp_applicationdata=0X0E;}
   5670          if(P1_5==0){while(P1_5==0);GenericApp_applicationdata=0X0F;}
   5671          if(P1_7==0){while(P1_7==0);GenericApp_applicationdata=0X10;}
   5672            if(GenericApp_applicationdata!=0)
   5673            {GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý   
   5674              GenericApp_applicationdata=0;
   5675            }
   5676          #endif
   5677          
   5678          /*#if(SENSOR_TYPE =='K')
   5679           if(((~P1)&0X06)!=GenericApp_appIO)
   5680            {
   5681             GenericApp_appIO=((~P1)&0X06);
   5682             GenericApp_ON_OFF=(GenericApp_appIO>>0X01);
   5683             GenericApp_applicationbuf=2;
   5684             GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   5685            }
   5686          #endif
   5687          */
   5688          
   5689          #if(SENSOR_TYPE =='K')
   5690           if(T_MG>0X01)
   5691            {T_MG--;
   5692            if(T_MG==0X01){P1_0=1; T_MG=0X00;}
   5693            }
   5694          #endif
   5695          #if(SENSOR_TYPE ==0X79)
   5696          if((PDI==0XD1)||(PDI==0XD2))GenericApp_ON_OFF=11;
   5697          if(GenericApp_ON_OFF>10)
   5698           { GenericApp_ON_OFF=0;
   5699           if(ERR_TEMP<5)
   5700           {
   5701           uint  data;
   5702            valuen humi_val,temp_val;							    
   5703            unsigned char error,checksum; 
   5704           error=0;  
   5705                     error+=s_measure( &Send_data[7],&checksum,HUMI);  //measure humidity 
   5706                     error+=s_measure( &Send_data[9],&checksum,TEMP);  //measure temperature 
   5707                     if(error!=0){ s_connectionreset(); ERR_TEMP++;}                 //in case of an error: connection  
   5708                    else 
   5709                    { humi_val.i=Send_data[7]*256+Send_data[8];
   5710                      temp_val.i=Send_data[9]*256+Send_data[10];
   5711                      humi_val.f=(float)humi_val.i;                   //converts integer to float
   5712                      temp_val.f=(float)temp_val.i;                   //converts integer to float
   5713                      calc_dht90(&humi_val.f,&temp_val.f);            //calculate humidity, temperature
   5714            data=(uint)(100*humi_val.f);   
   5715           Send_data[10]=(uint8)(data/ 100);
   5716            data=(uint)(100*temp_val.f);              
   5717            Send_data[9]=(uint8)(data / 100);
   5718                    }
   5719           
   5720          if((((Send_data[9]>T_TEMP)? Send_data[9]-T_TEMP:T_TEMP-Send_data[9])>0X01)||(PDI==0XD1)) //ÎÂ¶ÈÖµ 
   5721            {T_TEMP=Send_data[9];
   5722            Send_data[7]=0X03;
   5723             Send_data[8]=0XD1;
   5724          Send_datalend=0x05;
   5725          GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   5726            }
   5727            }
   5728            Send_data[9]=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5729          if((((Send_data[9]>T_ADC)? Send_data[9]-T_ADC:T_ADC-Send_data[9])>0X0A)||(PDI==0XD2)) //AD²É¼¯ÊýÖµ
   5730            {T_ADC=Send_data[9];
   5731            Send_data[9]=(uint8)(((float)(Send_data[9]*11))/17);
   5732              Send_data[7]=0X03;
   5733             Send_data[8]=0XD2;
   5734             Send_data[10]=(165-Send_data[9]);
   5735          Send_datalend=0x05;
   5736          GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   5737            }
   5738            PDI=0;
   5739           }else GenericApp_ON_OFF++;
   5740          
   5741          #endif  
   5742          #if(SENSOR_TYPE ==0X83)
   5743          if(GenericApp_ON_OFF>0)
   5744          {GenericApp_ON_OFF=0;
   5745           if(!P0_5)
   5746            {P1_0=~P1_0;//P1_2=~P1_2; 
   5747            while(!P0_5);
   5748            }
   5749          }GenericApp_ON_OFF++;
   5750          #endif
   5751          #if(SENSOR_TYPE ==0X03)
   5752             if(P1_4)
   5753             {
   5754             // if((P1&0X0F)!=GenericApp_appIO)
   5755              {
   5756              GenericApp_appIO=(P1&0X0F);
   5757              GenericApp_SendTheMessage();
   5758               halMcuWaitMs(1000); 
   5759               }
   5760             }
   5761           else 
   5762             if(!(P1&0X0F))
   5763             GenericApp_appIO=0XFF;
   5764          #endif 
   5765          #if(SENSOR_TYPE ==0X10)
   5766          if(GenericApp_applicationbuf>6000)
   5767          {GenericApp_applicationbuf=0;
   5768          GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5769          GenericApp_sbum=(3233/(GenericApp_sbum+3))-11;//GP2Y0A02YKOF (20-150)cm
   5770          Send_data[7]=GenericApp_sbum;
   5771          GenericApp_SendTheMessage();
   5772          } 
   5773          #endif 
   5774          #if(SENSOR_TYPE ==0X0F)
   5775          if(GenericApp_applicationbuf>6000)
   5776          {GenericApp_applicationbuf=0;
   5777          GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5778          
   5779          GenericApp_sbum=((200*GenericApp_sbum)/255);//(0-200)(0-200CM)
   5780          
   5781          Send_data[7]=GenericApp_sbum;
   5782          GenericApp_SendTheMessage();
   5783          } 
   5784          #endif 
   5785          #if(SENSOR_TYPE ==0X17)
   5786          if(GenericApp_ON_OFF>5)
   5787          {GenericApp_ON_OFF=0;
   5788          GenericApp_switch=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);//-0x68;
   5789          if(GenericApp_switch>0x44)
   5790          Send_data[7]=3;
   5791          if(GenericApp_switch<0x45)
   5792          Send_data[7]=2;
   5793          if(GenericApp_switch<0x35)
   5794          Send_data[7]=1;
   5795          if(GenericApp_switch<0x32)
   5796          Send_data[7]=0;
   5797          if(Send_data[7]!=GenericApp_appIO)
   5798          {GenericApp_appIO=Send_data[7];
   5799          GenericApp_switchk2=0;
   5800          }
   5801          else GenericApp_switchk2++;
   5802          if(Send_data[7]==0)
   5803          {
   5804            if(GenericApp_switchk2==10)
   5805          GenericApp_SendTheMessage();
   5806          }
   5807          else
   5808          {
   5809          if(GenericApp_switchk2==2)
   5810          GenericApp_SendTheMessage();
   5811          }
   5812          //Send_data[7]=GenericApp_switch;
   5813          //GenericApp_SendTheMessage();
   5814          
   5815          
   5816          } 
   5817          else GenericApp_ON_OFF++;
   5818          #endif
   5819          #if(SENSOR_TYPE ==0X11) 
   5820          if(GenericApp_applicationbuf>6000)
   5821          {GenericApp_applicationbuf=0;
   5822          GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5823          GenericApp_sbum=((0X15*GenericApp_sbum)/0X17);
   5824          Send_data[7]=GenericApp_sbum;
   5825          Send_data[8]=0XAA;
   5826          GenericApp_SendTheMessage();
   5827          }
   5828          #endif 
   5829          #if((SENSOR_TYPE ==0X1A)) 
   5830          if(GenericApp_ON_OFF>10)
   5831           { GenericApp_ON_OFF=0;
   5832           GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5833            if(((GenericApp_sbum-T_MUMPT1)>0X0A)||((T_MUMPT1-GenericApp_sbum)>0X0A)||((GenericApp_sbum==0)&&(T_MUMPT1!=0)))
   5834            {T_MUMPT1=GenericApp_sbum;
   5835             GenericApp_applicationbuf=6001;
   5836            }
   5837           }else GenericApp_ON_OFF++;
   5838          if(GenericApp_applicationbuf>6000)
   5839          {GenericApp_applicationbuf=0;
   5840          #if(SENSOR_TYPE ==0X1A) 
   5841          GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5842          //GenericApp_sbum=((0X15*GenericApp_sbum)/0X17);
   5843          Send_data[7]=GenericApp_sbum;
   5844          Send_data[8]=0XAA;
   5845          #endif 
   5846          GenericApp_SendTheMessage();
   5847          }
   5848          #endif 
   5849          #if((SENSOR_TYPE ==0X3D)||(SENSOR_TYPE ==0X3B)||(SENSOR_TYPE ==0X3C))
   5850          if(GenericApp_ON_OFF>10)
   5851           { GenericApp_ON_OFF=0;
   5852           GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5853          if(((GenericApp_sbum>T_MUMPT1)? GenericApp_sbum-T_MUMPT1:T_MUMPT1-GenericApp_sbum)>0X0A) 
   5854            {
   5855              T_MUMPT1=GenericApp_sbum;
   5856             GenericApp_applicationbuf=6001;
   5857            }
   5858           }else GenericApp_ON_OFF++;
   5859          if(GenericApp_applicationbuf>6000)
   5860          {GenericApp_applicationbuf=0;
   5861          GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5862          #if(SENSOR_TYPE ==0X3B)            // ²»·ÖÑ¹Ö±Á¬  UVM-30×ÏÍâÏß 0-1V 
   5863          Send_data[9]=(GenericApp_sbum/4); //µ¥Î» UV index
   5864          #endif 
   5865          #if(SENSOR_TYPE ==0X3C)   //SCA60C:N1000060 0-180  0.5-4.5  10K 10K·ÖÑ¹  0-180  0.25-2.25V  ¶ÔÓ¦08H-68H ÖÐ¼äÆ½ºâ34H
   5866          if(GenericApp_sbum>0X5E) Send_data[8]=180; //×î´ó½Ç¶È180¶È
   5867          else if(GenericApp_sbum<0X0A) Send_data[8]=0; //×îÐ¡½Ç¶È0¶È
   5868          else if(((GenericApp_sbum>0X34)? GenericApp_sbum-0X34:0X34-GenericApp_sbum)<3) Send_data[8]=90; //Æ½ºâµã 90¶È
   5869          else Send_data[8]=((int)(((float)GenericApp_sbum-0x08)*2.1));
   5870          if(Send_data[8]>180)Send_data[8]=180;
   5871          #endif 
   5872          #if(SENSOR_TYPE ==0X3D)
   5873          if(GenericApp_sbum>0x34){Send_data[8]=0X01;GenericApp_sbum=130*(GenericApp_sbum-0X34);}  //ÕýÏòµçÁ÷   5VÊä³ö 10k 10K·ÖÑ¹µ½2.5V   0X34Ïàµ±ÓÚ 0A 1250mV   1=130ma=24mV  185mv=1A
   5874          else {Send_data[8]=0;GenericApp_sbum=130*(0X34-GenericApp_sbum);}
   5875          Send_data[9]=GenericApp_sbum>>8;
   5876          Send_data[10]=GenericApp_sbum;
   5877          #endif 
   5878          GenericApp_SendTheMessage();
   5879          }
   5880          #endif 
   5881          #if(SENSOR_TYPE ==0X84)
   5882          if(GenericApp_ON_OFF>10)
   5883           { GenericApp_ON_OFF=0;
   5884            GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   5885             //SCA100T:-D01 0-60¶È  -D02 0-180¶È   0.5-4.5  10K 10K·ÖÑ¹  0-180  0.25-2.25V  ¶ÔÓ¦00H-63H ÖÐ¼äÆ½ºâ31H
   5886          if(GenericApp_sbum>0X60) Send_data[8]=60; //×î´ó½Ç¶È180¶È
   5887          else if(GenericApp_sbum<0X02) Send_data[8]=0; //×îÐ¡½Ç¶È0¶È
   5888          else if(((GenericApp_sbum>0X31)? GenericApp_sbum-0X31:0X31-GenericApp_sbum)<3) Send_data[8]=30; //Æ½ºâµã 30¶È
   5889          else Send_data[8]=((int)((((float)GenericApp_sbum)*60)/0X60));
   5890          if(Send_data[8]>60)Send_data[8]=60;
   5891          //Send_data[8]=GenericApp_sbum;
   5892          
   5893          GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN5, HAL_ADC_RESOLUTION_8);
   5894              //SCA100T:-D01 0-60¶È  -D02 0-180¶È   0.5-4.5  10K 10K·ÖÑ¹  0-180  0.25-2.25V  ¶ÔÓ¦00H-63H ÖÐ¼äÆ½ºâ31H
   5895          if(GenericApp_sbum>0X60) Send_data[9]=60; //×î´ó½Ç¶È180¶È
   5896          else if(GenericApp_sbum<0X02) Send_data[9]=0; //×îÐ¡½Ç¶È0¶È
   5897          else if(((GenericApp_sbum>0X31)? GenericApp_sbum-0X31:0X31-GenericApp_sbum)<3) Send_data[9]=30; //Æ½ºâµã 30¶È
   5898          else Send_data[9]=((int)((((float)GenericApp_sbum)*60)/0X60));
   5899          if(Send_data[9]>60)Send_data[9]=60;
   5900          //Send_data[9]=GenericApp_sbum;
   5901          
   5902          if((Send_data[8]==30)&&(Send_data[9]==30)){P1_1=1; P1_2=1;P1_3=1; P1_4=1;}
   5903          if((Send_data[8]==30)&&(Send_data[9]<30)){P1_1=0; P1_2=0;P1_3=1; P1_4=1;}
   5904          if((Send_data[8]==30)&&(Send_data[9]>30)){P1_1=1; P1_2=1;P1_3=0; P1_4=0;}
   5905          if((Send_data[8]<30)&&(Send_data[9]==30)){P1_1=0; P1_2=1;P1_3=1; P1_4=0;}
   5906          if((Send_data[8]<30)&&(Send_data[9]<30)){P1_1=0; P1_2=0;P1_3=1; P1_4=0;}
   5907          if((Send_data[8]<30)&&(Send_data[9]>30)){P1_1=0; P1_2=1;P1_3=0; P1_4=0;}
   5908          if((Send_data[8]>30)&&(Send_data[9]==30)){P1_1=1; P1_2=0;P1_3=0; P1_4=1;}
   5909          if((Send_data[8]>30)&&(Send_data[9]<30)){P1_1=0; P1_2=0;P1_3=0; P1_4=1;}
   5910          if((Send_data[8]>30)&&(Send_data[9]>30)){P1_1=1; P1_2=0;P1_3=0; P1_4=0;}
   5911          
   5912          GenericApp_sbum=Send_data[8]+Send_data[9];
   5913          if(((GenericApp_sbum>T_MUMPT1)? GenericApp_sbum-T_MUMPT1:T_MUMPT1-GenericApp_sbum)>0X0A) 
   5914            {
   5915              T_MUMPT1=GenericApp_sbum;
   5916             GenericApp_applicationbuf=6001;
   5917            }
   5918           }else GenericApp_ON_OFF++;
   5919          
   5920          if(GenericApp_applicationbuf>6000)
   5921          {GenericApp_applicationbuf=0;
   5922          GenericApp_SendTheMessage();
   5923          }
   5924          #endif 
   5925          #if(SENSOR_TYPE ==0X18)
   5926           if(GenericApp_uart_485==1)
   5927             P1_0=0; 
   5928            if(GenericApp_uart_485==0)
   5929             GenericApp_uart_485=1; 
   5930           if(GenericApp_applicationbuf>6000)
   5931          { P1_0=1; 
   5932           GenericApp_uart_485=0; 
   5933            GenericApp_applicationbuf=0;
   5934           uint8  hr[8]={0xA1,0X04,0X01,0X74,0XD0,0X16,0X0A,0X0D};
   5935           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5936           hr[2]=0x02;hr[4]=0xD3;hr[5]=0x12;
   5937           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5938           hr[2]=0x03;hr[4]=0xd2;hr[5]=0x12;
   5939           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5940            hr[2]=0x04;hr[4]=0xd5;hr[5]=0x0e;
   5941           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5942            hr[2]=0x05;hr[4]=0xD4;hr[5]=0x0E;
   5943           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5944            hr[2]=0x06;hr[4]=0xd7;hr[5]=0x0a;
   5945           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5946            hr[2]=0x07;hr[4]=0xd6;hr[5]=0x0a;
   5947           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5948           hr[2]=0x08;hr[4]=0xd9;hr[5]=0x06;
   5949           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5950            hr[2]=0x09;hr[4]=0xd8;hr[5]=0x06;
   5951           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5952             hr[2]=0x0A;hr[4]=0xdB;hr[5]=0x02;
   5953           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5954            hr[2]=0x0B;hr[4]=0xdA;hr[5]=0x02;
   5955           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5956             hr[2]=0x0C;hr[4]=0xdD;hr[5]=0xFE;
   5957           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5958             hr[2]=0x0D;hr[4]=0xdC;hr[5]=0xFE;
   5959           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5960             hr[2]=0x0E;hr[4]=0xdF;hr[5]=0xFA;
   5961           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5962             hr[2]=0x0F;hr[4]=0xdE;hr[5]=0xFA;
   5963           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   5964             GenericApp_SendTheMessage();
   5965          } 
   5966          #endif
   5967          #if((SENSOR_TYPE ==0X5A)||(SENSOR_TYPE ==0X5B))
   5968           if(GenericApp_applicationbuf>6000)
   5969          {
   5970            GenericApp_applicationbuf=0;
   5971             GenericApp_SendTheMessage();
   5972          } 
   5973          if(GenericApp_ON_OFF>10)
   5974           { GenericApp_ON_OFF=0; 
   5975            GenericApp_applicationbuf=0;
   5976           uint8  hr[8]={0x02,0X03,0X00,0X2A,0X00,0X01,0XA5,0XF1};//DMAÄ£Ê½ RS485·¢ËÍ
   5977           HalUARTWrite(HAL_UART_PORT_0, hr,8);//DMAÄ£Ê½ RS485·¢ËÍ×îºóÁ½×Ö½Ú»á¶ªµô¡£ËùÒÔ¶àÌí¼ÓÁ½×Ö½Ú
   5978          }else GenericApp_ON_OFF++;
   5979          #endif
   5980          #if(SENSOR_TYPE ==0X70)
   5981           if(GenericApp_uart_485==1)
   5982             P1_0=0; 
   5983            if(GenericApp_uart_485==0)
   5984             GenericApp_uart_485=1; 
   5985          #endif
   5986          #if(SENSOR_TYPE ==0X13)
   5987          if(GenericApp_applicationbuf>6000)
   5988          {
   5989            GenericApp_applicationbuf=0;
   5990          #if defined(HUABANG) 
   5991           uint8  hr[8]={0xFF,0X03,0X00,0X00,0X00,0X02,0XD1,0XD5};
   5992           HalUARTWrite(HAL_UART_PORT_0, hr,8); 
   5993          #endif
   5994          #if defined(ammeter) 
   5995            uint8  hr[15]={0xFE,0X68,0X99,0X99,0X99,0X99,0X99,0X99,0X68,0X01,0X02,0X43,0XC3,0X6F,0X16};
   5996           HalUARTWrite(HAL_UART_PORT_0, hr,15);    
   5997          #endif
   5998          } 
   5999          #endif
   6000          #if(SENSOR_TYPE ==0X74)
   6001          if(GenericApp_applicationbuf>6000)
   6002          {GenericApp_applicationbuf=0;
   6003           {Send_data[7]=Send_data[8]=Send_data[9]=0XBB;}
   6004           Send_data[10]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9])%256;
   6005          GenericApp_SendTheMessage();
   6006          } 
   6007          #endif
   6008          #if(SENSOR_TYPE ==0X14)
   6009          if(GenericApp_applicationbuf>6000)
   6010          {
   6011            GenericApp_applicationbuf=0;
   6012          #if defined(PH_A)
   6013           //uint8  hr[8]={0x01,0x03,0x00,0x00,0x00,0x0C,0xA5,0xE2}; ¾ÉµÄ
   6014           uint8  hr[8]={0x01,0x03,0x00,0x00,0x00,0x0C,0x45,0xCF};// ÐÂµÄ
   6015           HalUARTWrite(HAL_UART_PORT_0, hr,8);
   6016          #endif
   6017          #if defined(PH_ORP)
   6018          uint8  hr[8]={0x00,0x03,0x00,0x00,0x00,0x02,0xC5,0xDA};
   6019          HalUARTWrite(HAL_UART_PORT_0, hr,8);
   6020          #endif
   6021          #if defined(PH_E201C)
   6022            float PH_A2;
   6023          unsigned int  PH;	
   6024          GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN5, HAL_ADC_RESOLUTION_8); //»·¾³ÎÂ¶È²É¼¯
   6025          Send_data[10]=((GenericApp_sbum*345)/4)>>8;   //LM35 Êä³ö0-150mv Ó²¼þ·Å´ó£¬Èí¼þ»¹Ô­
   6026          Send_data[11]=((GenericApp_sbum*345)/4);
   6027          GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8); //PH²É¼¯
   6028          /***********************ÒºÌåÎÂ¶È18B20²É¼¯**************************/
   6029           unsigned int  data;						    
   6030              float Temperature;
   6031                  Temperature = ReadTemperature();        //·µ»Ø16Î»¶þ½øÖÆÊý
   6032                  Temperature *= CelsiurPerLSB;		//×ª»»³É¸¡µãÐÍÎÂ¶ÈÖµ(ÉãÊÏ¶È)
   6033                   
   6034                  // data=(unsigned int)(100*Temperature);   
   6035                   data=(unsigned int)(Temperature);  
   6036           /***********************ÒºÌåÎÂ¶È18B20²É¼¯**************************/
   6037           /***********************PHÎÂ¶ÈÊý¾Ý´¦Àí**************************/
   6038           PH_A2=((float)(GenericApp_sbum*330)/127.0);  //Êµ¼Ê²É¼¯ÊýÖµ¶ÔÓ¦µçÑ¹Öµ  ÐèÊµ¼Êµ÷Õû
   6039           PH_A2=PH_A2-87.90;              //²É¼¯µçÑ¹Öµ¼õÈ¥87.90  ÐèÊµ¼Êµ÷Õû
   6040           PH_A2=1400.0-PH_A2/0.089;              //¼ÆËãPHÖµ
   6041           PH=(unsigned int)(PH_A2);      //PHÖµ
   6042           if(data<100){if(data>25)PH=PH+(data-25); else PH=PH-(25-data);}//  PHÖµ½øÐÐÎÂ¶È²¹³¥
   6043           Send_data[8]=(uint8)(PH>>8);
   6044           Send_data[9]=(uint8)(PH);
   6045           Send_data[7]=0XCC;
   6046           Send_data[12]=(Send_data[6]+Send_data[7]+Send_data[8]+Send_data[9]+Send_data[10]+Send_data[11])%256;
   6047          Send_datalend=0X07;
   6048          GenericApp_SendTheMessage();
   6049           /***********************ÒºPHÎÂ¶ÈÊý¾Ý´¦Àí*************************/
   6050           
   6051          #endif 
   6052          } 
   6053          #endif
   6054          #if(SENSOR_TYPE ==0X21)
   6055          if(GenericApp_ON_OFF>10)
   6056           { GenericApp_ON_OFF=0;
   6057           Send_data[7]=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   6058            if(((Send_data[7]-T_MUMPT1)>0X1A)||((T_MUMPT1-Send_data[7])>0X1A)||((Send_data[7]==0)&&(T_MUMPT1!=0)))
   6059            {T_MUMPT1=Send_data[7];
   6060             GenericApp_applicationbuf=6001;
   6061            }
   6062           }else GenericApp_ON_OFF++;
   6063          if(GenericApp_applicationbuf>6000)
   6064          {GenericApp_applicationbuf=0;
   6065          //GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   6066          Send_data[7]=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   6067          GenericApp_SendTheMessage();
   6068          }
   6069          #endif 
   6070          #if(SENSOR_TYPE ==0X66)
   6071          LEDtime++;
   6072          if(LEDtime>0)
   6073          {LEDtime=0;
   6074           switch(LED_HL)					  
   6075            {case 0:LED_HL=1;break; 
   6076            case 1:LED_HL=0;break;
   6077            default:LED_HL=0;break;
   6078            }
   6079           display();      //ÊýÂë¹ÜÉ¨Ãè³ÌÐò
   6080          }
   6081          #endif 
   6082          #if(SENSOR_TYPE ==0X76)
   6083          if(GenericApp_applicationbuf>300)
   6084          {
   6085          if((!P2_0)&&(0==p))
   6086          {p=1;lens++;
   6087          GenericApp_applicationbuf=0; 
   6088          GenericApp_SendTheMessage();
   6089          }
   6090          halMcuWaitMs(50); 
   6091          if(P2_0){p=0;}
   6092          Send_data[8]=lens/256;
   6093          Send_data[9]=lens%256;
   6094          }
   6095          
   6096          
   6097          if(GenericApp_applicationbuf>10000)
   6098          {GenericApp_applicationbuf=0;
   6099          lens=0;
   6100          }else GenericApp_applicationbuf++;
   6101          #endif 
   6102          
   6103          #if(SENSOR_TYPE =='G')
   6104          if(GenericApp_ON_OFF>90)
   6105           { GenericApp_ON_OFF=0;
   6106           switch(Coil_AB)
   6107            { 
   6108              case 1:Coil_A1;Coil_AB++;break;//Í¨µç´ÎÐò£º+A,+B,-A,-B
   6109              case 2:Coil_A2;Coil_AB++;break;
   6110              case 3:Coil_B1;Coil_AB++;break;
   6111              case 4:Coil_B2;Coil_AB=1;break;
   6112              
   6113              case 10:Coil_B2;Coil_AB++;break;//Í¨µç´ÎÐò£º+A,+B,-A,-B
   6114              case 11:Coil_B1;Coil_AB++;break;
   6115              case 12:Coil_A2;Coil_AB++;break;
   6116              case 13:Coil_A1;Coil_AB=10;break;
   6117               default:break;
   6118            }		
   6119           }else GenericApp_ON_OFF++;
   6120          #endif 
   6121          #if(SENSOR_TYPE ==0X30)
   6122          if(c68>1)c68--;
   6123          if(c68==1)
   6124          {c68=0;a68=0xab;b68=B01;}
   6125          static unsigned char i;	
   6126          if(P2_0)
   6127          while(b68)
   6128          {
   6129            if(P2_0==0)
   6130            {b68=0;
   6131             switch(a68)
   6132            { 
   6133            case 0XAB:for(int t=0;t<10;t++){Coil_B2;halMcuWaitMs(10);Coil_A2;halMcuWaitMs(10);Coil_B1;halMcuWaitMs(10);Coil_A1;halMcuWaitMs(10);}break;
   6134            case 0XBA:for(int t=0;t<10;t++){Coil_A1;halMcuWaitMs(10);Coil_B1;halMcuWaitMs(10);Coil_A2;halMcuWaitMs(10);Coil_B2;halMcuWaitMs(10);}break;
   6135               default:break;
   6136            }			
   6137            }
   6138            
   6139          halMcuWaitMs(20);
   6140          if((a68==0XAB)&&b68)	//Õý×ª±êÖ¾
   6141          {
   6142            switch(i)
   6143            { 
   6144              case 0:Coil_A1;i++;break;//Í¨µç´ÎÐò£º+A,+B,-A,-B
   6145              case 1:Coil_B1;i++;break;
   6146              case 2:Coil_A2;i++;break;
   6147              case 3:Coil_B2;i=0;b68--;break;
   6148               default:break;
   6149            }			
   6150          }  
   6151          else    
   6152            if((a68==0XBA)&&b68)	//·´×ª
   6153            { 
   6154              switch(i)
   6155              {						
   6156              case 0:Coil_B2;i++;break;
   6157              case 1:Coil_A2;i++;break;
   6158              case 2:Coil_B1;i++;break;
   6159              case 3:Coil_A1;i=0;b68--;break;
   6160              default:break;
   6161              }			
   6162            }		
   6163          }
   6164          if(b68==0)Coil_OFF ;
   6165          #endif
   6166          #if(SENSOR_TYPE ==0X73)
   6167          if(P2_0)
   6168          {if(b68)C68=1;
   6169          if((a68==0XAB)&&b68)	//Õý×ª±êÖ¾
   6170          {
   6171           DIR=0;b68-=CP;{CP=~CP; halMcuWaitUs(800);}
   6172          }  
   6173          else    
   6174          if((a68==0XBA)&&b68)	//·´×ª
   6175            { 
   6176           DIR=1;b68-=CP;{CP=~CP; halMcuWaitUs(800);}
   6177            }		
   6178          }
   6179          //else{b68=0;}
   6180           if(P2_0==0)
   6181            {b68=0;
   6182             if(C68)
   6183            {
   6184              halMcuWaitMs(5);
   6185             switch(a68)
   6186            { 
   6187            case 0XAB: DIR=1; for(int i=300;i>0;i--){CP=~CP; halMcuWaitUs(1500);}Send_data[10]=0XAB; GenericApp_applicationbuf=1; GenericApp_SendTheMessage(); break;
   6188            case 0XBA: DIR=0; for(int i=300;i>0;i--){CP=~CP; halMcuWaitUs(1500);}Send_data[10]=0XBA;  GenericApp_applicationbuf=1;GenericApp_SendTheMessage(); break;
   6189               default:break;
   6190            }C68=0;		
   6191            }
   6192            }
   6193          if(b68==0) 
   6194          {DIR=1;CP=1;}
   6195          #endif
   6196          #if(SENSOR_TYPE ==0X6A)
   6197          #if defined(HX711P) 
   6198          if(GenericApp_ON_OFF>10)
   6199           { GenericApp_ON_OFF=0;
   6200           AD_filter();//ADºÍÂË²¨
   6201           if((AD_Compar&0x800000)!=0x800000)
   6202           {
   6203                   AD_Compar=  AD_Compar/2;//ÇóÌåÖØ//¿ÇÌå²âÊÔ
   6204                   AD_Compar=  AD_Compar-Send_data[7];
   6205                  
   6206           }
   6207           else AD_Compar=0;
   6208           
   6209            Send_data[8]=AD_Compar/256;
   6210            Send_data[9]=AD_Compar%256;
   6211          
   6212          if(((Send_data[9]-T_MUMPT1)>0X50)||((T_MUMPT1-Send_data[9])>0X50)||((Send_data[9]==0)&&(T_MUMPT1!=0)))//
   6213            {T_MUMPT1=Send_data[9];
   6214             GenericApp_applicationbuf=6001;
   6215            }
   6216           }else GenericApp_ON_OFF++;
   6217          #endif 
   6218          if(GenericApp_applicationbuf>6000)
   6219          {GenericApp_applicationbuf=1;
   6220          GenericApp_switch=2;
   6221          #if defined(ADCP) 
   6222          Send_data[8]=0;
   6223          //GenericApp_sbum=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8);
   6224          Send_data[9]=HalAdcRead (HAL_ADC_CHN_AIN4, HAL_ADC_RESOLUTION_8)-Send_data[7];
   6225          #endif 
   6226          GenericApp_SendTheMessage();
   6227          }
   6228          #endif 
   6229          #if(SENSOR_TYPE ==0X23)
   6230             if(GenericApp_ON_OFF>1)
   6231             {GenericApp_ON_OFF=0;
   6232               if(SFG_R30X)
   6233             { char DD[17]={0xEF,0x01,0xFF,0xFF,0xFF,0xFF,0x01,0x00,0x08,0x04,0x01,0x00,0x00,0x00,0xFF,0x01,0x0D}; 
   6234                 SFG_R30X=0;
   6235               if(SFG_R30XA[0]==0x01)
   6236                 { 
   6237                     DD[8]=0x03;DD[9]=0X01;DD[10]=0X00 ;DD[11]=0X05;       //Â¼ÈëÍ¼Ïñ
   6238                     HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,12);
   6239                  }
   6240                    if(SFG_R30XA[0]==0x02)
   6241                 { 
   6242                     DD[8]=0x04;DD[9]=0X02;DD[10]=0X01 ;DD[11]=0X00;DD[12]=0X08; //Éú³ÉÌØÕ÷1
   6243                   HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,13);
   6244                 }
   6245                 if(SFG_R30XA[0]==0x03)
   6246                 {  
   6247                     DD[8]=0x03;DD[9]=0X01;DD[10]=0X00 ;DD[11]=0X05;       //Â¼ÈëÍ¼Ïñ
   6248                     HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,12);
   6249                  }
   6250                  if(SFG_R30XA[0]==0x04)
   6251                 { 
   6252                     DD[8]=0x04;DD[9]=0X02;DD[10]=0X02 ;DD[11]=0X00; DD[12]=0X09; //Éú³ÉÌØÕ÷2
   6253                     HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,13);
   6254                 }
   6255                  if(SFG_R30XA[0]==0x05)
   6256                 {
   6257                     DD[8]=0x03;DD[9]=0X05;DD[10]=0X00 ;DD[11]=0X09;  //ºÏ²¢ÌØÕ÷
   6258                      HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,12);
   6259                 }
   6260                  if(SFG_R30XA[0]==0x06)
   6261                 { 
   6262                     DD[8]=0x06;DD[9]=0X06;DD[10]=0X02 ;DD[11]=SFG_R30XA[1]; DD[12]=SFG_R30XA[2]; //DD[13]=0X00;DD[14]=0X10;//´æ´¢ÌØÕ÷
   6263                     DD[13]=(1+DD[8]+DD[9]+DD[10]+DD[11]+DD[12])/256;  DD[14]=(1+DD[8]+DD[9]+DD[10]+DD[11]+DD[12])%256;
   6264                     HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,15);
   6265                   }
   6266                   if(SFG_R30XA[0]==0xA1)//ËÑË÷
   6267                   { DD[8]=0x03;DD[9]=0X01;DD[10]=0X00 ;DD[11]=0X05;       //Â¼ÈëÍ¼Ïñ
   6268                     HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,12);
   6269                   }
   6270                    if(SFG_R30XA[0]==0xA2)
   6271                    { DD[8]=0x04;DD[9]=0X02;DD[10]=0X01 ;DD[11]=0X00;DD[12]=0X08; //Éú³ÉÌØÕ÷1
   6272                     HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,13);
   6273                    }
   6274                     if(SFG_R30XA[0]==0xA3)
   6275                     {
   6276                     DD[8]=0x08;DD[9]=0X04;DD[10]=0X01 ;DD[11]=0X00; DD[12]=0X00; DD[13]=0X00;DD[14]=0XFF;DD[15]=0X01;DD[16]=0X0D;//¶Ô±ÈÍ¼Ïñ
   6277                     HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,17);
   6278                     }
   6279                  if(SFG_R30XA[0]==0x21)
   6280                  {
   6281                    if((SFG_R30XA[1]==0xFF)&&(SFG_R30XA[2]==0xFF))//Çå¿ÕÖ¸ÎÆ¿â
   6282                    {
   6283                    DD[8]=0x03;DD[9]=0X0D;DD[10]=0X00 ;DD[11]=0X11;       
   6284                     HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,12);
   6285                     }
   6286                    else
   6287                    {DD[8]=0x07;DD[9]=0X0c;DD[10]=SFG_R30XA[1] ;DD[11]=SFG_R30XA[2]; DD[12]=0x00;DD[13]=0x01; //Çå¿ÕÖ¸ÎÆ¿â
   6288                    DD[14]=(2+DD[8]+DD[9]+DD[10]+DD[11]+DD[12])/256;  DD[15]=(2+DD[8]+DD[9]+DD[10]+DD[11]+DD[12])%256;
   6289                    HalUARTWrite(HAL_UART_PORT_0, (uint8*)DD,16);
   6290                    }
   6291                  }
   6292                  if(SFG_R30XA[0]==0xBB)
   6293                 {GenericApp_applicationbuf=1;
   6294                  Send_data[7]=0XAA;
   6295                 Send_data[8]=SFG_R30XA[1];Send_data[9]=SFG_R30XA[2];
   6296                   GenericApp_SendTheMessage();
   6297                   }
   6298                if(SFG_R30XA[0]==0xDD)
   6299                 {GenericApp_applicationbuf=1;
   6300                  Send_data[7]=0XCC;
   6301                 Send_data[8]=SFG_R30XA[1];Send_data[9]=SFG_R30XA[2];
   6302                   GenericApp_SendTheMessage();
   6303                   }
   6304                    if(SFG_R30XA[0]==0xCC)
   6305                 {  GenericApp_applicationbuf=1;
   6306                  Send_data[7]=0XBB;
   6307                   GenericApp_SendTheMessage();
   6308                   SFG_R30XA[0]=0xA1;SFG_R30X=1;
   6309                   }
   6310                   }
   6311             }
   6312             else GenericApp_ON_OFF++;
   6313          #endif
   6314          #if(SENSOR_TYPE =='Q')
   6315           if(GenericApp_ON_OFF>2)
   6316           { GenericApp_ON_OFF=0;
   6317           if( HXS>0X00)//ÆÁÄ»¹Ì¶¨ÊýÖµÉÁË¸
   6318           {        // for(char p=0;p<3;p++)
   6319              HXtime++;
   6320                     if(HXS>0X02)
   6321                      {
   6322                       if(HXtime==1)
   6323                        Ht1621WrAllData(0,Ht1621Tab,9);//Çå³ý1621¼Ä´æÆ÷Êý¾Ý£¬ôßÇåÆÁ //SEG0¡«SEG17 COM0-3=0X00 0000 È«Ãð
   6324                       if(HXtime>2)
   6325                       { {HXtime=0;HXS--;}
   6326                        P1_0=0;
   6327          #if defined(SHINING75MIL) 
   6328                        Ht1621WrOneData(9,0X01); //KG
   6329                      if(((AD_Compar/100)%10)!=0)
   6330                      { if(AD_Compar/1000)
   6331                         Ht1621WrOneData(1,(table2[(AD_Compar/100)%10])|0x01);//SEG2 COM0-3=table2[9]=0X0D 1101 Êý×Ö9  |°ÙÎ»1
   6332                         else
   6333                         Ht1621WrOneData(1,table2[(AD_Compar/100)%10]);//SEG2 COM0-3=table2[9]=0X0D 1101 Êý×Ö9
   6334                         
   6335                         Ht1621WrOneData(0,table1[(AD_Compar/100)%10]);//SEG1 COM0-3=table1[9]=0X0E 1110 Êý×Ö9
   6336                      }
   6337                        Ht1621WrOneData(2,table1[(AD_Compar/10)%10]);//SEG1 COM0-3=table1[9]=0X0E 1110 Êý×Ö9
   6338                        Ht1621WrOneData(3,table2[(AD_Compar/10)%10]|0X01);//SEG2 COM0-3=table2[9]=0X0D 1101 Êý×Ö9
   6339                        Ht1621WrOneData(4,table1[(AD_Compar%10)]);//SEG1 COM0-3=table1[9]=0X0E 1110 Êý×Ö9
   6340                        if(PAN_ID_Success==2)
   6341                        Ht1621WrOneData(5,(table2[(AD_Compar%10)])|0X01);//SEG2 COM0-3=table2[9]=0X0D 1101 Êý×Ö9 | M Ìí¼ÓÍøÂçÏÔÊ¾M
   6342                        else
   6343                        Ht1621WrOneData(5,table2[(AD_Compar%10)]);//SEG2 COM0-3=table2[9]=0X0D 1101 Êý×Ö9
   6344                        
   6345                        Ht1621WrOneData(6,table1[0]);//SEG1 COM0-3=table1[9]=0X0E 1110 Êý×Ö9
   6346                        Ht1621WrOneData(7,table2[0]);//SEG2 COM0-3=table2[9]=0X0D 1101 Êý×Ö9
   6347          #endif
   6348          #if defined(SHINING100MIL)  
   6349          Ht1621WrOneData(8,0X0C); //¹«½ï
   6350           if(PAN_ID_Success==2)
   6351                        {
   6352                        Ht1621WrOneData(0,table1[AD_Compar/1000]);//SEG1 COM0-3=table1[9]=0X0E 1110 Êý×Ö9
   6353                        Ht1621WrOneData(1,table2[AD_Compar/1000]);//SEG2 COM0-3=table2[9]=0X0D 1101 Êý×Ö9
   6354                        }
   6355                        Ht1621WrOneData(2,table1[(AD_Compar/100)%10]);//SEG1 COM0-3=table1[9]=0X0E 1110 Êý×Ö9
   6356                        Ht1621WrOneData(3,table2[(AD_Compar/100)%10]);//SEG2 COM0-3=table2[9]=0X0D 1101 Êý×Ö9
   6357                        Ht1621WrOneData(4,table1[(AD_Compar/10)%10]);//SEG1 COM0-3=table1[9]=0X0E 1110 Êý×Ö9
   6358                        Ht1621WrOneData(5,table2[(AD_Compar/10)%10]|0X01);//SEG2 COM0-3=table2[9]=0X0D 1101 Êý×Ö9
   6359                        Ht1621WrOneData(6,table1[(AD_Compar%10)]);//SEG1 COM0-3=table1[9]=0X0E 1110 Êý×Ö9
   6360                        Ht1621WrOneData(7,table2[(AD_Compar%10)]);//SEG2 COM0-3=table2[9]=0X0D 1101 Êý×Ö9
   6361          #endif
   6362                    }
   6363                     
   6364           }
   6365           else
   6366           {
   6367                     if(HXtime>8)
   6368                     {HXtime=0;HXS=0;
   6369                      Send_datalend=0x03;  
   6370                      Send_data[7]=RS;
   6371                      Send_data[8]=(Send_data[6]+Send_data[7])%256;
   6372                      GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   6373                      Ht1621WrAllData(0,Ht1621Tab,9);//Çå³ý1621¼Ä´æÆ÷Êý¾Ý£¬ôßÇåÆÁ //SEG0¡«SEG17 COM0-3=0X00 0000 È«Ãð
   6374                       P1_0=1;
   6375                       RSn=0;
   6376                       T_MUMPT1=21;
   6377                     }
   6378           }
   6379           }
   6380           else 
   6381           {          AD_filter();//ADºÍÂË²¨
   6382                    // AD_Compar=  AD_Compar/80;//ÇóÌåÖØ //²ÎÕÕ
   6383                      AD_Compar=  10*AD_Compar;//ÇóÌåÖØ//¿ÇÌå²âÊÔ
   6384                      AD_Compar=  AD_Compar/AD_SHINING;//ÇóÌåÖØ//¿ÇÌå²âÊÔ
   6385                     if((AD_Compar<10)&&(AD_Compar>(-5)))AD_Compar=0;
   6386                     RS=AD_Compar/10;
   6387                     if(T_MUMPT1<20)
   6388                      {
   6389                        P1_0=0;
   6390          #if defined(SHINING75MIL) 
   6391                        Ht1621WrOneData(9,0X01); //KG
   6392                      if(((AD_Compar/100)%10)!=0)
   6393                      { if(AD_Compar/1000)
   6394                         Ht1621WrOneData(1,(table2[(AD_Compar/100)%10])|0x01);//SEG2 COM0-3=table2[9]=0X0D 1101 Êý×Ö9  |°ÙÎ»1
   6395                         else
   6396                         Ht1621WrOneData(1,table2[(AD_Compar/100)%10]);//SEG2 COM0-3=table2[9]=0X0D 1101 Êý×Ö9
   6397                         
   6398                         Ht1621WrOneData(0,table1[(AD_Compar/100)%10]);//SEG1 COM0-3=table1[9]=0X0E 1110 Êý×Ö9
   6399                      }
   6400                        Ht1621WrOneData(2,table1[(AD_Compar/10)%10]);//SEG1 COM0-3=table1[9]=0X0E 1110 Êý×Ö9
   6401                        Ht1621WrOneData(3,table2[(AD_Compar/10)%10]|0X01);//SEG2 COM0-3=table2[9]=0X0D 1101 Êý×Ö9
   6402                        Ht1621WrOneData(4,table1[(AD_Compar%10)]);//SEG1 COM0-3=table1[9]=0X0E 1110 Êý×Ö9
   6403                        if(PAN_ID_Success==2)
   6404                        Ht1621WrOneData(5,(table2[(AD_Compar%10)])|0X01);//SEG2 COM0-3=table2[9]=0X0D 1101 Êý×Ö9 | M Ìí¼ÓÍøÂçÏÔÊ¾M
   6405                        else
   6406                        Ht1621WrOneData(5,table2[(AD_Compar%10)]);//SEG2 COM0-3=table2[9]=0X0D 1101 Êý×Ö9
   6407                        
   6408                        Ht1621WrOneData(6,table1[0]);//SEG1 COM0-3=table1[9]=0X0E 1110 Êý×Ö9
   6409                        Ht1621WrOneData(7,table2[0]);//SEG2 COM0-3=table2[9]=0X0D 1101 Êý×Ö9
   6410          #endif
   6411          #if defined(SHINING100MIL)  
   6412          Ht1621WrOneData(8,0X0C); //¹«½ï
   6413           if(PAN_ID_Success==2)
   6414                        {
   6415                        Ht1621WrOneData(0,table1[AD_Compar/1000]);//SEG1 COM0-3=table1[9]=0X0E 1110 Êý×Ö9
   6416                        Ht1621WrOneData(1,table2[AD_Compar/1000]);//SEG2 COM0-3=table2[9]=0X0D 1101 Êý×Ö9
   6417                        }
   6418                        Ht1621WrOneData(2,table1[(AD_Compar/100)%10]);//SEG1 COM0-3=table1[9]=0X0E 1110 Êý×Ö9
   6419                        Ht1621WrOneData(3,table2[(AD_Compar/100)%10]);//SEG2 COM0-3=table2[9]=0X0D 1101 Êý×Ö9
   6420                        Ht1621WrOneData(4,table1[(AD_Compar/10)%10]);//SEG1 COM0-3=table1[9]=0X0E 1110 Êý×Ö9
   6421                        Ht1621WrOneData(5,table2[(AD_Compar/10)%10]|0X01);//SEG2 COM0-3=table2[9]=0X0D 1101 Êý×Ö9
   6422                        Ht1621WrOneData(6,table1[(AD_Compar%10)]);//SEG1 COM0-3=table1[9]=0X0E 1110 Êý×Ö9
   6423                        Ht1621WrOneData(7,table2[(AD_Compar%10)]);//SEG2 COM0-3=table2[9]=0X0D 1101 Êý×Ö9
   6424                    
   6425          #endif
   6426                   }  
   6427                     if(((RSn>RS)?(RSn-RS):(RS-RSn))>1)
   6428                        {T_MUMPT1=0;
   6429                        RSn=RS;
   6430                        }
   6431                    else   
   6432                  {
   6433                    RSn=RS;
   6434                    if(T_MUMPT1<8)T_MUMPT1++;
   6435                    else
   6436                    { 
   6437                     if(AD_Compar<50)
   6438                     { 
   6439                      if(AD_Compar==0)
   6440                      {
   6441                       Ht1621WrAllData(0,Ht1621Tab,9);//Çå³ý1621¼Ä´æÆ÷Êý¾Ý£¬ôßÇåÆÁ //SEG0¡«SEG17 COM0-3=0X00 0000 È«Ãð
   6442                       P1_0=1;
   6443                       T_MUMPT1=21;
   6444                      }
   6445                      else 
   6446                       {T_MUMPT1=0;
   6447                       Tozero();//×Ô¶¯¹éÁã
   6448                      }
   6449                     }
   6450                     else 
   6451                     {HXS=0X05;
   6452                     Send_datalend=0x03;  
   6453                      Send_data[7]=RS;
   6454                      Send_data[8]=(Send_data[6]+Send_data[7])%256;
   6455                      GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   6456                     }
   6457                     
   6458                    }
   6459                  }
   6460            }
   6461          }else GenericApp_ON_OFF++;
   6462          #endif
   6463          #if(SENSOR_TYPE =='D')
   6464           if(GenericApp_applicationbuf>6000)
   6465            { P1_3=1;
   6466              GenericApp_applicationbuf=0;
   6467              for(unsigned int i=0;i<50000;i++);
   6468              GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   6469            }
   6470          #endif
   6471          #if(SENSOR_TYPE ==0X33)
   6472           if(GenericApp_ON_OFF>10)
   6473           { GenericApp_ON_OFF=0;
   6474          B_LUX30_Multiple_read(0X00,&Send_data[8],4);
   6475          
   6476          if(((Send_data[9]-T_MUMPT1)>0X04)||((T_MUMPT1-Send_data[9])>0X04)||((Send_data[9]==0)&&(T_MUMPT1!=0)))//327 Lux
   6477            {T_MUMPT1=Send_data[9];
   6478             GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   6479            }
   6480           }else GenericApp_ON_OFF++;
   6481           
   6482          if(GenericApp_applicationbuf>6000)
   6483            {GenericApp_applicationbuf=0;
   6484              GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   6485            }
   6486          #endif
   6487          #if(SENSOR_TYPE ==0X85)
   6488          if(GenericApp_ON_OFF>10)
   6489           { GenericApp_ON_OFF=0;
   6490               unsigned char     slaveaddress;	 			  
   6491               unsigned long int    DATA;  
   6492               unsigned char tempbat[2];
   6493               
   6494              slaveaddress=MEM_READ(0x00,0x10);
   6495                   //¶ÁÈ¡´æÓÚMLX90615 EEPROM "00h"µØÖ·ÖÐµÄSMBusµØÖ·
   6496                   DATA=MEM_READ(slaveaddress,0x27);
   6497                   //»ùÓÚÉÏÊöµØÖ·ÓÉMLX90615µÄÄÚ´æ07hÖÐ¶ÁÈ¡ÎïÌåÎÂ¶È
   6498                    CALTEMP(DATA,tempbat);	
   6499                   //»ùÓÚËùµÃµÄÊ®Áù½øÖÆÎÂ¶È¸ñÊ½¼ÆËãÊµ¼ÊÎÂ¶È
   6500                   // UartTX_Send_String(tempbat,5);	
   6501                     int temp;
   6502                    temp=(tempbat[0]*100+tempbat[0]);
   6503                      data[4]=temp>>8;
   6504                      data[5]=temp;
   6505                      data[8]= data[0]+data[1]+data[2]+data[3]+data[4]+data[5]+data[6]+data[7];
   6506          
   6507                      Send_data[7]=0xAA;
   6508                      Send_data[8]=tempbat[0];//ÕûÊý²¿·Ö
   6509                      Send_data[9]=tempbat[1];//Ð¡Êý²¿·Ö
   6510                      Send_data[10]=0xAA;    //±£Áô
   6511                      Send_data[11]=0xAA;    //±£Áô
   6512                   if(((Send_data[8]>T_MUMPT1)?( Send_data[8]-T_MUMPT1):(T_MUMPT1-Send_data[8]))>0X01) //´óÓÚ1
   6513                   {T_MUMPT1=Send_data[8];
   6514                   GenericApp_applicationbuf=6001;
   6515                   }
   6516          
   6517           }else GenericApp_ON_OFF++;
   6518           if(GenericApp_applicationbuf>6000)
   6519            {GenericApp_applicationbuf=0;
   6520            HalUARTWrite(HAL_UART_PORT_0,data,9);
   6521              GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   6522            }
   6523          #endif
   6524          #if defined (NB_IOT_S10)
   6525           
   6526           if(NBjishu>5)
   6527           { 
   6528           //{"Nbiot-up":{"IMEI":"0123456789ABCDEF","HUMITURE":"25-36"}}
   6529           //{"Nbiot-up" //"7b224e62696f742d757022"
   6530           //:{"IMEI"// "3a7b22494d454922"
   6531           //:"0123456789ABCDEF"//"3a223031323334353637383941424344454622"
   6532           //,"HUMITURE" //"2c2248554d495455524522"
   6533           //:"25-36"}}//"3a2232352d3336227d7d"
   6534            uint8 tmp[32]={0};
   6535             NBjishu=0;
   6536           switch(NBliucheng)
   6537           {case 0: HalUARTWrite(HAL_UART_PORT_0,"AT+NRB\r\n",8);
   6538                    HalUARTWrite(HAL_UART_PORT_0,"AT+NCONFIG=AUTOCONNECT,TRUE\r\n",29);break;
   6539            case 1: HalUARTWrite(HAL_UART_PORT_0,"AT+NBAND=5\r\n",12);break;
   6540            case 2: HalUARTWrite(HAL_UART_PORT_0,"AT+CFUN=1\r\n",11);break;
   6541            case 3: HalUARTWrite(HAL_UART_PORT_0,"AT+CIMI\r\n",9);break;
   6542            case 4: HalUARTWrite(HAL_UART_PORT_0,"AT+CGDCONT=1,\"IP\",\"CTNB\"\r\n",26);break;
   6543            case 5: HalUARTWrite(HAL_UART_PORT_0,"AT+CGATT=1\r\n",12);break;
   6544            case 6: HalUARTWrite(HAL_UART_PORT_0,"AT+COPS=1,2,\"46011\"\r\n",21);break;
   6545            case 7: HalUARTWrite(HAL_UART_PORT_0,"AT+CGSN=1\r\n",11);break; //¶ÁÈ¡IMEIºÅ
   6546            case 15: HalUARTWrite(HAL_UART_PORT_0,"AT+CGATT?\r\n",11);break; //ÈëÍø³É¹¦
   6547            case 16: HalUARTWrite(HAL_UART_PORT_0,"AT+NSOCR=DGRAM,17,5050,1\r\n",26);break;//´´½¨Socket 5050
   6548            case 17: //strcat((char*)tmp, (char const*)tmp1);
   6549               for(int i=0;i<16;i++)
   6550              {  tmp[2*i]='3';tmp[2*i+1]=NB_IMEI[i];}
   6551              tmp[31]='0';
   6552              
   6553              HalUARTWrite(HAL_UART_PORT_0,"AT+NSOST=0,139.196.218.156,5050,56,",35);//·¢ËÍÊý¾Ý
   6554              HalUARTWrite(HAL_UART_PORT_0,"7b224e622d757022",16);//·¢ËÍÊý¾Ý  //{"Nb-up" //"7b224e622d757022"
   6555              HalUARTWrite(HAL_UART_PORT_0,"3a7b22494d4549223a22",20);//·¢ËÍÊý¾Ý  //:{"IMEI":"// "3a7b22494d4549223a22"
   6556              //HalUARTWrite(HAL_UART_PORT_0,"30313233343536373839414243444546",32);//·¢ËÍÊý¾Ý  //0123456789ABCDEF//"30313233343536373839414243444546"
   6557              HalUARTWrite(HAL_UART_PORT_0,tmp,32);//·¢ËÍÊý¾Ý  //0123456789ABCDEF//"30313233343536373839414243444546"
   6558              NBjishu=4;NBliucheng=18;break;
   6559           case 18: //Send_data[7]=34; Send_data[9]=60;
   6560               tmp[0]='3';
   6561               if((Send_data[9])<100){tmp[1]=(Send_data[9]/10)+0X30;}else tmp[1]='0'; //ÕûÊýÎ»
   6562               tmp[2]='3';
   6563               if((Send_data[9])<100){tmp[3]=(Send_data[9]%10)+0X30;}else tmp[3]='0';
   6564               tmp[4]='2';
   6565               tmp[5]='d';
   6566               tmp[6]='3';
   6567               if((Send_data[7])<100){tmp[7]=(Send_data[7]/10)+0X30;}else tmp[7]='0'; //ÕûÊýÎ»
   6568               tmp[8]='3';
   6569               if((Send_data[7])<100){tmp[9]=(Send_data[7]%10)+0X30;}else tmp[9]='0';
   6570               HalUARTWrite(HAL_UART_PORT_0,"222c2248554d4954555245223a22",28);//·¢ËÍÊý¾Ý   //:,"HUMITURE":" //"222c2248554d4954555245223a22"
   6571             // HalUARTWrite(HAL_UART_PORT_0,"32352d3336",10);//·¢ËÍÊý¾Ý  //25-36//"32352d3336"
   6572               HalUARTWrite(HAL_UART_PORT_0,tmp,10);//·¢ËÍÊý¾Ý  //25-36//"32352d3336"
   6573              HalUARTWrite(HAL_UART_PORT_0,"227d7d\r\n",8);NBliucheng=100;break;//·¢ËÍÊý¾Ý  //}} //227d7d//½áÊø·û
   6574              
   6575            case 19: HalUARTWrite(HAL_UART_PORT_0,"AT+NSORF=0,100\r\n",16);break;//¶ÁÈ¡Êý¾Ý
   6576            case 30: HalUARTWrite(HAL_UART_PORT_0,"AT+NSORF=0,100\r\n",16);break;//¶ÁÈ¡Êý¾Ý
   6577            case 40: HalUARTWrite(HAL_UART_PORT_0,"AT+NSORF=0,100\r\n",16);break;//¶ÁÈ¡Êý¾Ý
   6578            case 100:break;//ÍË³ö
   6579            default:break;//ÍË³ö
   6580          
   6581           }
   6582           //NBliucheng++;
   6583           
   6584            if(NBliucheng>50)NBliucheng--;
   6585            if(NBliucheng==55)NBliucheng=17;
   6586           }
   6587           else NBjishu++;
   6588          
   6589          #endif
   6590           
   6591          #if(SENSOR_TYPE =='E')
   6592          if(GenericApp_ON_OFF>10)
   6593           { GenericApp_ON_OFF=0;
   6594           uint  data;
   6595            valuen humi_val,temp_val;							    
   6596            unsigned char error,checksum; 
   6597           error=0;  
   6598                     error+=s_measure( &Send_data[7],&checksum,HUMI);  //measure humidity 
   6599                     error+=s_measure( &Send_data[9],&checksum,TEMP);  //measure temperature 
   6600                    if(error!=0) s_connectionreset();                  //in case of an error: connection  
   6601                    else 
   6602                    { humi_val.i=Send_data[7]*256+Send_data[8];
   6603                      temp_val.i=Send_data[9]*256+Send_data[10];
   6604                      humi_val.f=(float)humi_val.i;                   //converts integer to float
   6605                      temp_val.f=(float)temp_val.i;                   //converts integer to float
   6606                      calc_dht90(&humi_val.f,&temp_val.f);            //calculate humidity, temperature
   6607           Send_data[6]=SENSOR_TYPE;//´«¸ÐÆ÷ÀàÐÍ
   6608            data=(uint)(100*humi_val.f);   
   6609           Send_data[7]=(uint8)(data/ 100);
   6610            Send_data[8]=(uint8)(data % 100);
   6611            data=(uint)(100*temp_val.f);              
   6612            Send_data[9]=(uint8)(data / 100);
   6613            Send_data[10]=(uint8)(data % 100);
   6614                    }
   6615          if(((Send_data[9]-T_MUMPT1)>0X01)||((T_MUMPT1-Send_data[9])>0X01))//ÎÂ¶ÈÖµ
   6616            {T_MUMPT1=Send_data[9];
   6617            GenericApp_applicationbuf=6001;
   6618            }
   6619           }else GenericApp_ON_OFF++;
   6620          
   6621          
   6622            if(GenericApp_applicationbuf>6000)
   6623            {GenericApp_applicationbuf=0;
   6624          
   6625          #if defined (NB_IOT_S10)
   6626             if(NBliucheng>50)NBliucheng=17;
   6627           //  P0_4=~P0_4;
   6628          #endif
   6629              GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   6630            }
   6631          
   6632          #endif
   6633          #if(SENSOR_TYPE ==0X82)
   6634          if(GenericApp_ON_OFF>10)
   6635           { GenericApp_ON_OFF=0;
   6636            Multiple_Read_HMC5883();      //Á¬Ðø¶Á³öÊý¾Ý£¬´æ´¢ÔÚBUFÖÐ
   6637              //---------ÏÔÊ¾XÖá
   6638             // HMC5883_x=(BUF[0] << 8 | BUF[1]); //Combine MSB and LSB of X Data output register
   6639             // HMC5883_z=(BUF[2] << 8 | BUF[3]); //Combine MSB and LSB of Z Data output register
   6640             // HMC5883_y=(BUF[4] << 8 | BUF[5]); //Combine MSB and LSB of Y Data output register
   6641          
   6642            //HMC5883_x = atan2((float)(0.92* (BUF[4] << 8 | BUF[5])),(float)(0.92* (BUF[0] << 8 | BUF[1])));
   6643            //HMC5883_y = atan2((float)(0.92* (BUF[2] << 8 | BUF[3])),(float)(0.92* (BUF[0] << 8 | BUF[1])));
   6644            //HMC5883_z= atan2((float)(0.92* (BUF[2] << 8 | BUF[3])),(float)(0.92* (BUF[4] << 8 | BUF[5])));
   6645            //HMC5883_x =((HMC5883_x < 0)?(HMC5883_x += 2*PI):(HMC5883_x -= 2*PI)) * 180/M_PI;
   6646            //HMC5883_y =((HMC5883_y < 0)?(HMC5883_y += 2*PI):(HMC5883_y -= 2*PI)) * 180/M_PI;
   6647           // HMC5883_z =((HMC5883_z < 0)?(HMC5883_z += 2*PI):(HMC5883_z -= 2*PI)) * 180/M_PI;
   6648            
   6649              HMC5883_x= atan2((float)(BUF[4] << 8 | BUF[5]),(float)(BUF[0] << 8 | BUF[1])) * (180 / 3.14159265) + 180; // angle in degrees
   6650              HMC5883_y= atan2((float)(BUF[2] << 8 | BUF[3]),(float)(BUF[0] << 8 | BUF[1])) * (180 / 3.14159265) + 180; // angle in degrees
   6651              HMC5883_z= atan2((float)(BUF[2] << 8 | BUF[3]),(float)(BUF[4] << 8 | BUF[5])) * (180 / 3.14159265) + 180; // angle in degrees
   6652             
   6653             Send_data[8]=(int)HMC5883_x>>8;
   6654             Send_data[9]=(int)HMC5883_x;
   6655             Send_data[10]=(int)HMC5883_y>>8;
   6656             Send_data[11]=(int)HMC5883_y;
   6657             Send_data[12]=(int)HMC5883_z>>8;
   6658             Send_data[13]=(int)HMC5883_z;
   6659          if(((Send_data[9]>T_MUMPT1)?( Send_data[9]-T_MUMPT1):(T_MUMPT1-Send_data[9]))>0X05) //x½Ç¶È´óÓÚ5
   6660            {T_MUMPT1=Send_data[9];
   6661            GenericApp_applicationbuf=6001;
   6662            }
   6663          if(((Send_data[11]>T_MUMPT_y)?( Send_data[11]-T_MUMPT_y):(T_MUMPT_y-Send_data[11]))>0X05) //y½Ç¶È´óÓÚ5
   6664            {T_MUMPT_y=Send_data[11];
   6665            GenericApp_applicationbuf=6001;
   6666            }
   6667          if(((Send_data[13]>T_MUMPT_z)?( Send_data[13]-T_MUMPT_z):(T_MUMPT_z-Send_data[13]))>0X05) //z½Ç¶È´óÓÚ5
   6668            {T_MUMPT_z=Send_data[13];
   6669            GenericApp_applicationbuf=6001;
   6670            }
   6671           }else GenericApp_ON_OFF++;
   6672          
   6673            if(GenericApp_applicationbuf>6000)
   6674            {GenericApp_applicationbuf=0;
   6675              GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   6676            }
   6677          #endif
   6678            #if(SENSOR_TYPE ==0X81)
   6679          if(GenericApp_ON_OFF>10)
   6680           { GenericApp_ON_OFF=0;
   6681             GenericApp_sbum=read_max6675();
   6682             if(GenericApp_sbum==0X8001){Send_data[8]=1;Send_data[9]=0;Send_data[10]=0;}//1 ¿ªÂ·
   6683             else  { GenericApp_sbum=(GenericApp_sbum/4);
   6684             Send_data[8]=0;//Õý³£
   6685             Send_data[9]=(GenericApp_sbum>>8);
   6686             Send_data[10]=(GenericApp_sbum);
   6687          if(((Send_data[10]>T_MUMPT1)?( Send_data[10]-T_MUMPT1):(T_MUMPT1-Send_data[10]))>0X20) //ÎÂ¶È±ä»¯³¬¹ý 32¶È
   6688            {T_MUMPT1=Send_data[10];
   6689            GenericApp_applicationbuf=6001;
   6690            }
   6691          }
   6692           }else GenericApp_ON_OFF++;
   6693            if(GenericApp_applicationbuf>6000)
   6694            {GenericApp_applicationbuf=0;
   6695              GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   6696            }
   6697          #endif
   6698          #if((SENSOR_TYPE =='B')||(SENSOR_TYPE =='C')||(SENSOR_TYPE =='F')||(SENSOR_TYPE =='U'))
   6699            if(GenericApp_applicationbuf>6000)
   6700            {GenericApp_applicationbuf=0;
   6701              GenericApp_SendTheMessage(); //Ó¦ÓÃº¯Êý
   6702            }
   6703          #endif
   6704          #if(SENSOR_TYPE =='S')
   6705            if((P1&0XE0)!=GenericApp_appIO)
   6706            {
   6707               GenericApp_appIO=(P1&0XE0);
   6708             if(P1_5)
   6709              {
   6710                if(GenericApp_ON_OFF<0x71)
   6711                {
   6712                 if(GenericApp_ON_OFF>0x1F)
   6713                 GenericApp_ON_OFF+=0x05;
   6714               else
   6715                 GenericApp_ON_OFF=0x20;
   6716                }
   6717                else
   6718                  GenericApp_ON_OFF=0x75;
   6719               DimmingAppControl(GenericApp_ON_OFF,0X01);
   6720                 GenericApp_applicationbuf=1;
   6721                   GenericApp_SendTheMessage();
   6722              }
   6723                if(P1_7)
   6724              {
   6725                 if(GenericApp_ON_OFF>0x20)
   6726                 GenericApp_ON_OFF-=0x05;
   6727               else
   6728                 GenericApp_ON_OFF=0x00;
   6729               DimmingAppControl(GenericApp_ON_OFF,0X01);
   6730               GenericApp_applicationbuf=1;
   6731                   GenericApp_SendTheMessage();
   6732              }
   6733             if(P1_6)
   6734             { DimmingAppControl(0x00,0X01);
   6735               halMcuWaitMs(3000);
   6736                  if(P1_6)
   6737                  {  uint16 nv_data=0X0000;
   6738                      osal_nv_item_init( ZCD_NV_APP_R_E_KEY_P07,sizeof(nv_data), &nv_data );
   6739                      osal_nv_write( ZCD_NV_APP_R_E_KEY_P07, 0,sizeof(nv_data),&nv_data);  
   6740                     WDCTL = 0x00;WDCTL |= 0x09;  //0B  1.9MS  09  0.25Ãë
   6741          	}
   6742             }
   6743            } 
   6744          #endif
   6745          /*
   6746          #if(SENSOR_TYPE =='S')
   6747            if((P1&0XE0)!=GenericApp_appIO)
   6748            {
   6749               GenericApp_appIO=(P1&0XE0);
   6750             if(P1_6)
   6751              {
   6752                if(GenericApp_ON_OFF<0x71)
   6753                 GenericApp_ON_OFF+=0x05;
   6754               else
   6755                 GenericApp_ON_OFF=0x75;
   6756               DimmingAppControl(GenericApp_ON_OFF,0X01);
   6757                    GenericApp_KSH_H=1;
   6758                if(GenericApp_KSH>2)
   6759                   { 
   6760                      uint16 nv_data=0X0000;
   6761                      osal_nv_item_init( ZCD_NV_APP_R_E_KEY_P07,sizeof(nv_data), &nv_data );
   6762                      osal_nv_write( ZCD_NV_APP_R_E_KEY_P07, 0,sizeof(nv_data),&nv_data);
   6763                      WDCTL = 0x00;
   6764          	    WDCTL |= 0x0B;
   6765                   }
   6766              }
   6767                if(P1_7)
   6768              {  
   6769                 if(GenericApp_ON_OFF>0x07)
   6770                 GenericApp_ON_OFF-=0x05;
   6771               else
   6772                 GenericApp_ON_OFF=0x00;
   6773               DimmingAppControl(GenericApp_ON_OFF,0X01);
   6774               if(GenericApp_KSH_H)
   6775               {GenericApp_KSH86=0;
   6776                 GenericApp_KSH++;
   6777                GenericApp_KSH_H=0;
   6778               }
   6779               }
   6780            } 
   6781          #endif 
   6782          */
   6783            }
   6784          #if !defined (SENSOR_TYPE_Coord)
   6785          #if((SENSOR_TYPE ==0X66)||(SENSOR_TYPE ==0X73)||(SENSOR_TYPE ==0X76)||(SENSOR_TYPE =='G'))
   6786          if(GenericApp_ON_OFF>100)
   6787          {GenericApp_ON_OFF=0;
   6788            ZigBee_C_R_E_Engineering_I();
   6789          }
   6790          else GenericApp_ON_OFF++;
   6791          #else
   6792            ZigBee_C_R_E_Engineering_I();
   6793          #endif
   6794          #endif
   6795          }
   \   000000   02....       LJMP    ?BRET

   \                                 In  segment INTVEC, offset 0x5b, root
   \                     `??T3_IRQ??INTVEC 91`:
   \   00005B   02....       LJMP       (T3_IRQ)

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for Send_data>`:
   \   000000   FA0A0000     DB 250, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00000000
   \            00000000
   \   000010   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00000000
   \            00000000
   \   000020   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00000000
   \            00000000
   \   000030   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00000000
   \            00000000
   \   000040   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00000000
   \            00000000
   \   000050   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00000000
   \            00000000
   \   000060   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00000000
   \            00000000
   \   000070   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00000000
   \            00000000

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for T3_t1Val>`:
   \   000000   64000000     DD 100

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??OLED_delay?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OLED_delay

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??OLED_IIC_Start?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OLED_IIC_Start

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??OLED_IIC_Stop?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OLED_IIC_Stop

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??Write_IIC_Byte?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    Write_IIC_Byte

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??OLED_WrDat?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OLED_WrDat

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??OLED_WrCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OLED_WrCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??OLED_Set_Pos?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OLED_Set_Pos

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??OLED_Fill?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OLED_Fill

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??OLED_CLS?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OLED_CLS

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??OLED_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OLED_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??OLED_P8x16Str?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OLED_P8x16Str

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halSetTimer3Period?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halSetTimer3Period

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GenericApp_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GenericApp_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GenericApp_ProcessEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GenericApp_ProcessEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GenericApp_HandleKeys?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GenericApp_HandleKeys

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GenericApp_MessageMSGCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GenericApp_MessageMSGCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GenericApp_SendTheMessage?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GenericApp_SendTheMessage

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GenericAppCoordEB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GenericAppCoordEB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GenericAppEndDeviceEB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GenericAppEndDeviceEB

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "%04X">`:
   \   000000   25303458     DB "%04X"
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "R       ID:">`:
   \   000000   52202020     DB "R       ID:"
   \            20202020
   \            49443A00

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "%02d">`:
   \   000000   25303264     DB "%02d"
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "V2.45">`:
   \   000000   56322E34     DB "V2.45"
   \            3500    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "%02X%02X%02X%02X%02X%...">`:
   \   000000   25303258     DB "%02X%02X%02X%02X%02X%02X%02X%02X"
   \            25303258
   \            25303258
   \            25303258
   \            25303258
   \            25303258
   \            25303258
   \            25303258
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_7d:
   \   000000   7D000000     DD 125

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0

   Maximum stack usage in bytes:

     Function                     ISTACK PSTACK XSTACK
     --------                     ------ ------ ------
     GenericAppCoordEB                1      0     19
       -> AF_DataRequest              0      0     38
     GenericAppEndDeviceEB            0      0      0
     GenericApp_HandleKeys            0      0     54
       -> OLED_Init                   0      0     44
       -> OLED_P8x16Str               0      0     44
       -> osal_nv_read                0      0     52
       -> sprintf                     0      0     48
       -> OLED_P8x16Str               0      0     44
       -> osal_nv_read                0      0     52
       -> sprintf                     0      0     48
       -> OLED_P8x16Str               0      0     44
       -> OLED_P8x16Str               0      0     44
       -> NLME_GetCoordShortAddr      0      0     44
       -> sprintf                     0      0     48
       -> OLED_P8x16Str               0      0     44
       -> NLME_GetShortAddr           0      0     44
       -> sprintf                     0      0     48
       -> OLED_P8x16Str               0      0     44
       -> NLME_GetExtAddr             0      0     44
       -> sprintf                     0      0     76
       -> OLED_P8x16Str               0      0     44
       -> OLED_Init                   0      0     44
       -> OLED_P8x16Str               0      0     44
       -> osal_nv_read                0      0     52
       -> sprintf                     0      0     48
       -> OLED_P8x16Str               0      0     44
       -> osal_nv_read                0      0     52
       -> sprintf                     0      0     48
       -> OLED_P8x16Str               0      0     44
       -> OLED_P8x16Str               0      0     44
       -> NLME_GetCoordShortAddr      0      0     44
       -> sprintf                     0      0     48
       -> OLED_P8x16Str               0      0     44
       -> NLME_GetShortAddr           0      0     44
       -> sprintf                     0      0     48
       -> OLED_P8x16Str               0      0     44
       -> NLME_GetExtAddr             0      0     44
       -> sprintf                     0      0     76
       -> OLED_P8x16Str               0      0     44
     GenericApp_Init                  0      0      9
       -> afRegister                  0      0     18
       -> RegisterForKeys             0      0     18
     GenericApp_MessageMSGCB          2      0     16
       -> HalUARTWrite                4      0      0
       -> HalLedSet                   4      0      0
     GenericApp_ProcessEvent          0      0     20
       -> osal_msg_receive            0      0     32
       -> GenericApp_HandleKeys       0      0     32
       -> osal_msg_deallocate         0      0     32
       -> osal_msg_receive            0      0     32
       -> GenericApp_MessageMSGCB     0      0     32
       -> osal_start_timerEx          0      0     32
       -> osal_nv_read                0      0     40
       -> sprintf                     0      0     36
       -> OLED_P8x16Str               0      0     32
       -> NLME_GetCoordShortAddr      0      0     32
       -> sprintf                     0      0     36
       -> OLED_P8x16Str               0      0     32
       -> NLME_GetShortAddr           0      0     32
       -> sprintf                     0      0     36
       -> OLED_P8x16Str               0      0     32
       -> osal_start_timerEx          0      0     32
     GenericApp_SendTheMessage        0      0     19
       -> HalLedSet                   0      0     20
       -> HalLedSet                   0      0     20
       -> NLME_GetShortAddr           0      0     20
       -> NLME_GetShortAddr           0      0     20
       -> AF_DataRequest              0      0     38
       -> HalLedSet                   0      0     20
       -> HalLedSet                   0      0     20
     OLED_CLS                         0      0      9
       -> OLED_WrCmd                  0      0     18
       -> OLED_WrCmd                  0      0     18
       -> OLED_WrCmd                  0      0     18
       -> OLED_WrDat                  0      0     18
     OLED_Fill                        0      0      9
       -> OLED_WrCmd                  0      0     18
       -> OLED_WrCmd                  0      0     18
       -> OLED_WrCmd                  0      0     18
       -> OLED_WrDat                  0      0     18
     OLED_IIC_Start                   0      0      9
     OLED_IIC_Stop                    0      0      9
     OLED_Init                        2      0     22
       -> OLED_delay                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_WrCmd                  4      0      0
       -> OLED_Fill                   4      0      0
       -> OLED_Set_Pos                4      0      0
     OLED_P8x16Str                    0      0     38
       -> OLED_Set_Pos                0      0     32
       -> OLED_WrDat                  0      0     32
       -> OLED_Set_Pos                0      0     32
       -> OLED_WrDat                  0      0     32
     OLED_Set_Pos                     0      0     25
       -> OLED_WrCmd                  0      0     18
       -> OLED_WrCmd                  0      0     18
       -> OLED_WrCmd                  0      0     18
     OLED_WrCmd                       0      0     18
       -> OLED_IIC_Start              0      0     18
       -> Write_IIC_Byte              0      0     18
       -> Write_IIC_Byte              0      0     18
       -> Write_IIC_Byte              0      0     18
       -> OLED_IIC_Stop               0      0     18
     OLED_WrDat                       0      0     25
       -> OLED_IIC_Start              0      0     18
       -> Write_IIC_Byte              0      0     18
       -> Write_IIC_Byte              0      0     18
       -> Write_IIC_Byte              0      0     18
       -> OLED_IIC_Stop               0      0     18
     OLED_delay                       0      0      0
     T3_IRQ                           2      0     22
     Write_IIC_Byte                   0      0      9
     halSetTimer3Period               0      0      0


   Segment part sizes:

     Function/Label                         Bytes
     --------------                         -----
     _A_P2                                     1
     _A_IEN0                                   1
     T3CC0                                     1
     _A_TIMIF                                  1
     P2DIR                                     1
     F8X16                                  1520
     OLED_delay                               22
     ??Subroutine27_0                          6
     OLED_IIC_Start                           13
     ?Subroutine0                              2
     ??Subroutine26_0                          2
     OLED_IIC_Stop                            15
     Write_IIC_Byte                           45
     OLED_WrDat                               12
     ?Subroutine6                             11
     ?Subroutine2                             11
     ??Subroutine28_0                          5
     OLED_WrCmd                               12
     OLED_Set_Pos                             37
     OLED_Fill                                39
     ?Subroutine4                             15
     OLED_CLS                                 33
     OLED_Init                               138
     ?Subroutine1                              7
     ?Subroutine9                              9
     ?Subroutine8                              9
     ?Subroutine7                              9
     OLED_P8x16Str                           142
     ?Subroutine10                            14
     ?Subroutine5                             16
     Send_data                               128
     Send_datalend                             1
     AF_OK                                     1
     AF_RF                                     1
     AF_RFn                                    1
     AF_RFnd                                   1
     AF_RFnds                                  1
     chnnd                                   600
     GenericApp_applicationdata                2
     GenericApp_time                           1
     GenericApp_applicationbuf                 2
     GenericApp_uart_data                      2
     GenericApp_CR                             1
     openoff                                   1
     PWRMGR_ALWAYS_ON_OFF                      1
     OSAL_SET_CPU_INTO_SLEEP                   1
     GenericApp_sbum                           2
     GenericApp_KSH_H                          2
     GenericApp_KSH                            2
     GenericApp_KSH86                          2
     T3_t1Val                                  4
     t1Val                                     4
     T_MG                                      1
     T_MGSbit                                  1
     GenericApp_appIO                          1
     GenericApp_BX                             1
     GenericApp_ON_OFF                         2
     GenericApp_switch                         2
     GenericApp_switchk2                       2
     T_MUMPT1                                  1
     T_MUMPTS                                  2
     GenericApp_ClusterList                    2
     GenericApp_SimpleDesc                    12
     GenericApp_epDesc                         6
     GenericApp_TaskID                         1
     GenericApp_NwkState                       1
     GenericApp_TransID                        1
     GenericApp_DstAddr                       12
     halSetTimer3Period                        6
     T3_IRQ                                  109
     GenericApp_Init                         105
     ?Subroutine22                            10
     GenericApp_ProcessEvent                 310
     ?Subroutine20                             6
     ??Subroutine29_0                          8
     ?Subroutine16                             4
     ??Subroutine30_0                         10
     ?Subroutine21                            15
     GenericApp_HandleKeys                   543
     ?Subroutine23                            12
     ?Subroutine19                            27
     ?Subroutine18                            26
     ?Subroutine17                            15
     ?Subroutine25                            10
     ?Subroutine12                             1
     ??Subroutine31_0                          1
     ??Subroutine32_0                          1
     ??Subroutine33_0                          1
     ??Subroutine34_0                          1
     ??Subroutine35_0                          6
     ?Subroutine11                             1
     ??Subroutine36_0                          1
     ??Subroutine37_0                          1
     ??Subroutine38_0                          1
     ??Subroutine39_0                          1
     ??Subroutine40_0                          6
     GenericApp_MessageMSGCB                  49
     GenericApp_SendTheMessage               139
     ?Subroutine3                              5
     ?Subroutine14                            15
     GenericAppCoordEB                       548
     ?Subroutine24                            16
     ?Subroutine15                            12
     ?Subroutine13                            21
     GenericAppEndDeviceEB                     3
     ??T3_IRQ??INTVEC 91                       3
     ?<Initializer for Send_data>            128
     ?<Initializer for T3_t1Val>               4
     ??OLED_delay?relay                        6
     ??OLED_IIC_Start?relay                    6
     ??OLED_IIC_Stop?relay                     6
     ??Write_IIC_Byte?relay                    6
     ??OLED_WrDat?relay                        6
     ??OLED_WrCmd?relay                        6
     ??OLED_Set_Pos?relay                      6
     ??OLED_Fill?relay                         6
     ??OLED_CLS?relay                          6
     ??OLED_Init?relay                         6
     ??OLED_P8x16Str?relay                     6
     ??halSetTimer3Period?relay                6
     ??GenericApp_Init?relay                   6
     ??GenericApp_ProcessEvent?relay           6
     ??GenericApp_HandleKeys?relay             6
     ??GenericApp_MessageMSGCB?relay           6
     ??GenericApp_SendTheMessage?relay         6
     ??GenericAppCoordEB?relay                 6
     ??GenericAppEndDeviceEB?relay             6
     ?<Constant "%04X">                        5
     ?<Constant "R       ID:">                12
     ?<Constant "%02d">                        5
     ?<Constant "V2.45">                       6
     ?<Constant "%02X%02X%02X%02X%02X%...">   33
     __Constant_1                              4
     __Constant_7d                             4
     __Constant_0                              4

 
 2 561 bytes in segment BANKED_CODE
   114 bytes in segment BANK_RELAYS
 1 520 bytes in segment CODE_C
     3 bytes in segment INTVEC
   109 bytes in segment NEAR_CODE
     5 bytes in segment SFR_AN
   132 bytes in segment XDATA_I
   132 bytes in segment XDATA_ID
    87 bytes in segment XDATA_ROM_C
   663 bytes in segment XDATA_Z
 
 4 436 bytes of CODE  memory (+  3 bytes shared)
    75 bytes of CONST memory (+ 12 bytes shared)
     0 bytes of DATA  memory (+  5 bytes shared)
   795 bytes of XDATA memory

Errors: none
Warnings: 1
